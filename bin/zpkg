#!/bin/sh


# https://github.com/leleliu008/zpkg


COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;34m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf "%b" "$*"
}

echo() {
    print "$*\n"
}

info() {
    echo "$COLOR_PURPLE==>$COLOR_OFF $COLOR_GREEN$@$COLOR_OFF"
}

success() {
    print "${COLOR_GREEN}[âœ”] $*\n${COLOR_OFF}"
}

warn() {
    print "${COLOR_YELLOW}ðŸ”¥  $*\n${COLOR_OFF}"
}

error() {
    print "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}"
}

die() {
    print "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}"
    exit 1
}

# check if file exists
# $1 FILEPATH
file_exists() {
    [ -n "$1" ] && [ -e "$1" ]
}

# check if command exists in filesystem
# $1 command name or path
command_exists_in_filesystem() {
    case $1 in
        */*) executable "$1" ;;
        *)   command -v "$1" > /dev/null
    esac
}

executable() {
    file_exists "$1" && [ -x "$1" ]
}

die_if_file_is_not_exist() {
    file_exists "$1" || die "$1 is not exists."
}

die_if_not_executable() {
    executable "$1" || die "$1 is not executable."
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$@"
    echo
    echo "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

run() {
    info "$*"
    eval "$*"
}

list() {
    for item in $@
    do
        echo "$item"
    done
}

list_length() {
    echo $#
}

shiftn() {
    shift "$1" && shift && echo "$@"
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        unset SED_IN_PLACE_ACTION
        SED_IN_PLACE_ACTION="$1"
        shift
        # contains ' but not contains \'
        if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
            run gsed -i "\"$SED_IN_PLACE_ACTION\"" $@
        else
            run gsed -i "'$SED_IN_PLACE_ACTION'" $@
        fi
    elif command -v sed  > /dev/null ; then
        if sed -i 's/a/b/g' $(mktemp) 2> /dev/null ; then
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i "'$SED_IN_PLACE_ACTION'" $@
            fi
        else
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i '""' "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i '""' "'$SED_IN_PLACE_ACTION'" $@
            fi
        fi
    else
        die "please install sed utility."
    fi
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        echo "$1" | cut -d= -f2
    fi
}

trim() {
    if [ $# -eq 0 ] ; then
        sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    else
        if [ -n "$*" ] ; then
            echo "$*" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
        fi
    fi
}

tolower() {
    if [ $# -eq 0 ] ; then
        if command -v tr > /dev/null ; then
            tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            gawk '{print(tolower($0))}'
        else
            die "please install GNU CoreUtils or awk."
        fi
    else
        if [ -z "$*" ] ; then
            return 0
        fi
        if command -v tr > /dev/null ; then
            echo "$*" | tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            echo "$*" | awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            echo "$*" | gawk '{print(tolower($0))}'
        elif command -v python > /dev/null ; then
            python  -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python3 > /dev/null ; then
            python3 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python2 > /dev/null ; then
            python2 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v perl > /dev/null ; then
            perl -e 'print @ARGV[0],"\n"' "$1"
        elif command -v node > /dev/null ; then
            node -e 'console.log(process.argv[2].toLowerCase())' - "$*"
        else
            die "please install GNU CoreUtils or awk."
        fi
    fi
}

nproc() {
    if command nproc --version > /dev/null 2>&1 ; then
        command nproc
    elif test -f /proc/cpuinfo ; then
        grep -c processor /proc/cpuinfo
    elif command -v sysctl > /dev/null ; then
        sysctl -n machdep.cpu.thread_count
    else
        echo 4
    fi
}

is_integer () {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

# }}}
##############################################################################
# {{{ md5sum

#examples:
# printf ss | md5sum
# cat FILE  | md5sum
# md5sum < FILE
md5sum() {
    if [ $# -eq 0 ] ; then
        if echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl md5 | rev | cut -d ' ' -f1 | rev
        else
            return 1
        fi
    else
        if command -v openssl > /dev/null ; then
             openssl md5    "$1" | cut -d ' ' -f2
        elif echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum "$1" | cut -d ' ' -f1
        else
            die "please install openssl or GNU CoreUtils."
        fi
    fi
}

# }}}
##############################################################################
# {{{ sha256sum

#examples:
# printf ss | sha256sum
# cat FILE  | sha256sum
# sha256sum < FILE
sha256sum() {
    if [ $# -eq 0 ] ; then
        if echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl sha256 | rev | cut -d ' ' -f1 | rev
        else
            return 1
        fi
    else
        die_if_file_is_not_exist "$1"
        if command -v openssl > /dev/null ; then
             openssl sha256    "$1" | cut -d ' ' -f2
        elif echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum "$1" | cut -d ' ' -f1
        else
            die "please install openssl or GNU CoreUtils."
        fi
    fi
}

# $1 FILEPATH
# $2 expect sha256sum
file_exists_and_sha256sum_matched() {
    die_if_file_is_not_exist "$1"
    [ -z "$2" ] && die "please specify expected sha256sum."
    [ "$(sha256sum $1)" = "$2" ]
}

# $1 FILEPATH
# $2 expect sha256sum
die_if_sha256sum_mismatch() {
    file_exists_and_sha256sum_matched "$1" "$2" || die "sha256sum mismatch.\n    expect : $2\n    actual : $(sha256sum $1)"
}

# }}}
##############################################################################
# {{{ map

# $1 map_name
__map_name_ref() {
    die_if_map_name_is_not_specified "$1"
    printf "map_%s\n" "$(printf '%s' "$1" | md5sum)"
}

# $1 map_name
# $2 key
__map_key_ref() {
    die_if_map_name_is_not_specified   "$1"
    die_if_map_key__is_not_specified   "$2"
    printf "%s_%s\n" "$(__map_name_ref "$1")" "$(printf '%s' "$2" | md5sum)"
}

# $1 map_name
# $2 key
map_contains() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"
    for item in $(eval echo \$$(__map_name_ref "$1"))
    do
        [ "$item" = "$2" ] && return 0
    done
}

# $1 map_name
# $2 key
# $3 value
map_set() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"
    if ! map_contains "$1" "$2" ; then
        unset __MAP_NAME_REF__
        __MAP_NAME_REF__="$(__map_name_ref "$1")"
        __MAP_NAME_REF_VALUE__="$(eval echo \$$__MAP_NAME_REF__)"
        eval "$__MAP_NAME_REF__=\"$__MAP_NAME_REF_VALUE__ $2\""
    fi
    eval "$(__map_key_ref "$1" "$2")=$3"
}

# $1 map_name
# $2 key
# output: value
map_get() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"
    eval echo "\$$(__map_key_ref "$1" "$2")"
}

# $1 map_name
# $2 key
# output: value
map_remove() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    unset __MAP_KEYS__
    __MAP_KEYS__="$(map_keys "$1")"

    unset $__MAP_NAME_REF__

    for item in $__MAP_KEYS__
    do
        if [ "$item" = "$2" ] ; then
            continue
        else
            eval "$__MAP_NAME_REF__='$(eval echo \$$__MAP_NAME_REF__) $item'"
        fi
    done
    eval "unset $(__map_key_ref "$1" "$2")"
}

# $1 map_name
map_clear() {
    die_if_map_name_is_not_specified "$1"

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    for item in $(eval echo "\$$__MAP_NAME_REF__")
    do
        eval "unset $(__map_key_ref "$1" "$item")"
    done
    eval "unset $__MAP_NAME_REF__"
}

# $1 map_name
# output: key list
map_keys() {
    die_if_map_name_is_not_specified "$1"
    eval echo "\$$(__map_name_ref "$1")"
}

# $1 map_name
# output: key list length
map_size() {
    die_if_map_name_is_not_specified "$1"
    list_length $(map_keys "$1")
}

# $1 map_name
die_if_map_name_is_not_specified() {
    [ -z "$1" ] && die "please specify a map name."
}

# $1 key
die_if_map_key__is_not_specified() {
    [ -z "$1" ] && die "please specify a map key."
}

# }}}
##############################################################################
# {{{ fetch

__get_available_fetch_tool() {
    for tool in curl wget http lynx aria2c axel
    do
        if command_exists_in_filesystem "$tool" ; then
            echo "$tool"
            return 0
        fi
    done
    return 1
}

__fetch_via_git() {
    if [ -d "$FETCH_OUTPUT_PATH" ] ; then
        run cd  "$FETCH_OUTPUT_PATH" || return 1
        if      git rev-parse 2> /dev/null ; then
            run git pull &&
            run git submodule update --recursive
        else
            run cd .. &&
            run rm -rf "$FETCH_OUTPUT_NAME" &&
            run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
        fi
    else
        if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR" || return 1
        fi
        run cd "$FETCH_OUTPUT_DIR" || return 1
        run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
    fi
}

__fetch_archive_via_tools() {
    if [ -f "$FETCH_OUTPUT_PATH" ] ; then
        if [ -n "$FETCH_SHA256" ] ; then
            if file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                success "$FETCH_OUTPUT_PATH already have been downloaded."
                return 0
            fi
        fi
        rm -f "$FETCH_OUTPUT_PATH"
    fi

    AVAILABLE_FETCH_TOOL=$(__get_available_fetch_tool)

    if [ -z "$AVAILABLE_FETCH_TOOL" ] ; then
        handle_dependency required command curl || return 1
        if command_exists_in_filesystem curl ; then
            AVAILABLE_FETCH_TOOL=curl
        else
            return 1
        fi
    fi

    case $AVAILABLE_FETCH_TOOL in
        curl)  run curl --fail --retry 20 --retry-delay 30 --location -o "$FETCH_OUTPUT_PATH" "'$FETCH_URL'" ;;
        wget)  run wget --timeout=60 -O "$FETCH_OUTPUT_PATH" "'$FETCH_URL'" ;;
        http)  run http --timeout=60 -o "$FETCH_OUTPUT_PATH" "'$FETCH_URL'" ;;
        lynx)  run lynx -source "$FETCH_URL" > "\"$FETCH_OUTPUT_PATH\"" ;;
        aria2c)run aria2c -d "$FETCH_OUTPUT_DIR" -o "$FETCH_OUTPUT_NAME" "'$FETCH_URL'" ;;
        axel)  run axel -o "$FETCH_OUTPUT_PATH" "'$FETCH_URL'" ;;
    esac

    [ $? -eq 0 ] || return 1

    if [ -n "$FETCH_SHA256" ] ; then
        die_if_sha256sum_mismatch "$FETCH_OUTPUT_PATH" "$FETCH_SHA256"
    fi
}

# fetch <URL> [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH

    if [ -z "$1" ] ; then
        die "please specify a fetch url."
    else
        FETCH_URL="$1"
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    die "--output-dir argument's value must be not empty."
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    die "--output-name argument's value must be not empty."
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    die "--output-path argument's value must be not empty."
                fi
        esac
        shift
    done

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        [ -z "$FETCH_OUTPUT_DIR" ]  && FETCH_OUTPUT_DIR="$PWD"
        [ -z "$FETCH_OUTPUT_NAME" ] && FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")

        FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
    fi

    if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
        run install -d "$FETCH_OUTPUT_DIR"
    fi

    case $FETCH_URL in
        *.git) __fetch_via_git ;;
        *)     __fetch_archive_via_tools ;;
    esac
}

# }}}
##############################################################################
# {{{ os

__get_os_name_from_uname_a() {
    if command -v uname > /dev/null ; then
        unset V
        V=$(uname -a | cut -d ' ' -f2)
        case $V in
            opensuse*) return 1 ;;
            *-*) echo "$V" | cut -d- -f1 ;;
            *)   return 1
        esac
    else
        return 1
    fi
}

__get_os_version_from_uname_a() {
    if command -v uname > /dev/null ; then
        unset V
        V=$(uname -a | cut -d ' ' -f2)
        case $V in
            opensuse*) return 1 ;;
            *-*) echo "$V" | cut -d- -f2 ;;
            *)   return 1
        esac
    else
        return 1
    fi
}

# https://www.freedesktop.org/software/systemd/man/os-release.html
__get_os_name_from_etc_os_release() {
    if [ -f /etc/os-release ] ; then
        unset F
        F=$(mktemp) &&
        cat /etc/os-release > "$F" &&
        echo 'echo "$ID"'  >> "$F" &&
        sh "$F"
    else
        return 1
    fi
}

__get_os_version_from_etc_os_release() {
    if [ -f /etc/os-release ] ; then
        unset F
        F=$(mktemp) &&
        cat /etc/os-release > "$F" &&
        echo 'echo "$VERSION_ID"'  >> "$F" && {
            unset V
            V=$(sh "$F")
            if [ -z "$V" ] ; then
                echo 'rolling'
            else
                echo "$V"
            fi
        }
    else
        return 1
    fi
}

# https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/lsbrelease.html
__get_os_name_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --id | cut -f2
    else
        return 1
    fi
}

__get_os_version_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --release | cut -f2
    else
        return 1
    fi
}

__get_os_name_from_getprop() {
    if command -v getprop > /dev/null && command -v app_process > /dev/null ; then
        echo 'android'
    else
        return 1
    fi
}

__get_os_version_from_getprop() {
    if command -v getprop > /dev/null ; then
        getprop ro.build.version.release
    else
        return 1
    fi
}

__get_os_arch_from_getprop() {
    if command -v getprop > /dev/null ; then
        getprop ro.product.cpu.abi
    else
        return 1
    fi
}

__get_os_arch_from_uname() {
    if command -v uname > /dev/null ; then
        uname -m 2> /dev/null
    else
        return 1
    fi
}

__get_os_arch_from_arch() {
    if command -v arch > /dev/null ; then
        arch
    else
        return 1
    fi
}

os() {
    if [ $# -eq 0 ] ; then
        printf "current-machine-os-kind : %s\n" "$(os kind)"
        printf "current-machine-os-type : %s\n" "$(os type)"
        printf "current-machine-os-name : %s\n" "$(os name)"
        printf "current-machine-os-vers : %s\n" "$(os vers)"
        printf "current-machine-os-arch : %s\n" "$(os arch)"
        printf "current-machine-os-libc : %s\n" "$(os libc)"
    elif [ $# -eq 1 ] ; then
        case $1 in
            -h|--help)
                cat <<'EOF'
os -h | --help
os -V | --version
os kind
os type
os arch
os libc
os name
os vers
EOF
                ;;
            -V|--version) echo '2021.03.28.23' ;;
            kind)
                case $(uname | tr A-Z a-z) in
                    msys*)    echo "windows" ;;
                    mingw32*) echo "windows" ;;
                    mingw64*) echo "windows" ;;
                    cygwin*)  echo 'windows' ;;
                    *)  uname | tr A-Z a-z
                esac
                ;;

            type)
                case $(uname | tr A-Z a-z) in
                    msys*)    echo "msys"    ;;
                    mingw32*) echo "mingw32" ;;
                    mingw64*) echo "mingw64" ;;
                    cygwin*)  echo 'cygwin'  ;;
                    *)  uname | tr A-Z a-z
                esac
                ;;
            name)
                case $(os kind) in
                    freebsd) echo 'FreeBSD' ;;
                    openbsd) echo 'OpenBSD' ;;
                    netbsd)  echo 'NetBSD'  ;;
                    darwin)  sw_vers -productName ;;
                    linux)
                        __get_os_name_from_uname_a ||
                        __get_os_name_from_etc_os_release ||
                        __get_os_name_from_lsb_release
                        ;;
                    windows)
                        systeminfo | grep 'OS Name:' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//' ;;
                    *)  uname | tr A-Z a-z
                esac
                ;;
            arch)
                __get_os_arch_from_uname ||
                __get_os_arch_from_arch  ||
                __get_os_arch_from_getprop
                ;;
            libc)
                case $(os kind) in
                    linux)
                        # https://pubs.opengroup.org/onlinepubs/7908799/xcu/getconf.html
                        if command -v getconf > /dev/null ; then
                            if getconf GNU_LIBC_VERSION > /dev/null 2>&1 ; then
                                echo glibc
                                return 0
                            fi
                        fi
                        if command -v ldd > /dev/null ; then
                            if ldd --version 2>&1 | head -n 1 | grep -q GLIBC ; then
                                echo glibc
                                return 0
                            fi
                            if ldd --version 2>&1 | head -n 1 | grep -q musl ; then
                                echo musl
                                return 0
                            fi
                        fi
                        return 1
                esac
                ;;
            vers)
                case $(os kind) in
                    freebsd) freebsd-version ;;
                    openbsd) uname -r ;;
                    netbsd)  uname -r ;;
                    darwin)  sw_vers -productVersion ;;
                    linux)
                        __get_os_version_from_uname_a ||
                        __get_os_version_from_etc_os_release ||
                        __get_os_version_from_lsb_release
                        ;;
                    windows)
                        systeminfo | grep 'OS Version:' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//' | cut -d ' ' -f1 ;;
                esac
                ;;
            *)  echo "$1: not support item."; return 1
        esac
    else
        echo "os command only support one item."; return 1
    fi
}

# }}}
##############################################################################
# {{{ version

# retrive the version of a command from it's name or path
version_of_command() {
    case $(basename "$1") in
        cmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$1"   version | cut -d ' ' -f3 | cut -c3- ;;
         tree) "$1" --version | cut -d ' ' -f2 | cut -c2- ;;
   pkg-config) "$1" --version 2> /dev/null | head -n 1 ;;
       m4|gm4) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
    autopoint) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     automake|aclocal)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      objcopy) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
         flex) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        groff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     help2man) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 sphinx-build) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         file) "$1" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       protoc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
     rst2man|rst2man.py|rst2man-3|rst2man-3.6|rst2man-3.7|rst2man-3.8|rst2man-3.9)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         gzip) "$1" --version 2>&1 | head -n 1 | awk '{print($NF)}' ;;
         lzip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$1" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$1" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2) "$1" --help 2>&1 | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1 ;;
          tar)
            VERSION_MSG=$("$1" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) echo "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) echo "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         cpan) ;;
         find) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         diff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         grep) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$1" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
    python|python2|python3)
               "$1" --version 2>&1 | head -n 1 | cut -d ' ' -f2 ;;
         pip)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         pip3) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         node) "$1" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
       base64) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
            *) "$1" --version 2> /dev/null | head -n 1
    esac
}

# retrive the major part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_major_of_command() {
    version_of_command "$1" | cut -d. -f1
}

# retrive the minor part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_minor_of_command() {
    version_of_command "$1" | cut -d. -f2
}

# retrive the major part of the given version
# Note: the given version must have form: major.minor.patch
version_major_of_version() {
    echo "$1" | cut -d. -f1
}

# retrive the minor part of the given version
# Note: the given version must have form: major.minor.patch
version_minor_of_version() {
    echo "$1" | cut -d. -f2
}

version_sort() {
    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html
    # https://man.netbsd.org/NetBSD-8.1/i386/sort.1
    #
    # sort: unrecognized option: V
    # BusyBox v1.29.3 (2019-01-24 07:45:07 UTC) multi-call binary.
    # Usage: sort [-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...
    if  echo | (sort -V > /dev/null 2>&1) ; then
        echo "$@" | tr ' ' '\n' | sort -V
    else
        echo "$@" | tr ' ' '\n' | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4
    fi
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            [ "$1" = "$3" ] && return 0
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            [ "$1" = "$3" ] && return 0
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            [ "$1" = "$3" ] && return 1
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            [ "$1" = "$3" ] && return 1
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  die "version_compare: $2: not supported operator."
    esac
}

# check if the version of give installed command match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# command_exists_in_filesystem_and_version_matched automake eq 1.16.0
# command_exists_in_filesystem_and_version_matched automake lt 1.16.0
# command_exists_in_filesystem_and_version_matched automake gt 1.16.0
# command_exists_in_filesystem_and_version_matched automake le 1.16.0
# command_exists_in_filesystem_and_version_matched automake ge 1.16.0
# command_exists_in_filesystem_and_version_matched automake
command_exists_in_filesystem_and_version_matched() {
    if command_exists_in_filesystem "$1" ; then
        if [ "$NATIVE_OS_TYPE" = 'cygwin' ] ; then
            case $(command -v "$1") in
                /cygdrive/*) return 1
            esac
        fi
        if [ $# -eq 3 ] ; then
            version_match "$(version_of_command "$1")" "$2" "$3"
        fi
    else
        return 1
    fi
}

# }}}
##############################################################################
# {{{ package_manager

# check if the version of give package match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# package_exists_and_version_matched apt automake eq 1.16.0
# package_exists_and_version_matched apt automake lt 1.16.0
# package_exists_and_version_matched apt automake gt 1.16.0
# package_exists_and_version_matched apt automake le 1.16.0
# package_exists_and_version_matched apt automake ge 1.16.0
# package_exists_and_version_matched apt automake
package_exists_in_repo_and_version_matched() {
    if package_exists_in_repo "$1" "$2" ; then
        if [ $# -eq 4 ] ; then
            case $1 in
                apt|yum|dnf) version_match "$(version_of_package "$1" "$2")" "$3" "$4" ;;
                *)       return 0 ;;
            esac
        fi
    else
        return 1
    fi
}

# check if the give package is in the give repo
#
# examples:
# package_exists_in_repo apt automake
package_exists_in_repo() {
    case $1 in
        apt) apt show "$2" > /dev/null 2>&1 ;;
        yum) yum info "$2" > /dev/null 2>&1 ;;
        dnf) dnf info "$2" > /dev/null 2>&1 ;;
    esac
}

# get the version of the give package in the give repo
#
# examples:
# version_of_package apt automake
version_of_package() {
    case $1 in
        apt) apt show "$2" 2> /dev/null | grep 'Version: '      | head -n 1 | cut -d ' ' -f2 | cut -d- -f1 ;;
        yum) yum info "$2" 2> /dev/null | grep 'Version     :'  | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
        dnf) dnf info "$2" 2> /dev/null | grep 'Version      :' | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
    esac
}

# }}}
##############################################################################
# {{{ get_XX_package_name_by_command_name

# https://cygwin.com/packages/package_list.html
get_choco_package_name_by_command_name() {
    case $1 in
      cc|gcc) echo 'gcc-g++' ;;
       gmake) echo 'make' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    sphinx-build) echo 'python38-sphinx' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_pkg_add_package_name_by_command_name() {
    case $1 in
          cc) echo 'gcc'   ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
       gperf) echo 'gperf' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py3-pip' ;;
    libtool|libtoolize|glibtool|glibtoolize)
              echo "libtool" ;;
    autoreconf|autoconf|autoreconf-2.69|autoconf-2.69)
              echo "autoconf-2.69p3" ;;
    automake|autoheader|automake-1.16|autoheader-1.16)
            if [ "$NATIVE_OS_VERS" = '6.9' ] ; then
                echo "automake-1.16.3"
            else
                echo "automake-1.16.2"
            fi
            ;;
    autopoint) echo "gettext" ;;
    pkg-config) echo "pkgconf" ;;
        *) echo "$1"
    esac
}

get_pkgin_package_name_by_command_name() {
    case $1 in
          cc) echo 'gcc'   ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py38-pip'  ;;
    python3)  echo 'python38' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_pkg_package_name_by_command_name() {
    case $1 in
          cc) echo 'gcc'   ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py38-pip' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_emerge_package_name_by_command_name() {
    case $1 in
          cc) echo 'gcc' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      xz)     echo 'xz-utils' ;;
      rst2man|rst2html)
              echo "docutils" ;;
    sphinx-build)
              echo "sphinx" ;;
    pip3|pip) echo "dev-python/pip" ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

__get_pacman_package_name_by_command_name() {
    case $1 in
          cc) echo 'gcc'      ;;
         gm4) echo 'm4'       ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python-docutils" ;;
    sphinx-build)
              echo "python-sphinx" ;;
    pip3|pip) echo "python-pip" ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

__mingw_w64_i686() {
    if pacman -S -i "mingw-w64-i686-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-i686-$1"
    else
        echo "$1"
    fi
}

__mingw_w64_x86_64() {
    if pacman -S -i "mingw-w64-x86_64-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-x86_64-$1"
    else
        echo "$1"
    fi
}

get_pacman_package_name_by_command_name() {
    if [ "$1" = 'make' ] || [ "$1" = 'gmake' ] ; then
        echo make
    fi
    case $NATIVE_OS_TYPE in
        mingw32) __mingw_w64_i686   $(__get_pacman_package_name_by_command_name "$1") ;;
        mingw64) __mingw_w64_x86_64 $(__get_pacman_package_name_by_command_name "$1") ;;
        *) __get_pacman_package_name_by_command_name "$1"
    esac
}

get_xbps_package_name_by_command_name() {
    case $1 in
      cc|gcc) echo 'gcc' ;;
         gm4) echo 'm4'    ;;
       gperf) echo 'gperf' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python3-docutils" ;;
    pip|pip3) echo "python3-pip" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_apk_package_name_by_command_name() {
    case $1 in
      cc|gcc) echo 'gcc libc-dev' ;;
         gm4) echo 'm4'    ;;
       gperf) echo 'gperf' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "py3-docutils" ;;
    sphinx-build)
              echo "sphinx"  ;;
    pip3|pip) echo 'py3-pip' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *) echo "$1"
    esac
}

get_zypper_package_name_by_command_name() {
    case $1 in
      cc|gcc) echo 'gcc' ;;
         gm4) echo 'm4'    ;;
       gperf) echo 'gperf' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-Sphinx" ;;
    pip3|pip) echo "python3-pip" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_dnf_package_name_by_command_name() {
    case $1 in
      cc|gcc) echo 'gcc' ;;
         gm4) echo 'm4'    ;;
       gperf) echo 'gperf' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-sphinx" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_yum_package_name_by_command_name() {
    case $1 in
      cc|gcc) echo 'gcc' ;;
         gm4) echo 'm4'    ;;
       gperf) echo 'gperf' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    sphinx-build) echo "python-sphinx" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_apt_get_package_name_by_command_name() {
    get_apt_package_name_by_command_name $@
}

get_apt_package_name_by_command_name() {
    case $1 in
      cc|gcc) echo 'gcc' ;;
         gm4) echo 'm4'    ;;
       gperf) echo 'gperf' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
        xz)   echo 'xz-utils' ;;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-sphinx" ;;
    pip3|pip) echo "python3-pip" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_brew_package_name_by_command_name() {
    case $1 in
      cc|gcc) echo 'gcc' ;;
         gm4) echo 'm4'    ;;
       gperf) echo 'gperf' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
     rst2man.py|rst2html.py)
              echo "docutils" ;;
    grpc_cpp_plugin)
                echo "grpc" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    python|python3)
                echo 'python@3.9' ;;
        *)      echo "$1"
    esac
}

get_pip3_package_name_by_command_name() {
    get_pip_package_name_by_command_name $@
}

get_pip_package_name_by_command_name() {
    case $1 in
        sphinx-build) echo "sphinx"   ;;
        rst2man.py)   echo "docutils" ;;
    esac
}

# }}}
##############################################################################
# {{{ __get_available_package_manager_list

__add_available_package_manager() {
    if command_exists_in_filesystem "$1" ; then
        if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
            AVAILABLE_PACKAGE_MANAGER_LIST="$2"
        else
            AVAILABLE_PACKAGE_MANAGER_LIST="$AVAILABLE_PACKAGE_MANAGER_LIST $2"
        fi
    fi
}

__get_available_package_manager_list() {
    if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
        for pm in brew apt dnf zypper apk xbps-install emerge pacman choco pkg pkgin pkg_add
        do
            case $pm in
                apt)
                    if command_exists_in_filesystem apt && apt show apt > /dev/null 2>&1 ; then
                        __add_available_package_manager apt apt
                    else
                        __add_available_package_manager apt-get apt-get
                    fi
                    ;;
                dnf)
                    if command_exists_in_filesystem dnf ; then
                        __add_available_package_manager dnf dnf
                    else
                        __add_available_package_manager yum yum
                    fi
                    ;;
                xbps-install)
                    __add_available_package_manager xbps-install xbps
                    ;;
                *)  __add_available_package_manager "$pm" "$pm"
            esac
        done
    fi
    echo "$AVAILABLE_PACKAGE_MANAGER_LIST"
}

# }}}
##############################################################################
# {{{ __install_required

# $1 package manager name
# $2 package name
# examples:
# __install_package_via_package_manager apt make ge 3.80
# __install_package_via_package_manager apt make
__install_package_via_package_manager() {
    [ -z "$2" ] && return 1

    package_exists_in_repo_and_version_matched $@ || return 1

    case $1 in
        pip3)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip3 install --user -U "$2" ;;
                *)          run pip3 install        -U "$2"
            esac
            ;;
        pip)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip  install --user -U "$2" ;;
                *)          run pip  install        -U "$2"
            esac
            ;;
        brew)
            if run brew install "$2" ; then
                if [ "$(brew info --json=v2 "$2" | grep keg_only | sed 's/ //g' | cut -d: -f2 | sed 's/,//')" = 'true' ] ; then
                    if [ -d "$(brew --prefix "$2")/bin" ] ; then
                        export PATH="$(brew --prefix "$2")/bin:$PATH"
                    fi
                fi
            else
                return 1
            fi
            ;;
        pkg)     run $sudo pkg install -y "$2" ;;
        pkgin)   run $sudo pkgin -y install "$2" ;;
        pkg_add) run $sudo pkg_add "$2" ;;
        apt)     run $sudo apt     -y install "$2" ;;
        apt-get) run $sudo apt-get -y install "$2" ;;
        dnf)     run $sudo dnf -y install "$2" ;;
        yum)     run $sudo yum -y install "$2" ;;
        zypper)  run $sudo zypper install -y "$2" ;;
        apk)     run $sudo apk add "$2" ;;
        xbps)    run $sudo xbps-install -Sy "$2" ;;
        emerge)  run $sudo emerge "$2" ;;
        pacman)  run $sudo pacman -Syy --noconfirm && run $sudo pacman -S --noconfirm "$2" ;;
        choco)   run choco install -y --source cygwin "$2" ;;
    esac
    echo
}

# $1 package manager name
# $2 command name
# examples:
# __install_command_via_package_manager apt make ge 3.80
# __install_command_via_package_manager apt make
__install_command_via_package_manager() {
    unset __PACKAGE_NAME__
    __PACKAGE_NAME__="$(eval get_$(echo "$1" | tr - _)_package_name_by_command_name $2)"

    [ -z "$__PACKAGE_NAME__" ] && return 1

    package_exists_in_repo_and_version_matched "$1" "$__PACKAGE_NAME__" $3 $4 || return 1

    print "ðŸ”¥  ${COLOR_YELLOW}required command${COLOR_OFF} ${COLOR_GREEN}$(shiftn 1 $@)${COLOR_OFF}${COLOR_YELLOW}, but${COLOR_OFF} ${COLOR_GREEN}$2${COLOR_OFF} ${COLOR_YELLOW}command not found, try to install it via${COLOR_OFF} ${COLOR_GREEN}$1${COLOR_OFF}\n"

    __install_package_via_package_manager "$1" "$__PACKAGE_NAME__" $3 $4
}

# examples:
# __install_command_via_available_package_manager python3 ge 3.5
# __install_command_via_available_package_manager make
__install_command_via_available_package_manager() {
    command_exists_in_filesystem_and_version_matched $@ && return 0
 
    if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
        AVAILABLE_PACKAGE_MANAGER_LIST=$(__get_available_package_manager_list)
        if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
            warn "no package manager found."
            return 1
        else
            echo "    Found $(list_length $AVAILABLE_PACKAGE_MANAGER_LIST) package manager : ${COLOR_GREEN}$AVAILABLE_PACKAGE_MANAGER_LIST${COLOR_OFF}"
        fi
    fi
    for pm in $AVAILABLE_PACKAGE_MANAGER_LIST
    do
        __install_command_via_package_manager "$pm" $@ && return 0
    done
    return 1
}

handle_dependency_from_url() {
    case $1 in
        *.zip)
            handle_dependency required command unzip
            ;;
        *.tar.xz)
            handle_dependency required command tar
            handle_dependency required command xz
            ;;
        *.tar.gz)
            handle_dependency required command tar
            handle_dependency required command gzip
            ;;
        *.tar.lz)
            handle_dependency required command tar
            handle_dependency required command lzip
            ;;
        *.tar.bz2)
            handle_dependency required command tar
            handle_dependency required command bzip2
            ;;
        *.tgz)
            handle_dependency required command tar
            handle_dependency required command gzip
            ;;
        *.txz)
            handle_dependency required command tar
            handle_dependency required command xz
    esac
}

get_suffix_from_filename() {
    case $1 in
        *.zip)     echo '.zip' ;;
        *.tar.xz)  echo '.tar.xz' ;;
        *.tar.gz)  echo '.tar.gz' ;;
        *.tar.lz)  echo '.tar.lz' ;;
        *.tar.bz2) echo '.tar.bz2' ;;
        *.tgz)     echo '.tgz' ;;
        *.txz)     echo '.txz' ;;
    esac
}

# examples:
# pkg-config ge 0.18
# python3    ge 3.5
# make
__install_command_via_fetch_prebuild_binary() {
    unset PREBUILD_BINARY_FETCH_URL
    PREBUILD_BINARY_FETCH_URL=$(__get_prebuild_binary_fetch_url_by_command_name "$1")
    if [ -z "$PREBUILD_BINARY_FETCH_URL" ] ; then
        warn "no fetch url for $@"
        return 1
    fi

    handle_dependency_from_url "$PREBUILD_BINARY_FETCH_URL"

    print "ðŸ”¥  ${COLOR_YELLOW}required command${COLOR_OFF} ${COLOR_GREEN}$@${COLOR_OFF}${COLOR_YELLOW}, but${COLOR_OFF} ${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command not found, try to install it via${COLOR_OFF} ${COLOR_GREEN}fetch prebuild binary${COLOR_OFF}\n"

    unset PREBUILD_BINARY_FETCH_URL
    PREBUILD_BINARY_FETCH_URL=$(__get_prebuild_binary_fetch_url_by_command_name "$1")

    unset PREBUILD_BINARY_FILENAME_PREFIX
    unset PREBUILD_BINARY_FILENAME_SUFFIX
    unset PREBUILD_BINARY_FILENAME
    unset PREBUILD_BINARY_FILEPATH

    PREBUILD_BINARY_FILENAME=$(basename "$PREBUILD_BINARY_FETCH_URL")
    PREBUILD_BINARY_FILENAME_SUFFIX=$(get_suffix_from_filename "$PREBUILD_BINARY_FILENAME")
    PREBUILD_BINARY_FILENAME_PREFIX=$(basename "$PREBUILD_BINARY_FILENAME" "$PREBUILD_BINARY_FILENAME_SUFFIX")

    unset PREBUILD_BINARY_INSTALL_DIR
    PREBUILD_BINARY_INSTALL_DIR="$PREBUILD_BINARY_INSTALL_PREFIX_DIR/$PREBUILD_BINARY_FILENAME_PREFIX"

    PREBUILD_BINARY_FILEPATH="$PREBUILD_BINARY_INSTALL_DIR/$PREBUILD_BINARY_FILENAME"

    if [ -d "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
        if [ -d "$PREBUILD_BINARY_INSTALL_DIR" ] ; then
            if [ -r "$PREBUILD_BINARY_INSTALL_DIR" ] && [ -w "$PREBUILD_BINARY_INSTALL_DIR" ] && [ -x "$PREBUILD_BINARY_INSTALL_DIR" ] ; then
                rm -rf "$PREBUILD_BINARY_INSTALL_DIR" || return 1
                install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            else
                sudo rm -rf "$PREBUILD_BINARY_INSTALL_DIR" || return 1
                sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            fi
        else
            if [ -r "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] && [ -w "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] && [ -x "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
                install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            else
                sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            fi
        fi
    else
        if [ -r / ] && [ -w / ] && [ -x / ] ; then
                 install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
        else
            sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
        fi
    fi

    fetch "$PREBUILD_BINARY_FETCH_URL" --output-dir="$PREBUILD_BINARY_INSTALL_DIR" --output-name="$PREBUILD_BINARY_FILENAME" || return 1

    case $PREBUILD_BINARY_FILENAME_SUFFIX in
        .zip)
            run unzip  "$PREBUILD_BINARY_FILEPATH" -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1 ;;
        .tar.xz|.tar.gz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz)
            run tar xf "$PREBUILD_BINARY_FILEPATH" -C "$PREBUILD_BINARY_INSTALL_DIR" --strip-components 1 || return 1 ;;
    esac

    if [ -d "$PREBUILD_BINARY_INSTALL_DIR/bin" ] ; then
        export PATH="$PREBUILD_BINARY_INSTALL_DIR/bin:$PATH"
    fi
}

# examples:
# pkg-config ge 0.18
# python3    ge 3.5
# make
__get_prebuild_binary_fetch_url_by_command_name() {
    case $1 in
        python3|python)
            case $NATIVE_OS_KIND in
                linux)
                    if [ "$NATIVE_OS_LIBC" = 'glibc' ] && [ "$NATIVE_OS_ARCH" = 'x86_64' ] ; then
                        # https://github.com/leleliu008/python-prebuild
                        echo "https://github.com/leleliu008/python-prebuild/releases/download/3.9.5/python-3.9.5-x86_64-linux-glibc.tar.xz"
                    fi
            esac
            ;;
        cmake)
            case $NATIVE_OS_KIND in
                linux)
                    if [ "$NATIVE_OS_LIBC" = 'glibc' ] ; then
                        # https://cmake.org/download
                        echo "https://github.com/Kitware/CMake/releases/download/v3.20.2/cmake-3.20.2-linux-x86_64.tar.gz"
                    fi
                    ;;
                darwin)
                    if ! command_exists_in_filesystem brew ; then
                        echo "https://github.com/Kitware/CMake/releases/download/v3.20.2/cmake-3.20.2-macos-universal.tar.gz"
                    fi
            esac
    esac
}

__install_command_via_run_install_script() {
    case $1 in
        rustup)
            # https://www.rust-lang.org/tools/install

            unset __RUSTUP_INSTALL_SCRIPT_RUN_SHELL__
            __RUSTUP_INSTALL_SCRIPT_RUN_SHELL__=$(command -v bash || command -v zsh || command -v dash)
            if [ -z "$__RUSTUP_INSTALL_SCRIPT_RUN_SHELL__" ] ; then
                handle_dependency required command bash || return 1
            fi
            __RUSTUP_INSTALL_SCRIPT_RUN_SHELL__=$(command -v bash)
            if [ -z "$__RUSTUP_INSTALL_SCRIPT_RUN_SHELL__" ] ; then
                warn "install bash failed."
                return 1
            fi

            unset __RUSTUP_INSTALL_SCRIPT_DIR__
            __RUSTUP_INSTALL_SCRIPT_DIR__=$(mktemp -d) || return 1
            fetch 'https://sh.rustup.rs' --output-dir="$__RUSTUP_INSTALL_SCRIPT_DIR__" --output-name='rustup-init' || return 1

            run "$__RUSTUP_INSTALL_SCRIPT_RUN_SHELL__ $__RUSTUP_INSTALL_SCRIPT_DIR__/rustup-init -y" || return 1

            export CARGO_HOME=$HOME/.cargo
            export PATH="$CARGO_HOME/bin:$PATH"
            ;;
        *)  return 1
    esac
}

__install_command_via_pip() {
    [ -z "$(get_pip3_package_name_by_command_name "$1")" ] && return 1

    handle_dependency required command pip3:pip

    (
        unset __PIP_COMMAND__
        __PIP_COMMAND__="$(command -v pip3.8)"

        if [ -n "$__PIP_COMMAND__" ] && [ -d '/usr/local/bin' ] ; then
            $sudo ln -sf "$__PIP_COMMAND__" /usr/local/bin/pip3
        fi
    )

    if   command_exists_in_filesystem pip3 ; then
        __install_package_via_package_manager pip3 "$(get_pip3_package_name_by_command_name "$1")"
    elif command_exists_in_filesystem pip ; then
        __install_package_via_package_manager pip  "$(get_pip3_package_name_by_command_name "$1")"
    else
        return 1
    fi
}

# examples:
# __install_command python3 ge 3.5
# __install_command make
__install_command() {
    command_exists_in_filesystem_and_version_matched $@ && return 0

    __install_command_via_run_install_script $@         && return 0
    __install_command_via_pip $@                        && return 0
    __install_command_via_available_package_manager $@  && return 0
    __install_command_via_fetch_prebuild_binary $@      && return 0
    return 1
}

# examples:
# handle_dependency required command   pkg-config ge 0.18
# handle_dependency required command   python     ge 3.5
# handle_dependency required module.py libxml2    ge 2.19
#
# handle_dependency optional command   pkg-config ge 0.18
# handle_dependency optional command   python     ge 3.5
# handle_dependency optional module.py libxml2    ge 2.19
handle_dependency() {
    [ "$1" = 'required' ] || return 0

    shift

    case $1 in
        command)
            shift
            case $1 in
                *:*)
                    for command in $(echo "$1" | tr ':' ' ')
                    do
                        if command_exists_in_filesystem_and_version_matched "$command" $2 $3 ; then
                            map_set "$MAP_REQUIRED_DEPENDENCIES" "$1" "$command"
                            return 0
                        fi
                    done
                    for command in $(echo "$1" | tr ':' ' ')
                    do
                        if __install_command "$command" $2 $3 ; then
                            map_set "$MAP_REQUIRED_DEPENDENCIES" "$1" "$command"
                            return 0
                        fi
                    done
                    return 1
                    ;;
                *)  __install_command $@
            esac
            ;;
        module.py)
            shift
            python_module install "$1"
            ;;
        module.pl)
            shift
            perl_module install "$1"
            ;;
        *) die "$1 not support."
    esac
}

__handle_required_dependencies() {
    step "handle required dependencies"

    for dependency in $REQUIRED_DEPENDENCY_LIST
    do
        handle_dependency $(__decode_dependency "$dependency") || return 1
    done
}

# }}}
##############################################################################
# {{{ __printf_dependencies

# examples:
# __printf_dependency required command   pkg-config ge 0.18
# __printf_dependency required command   python     ge 3.5
# __printf_dependency required module.py libxml2    ge 2.19
#
# __printf_dependency optional command   pkg-config ge 0.18
# __printf_dependency optional command   python     ge 3.5
# __printf_dependency optional module.py libxml2    ge 2.19
__printf_dependency() {
    printf "%-10s %-15s %-2s %-10s %-10s %s\n" "$1" "$2" "$3" "$4" "$5" "$6"
}

# examples:
# printf_dependency required command   pkg-config ge 0.18
# printf_dependency required command   python     ge 3.5
# printf_dependency required module.py libxml2    ge 2.19
#
# printf_dependency optional command   pkg-config ge 0.18
# printf_dependency optional command   python     ge 3.5
# printf_dependency optional module.py libxml2    ge 2.19
printf_dependency() {
    case $2 in
        command)
            case $3 in
                *:*)
                    if [ "$1" = 'required' ] ; then
                        REQUIRED_ITEM="$(map_get "MAP_REQUIRED_DEPENDENCIES" "$3")"
                        __printf_dependency "$2" "$REQUIRED_ITEM" "$4" "$5" "$(version_of_command $REQUIRED_ITEM)" "$(command -v $REQUIRED_ITEM)"
                    else
                        for item in $(echo "$3" | tr ':' ' ')
                        do
                            __printf_dependency "$2" "$item" "$4" "$5" "$(version_of_command $item)" "$(command -v $item)"
                        done
                    fi
                    ;;
                *)  __printf_dependency "$2" "$3" "$4" "$5" "$(version_of_command $3)" "$(command -v $3)"
            esac
            ;;
        module.py)
            __printf_dependency "$2" "$3" "$4" "$5" "$(python_module get version "$item")" "$(python_module get location "$item")"
            ;;
        module.pl)
            __printf_dependency "$2" "$3" "$4" "$5" "$(perl_module get version "$item")" "$(perl_module get location "$item")"
            ;;
        *)  die "$2: type not support."
    esac
}

__printf_required_dependencies() {
    step "printf required dependencies"
    if [ -z "$REQUIRED_DEPENDENCY_LIST" ] ; then
        warn "no required dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $REQUIRED_DEPENDENCY_LIST
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

__printf_optional_dependencies() {
    step "printf optional dependencies"
    if [ -z "$OPTIONAL_DEPENDENCY_LIST" ] ; then
        warn "no optional dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $OPTIONAL_DEPENDENCY_LIST
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

# }}}
##############################################################################
# {{{ python_module

# examples:
# python_module is  installed libxml2
# python_module get version   libxml2
# python_module get location  libxml2
# python_module install       libxml2
python_module() {
    case $1 in
        is)
            [ $# -eq 3 ] || die "[python_module is] command accept 2 arguments."

            handle_dependency required command python3:python3.9:python3.8:python3.7:python3.6:python3.5:python
            handle_dependency required command pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || echo python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || echo pip)

            case $2 in
                installed)  "$__PYTHON_COMMAND__" -c "import $3" 2> /dev/null ;;
                *) die "python_module is $2: not support."
            esac
            ;;
        get)
            [ $# -eq 3 ] || die "[python_module get] command accept 2 arguments."

            handle_dependency required command python3:python3.9:python3.8:python3.7:python3.6:python3.5:python
            handle_dependency required command pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || echo python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || echo pip)

            case $2 in
                version)  "$__PIP_COMMAND__" show "$3" 2> /dev/null | grep 'Version:'  | cut -d ' ' -f2 ;;
                location) "$__PIP_COMMAND__" show "$3" 2> /dev/null | grep 'Location:' | cut -d ' ' -f2 ;;
                *) die "python_module get $2: not support."
            esac
            ;;
        install)
            [ -z "$2" ] && die "please specify a python module name."
            if ! python_module is installed "$2" ; then
                warn "required python module ${COLOR_GREEN}$2${COLOR_OFF}, but ${COLOR_GREEN}$2${COLOR_OFF} python module not found, try to install it via ${COLOR_GREEN}$__PIP_COMMAND__${COLOR_OFF}"
                run "$__PIP_COMMAND__" install -U pip  || return 1
                run "$__PIP_COMMAND__" install -U "$2" || return 1
            fi
            ;;
        *)  die "python_module $1: not support."
    esac
}

# }}}
##############################################################################
# {{{ perl_module

# examples:
# perl_module is  installed libxml2
# perl_module get version   libxml2
# perl_module get location  libxml2
# perl_module install       libxml2
perl_module() {
    case $1 in
        is)
            [ $# -eq 4 ] || die "perl_module command accept 4 arguments."
            handle_dependency required command perl
            case $2 in
                installed)  perl -M"$3" -le 'print "installed"' > /dev/null 2>&1 ;;
                *) die "perl_module is $2: not support."
            esac
            ;;
        get)
            ;;
        install)
            if ! perl_module is installed "$3" ; then
                handle_dependency required command cpan:cpanm
                if   command_exists_in_filesystem cpan  ; then
                    cpan -i "$3"
                elif command_exists_in_filesystem cpanm ; then
                    cpanm "$3"
                else
                    die "no perl module installer found."
                fi
            fi
            ;;
        *)  die "perl_module $1: not support."
    esac
}

# }}}
##############################################################################
# {{{ encode/decode dependency

__encode_dependency() {
    if [ $# -eq 0 ] ; then
        tr ' ' '|'
    else
        printf "%s" "$*" | tr ' ' '|'
    fi
}

__decode_dependency() {
    if [ $# -eq 0 ] ; then
        tr '|' ' '
    else
        printf "%s" "$*" | tr '|' ' '
    fi
}

# }}}
##############################################################################
# {{{ regist dependency

# regist dependency
#
# required this is a required dependency
# optional this is a optional dependency
#
# command  this dependency is a command
# python   this dependency is a python  module
# python2  this dependency is a python2 module
# python3  this dependency is a python3 module
# perl     this dependency is a perl module
#
# gt VERSION
# ge VERSION
# lt VERSION
# le VERSION
# eq VERSION
# ne VERSION
#
# examples:
# regist_dependency required command pkg-config ge 0.18
# regist_dependency required command python     ge 3.5
# regist_dependency required python  libxml2    ge 2.19
#
# regist_dependency optional command pkg-config ge 0.18
# regist_dependency optional command python     ge 3.5
# regist_dependency optional python  libxml2    ge 2.19
regist_dependency() {
    case $1 in
        required)
            if [ -z "$REQUIRED_DEPENDENCY_LIST" ] ; then
                REQUIRED_DEPENDENCY_LIST="$(__encode_dependency "$*")"
            else
                REQUIRED_DEPENDENCY_LIST="$REQUIRED_DEPENDENCY_LIST $(__encode_dependency "$*")"
            fi
            ;;
        optional)
            if [ -z "$OPTIONAL_DEPENDENCY_LIST" ] ; then
                OPTIONAL_DEPENDENCY_LIST=$(__encode_dependency "$*")
            else
                OPTIONAL_DEPENDENCY_LIST="$OPTIONAL_DEPENDENCY_LIST $(__encode_dependency "$*")"
            fi
    esac
}

# }}}
##############################################################################
# {{{ define formula syntax

# set package informations
# 
# examples:
# package set|add summary "JPEG image codec that aids compression and decompression"
# package set|add webpage "https://www.libjpeg-turbo.org"
# package set|add src.git "https://github.com/libjpeg-turbo/libjpeg-turbo.git"
# package set|add src.url "https://downloads.sourceforge.net/project/libjpeg-turbo/2.0.6/libjpeg-turbo-2.0.6.tar.gz"
# package set|add src.sum "d74b92ac33b0e3657123ddcf6728788c90dc84dcb6a52013d758af3c4af481bb"
# package set|add license "IJG"
# package set|add dep.cmd "nasm"
# package set|add dep.pkg "libxx"
# package set|add bsystem "cmake"
# package set     binsrcd 'true'
# package set     sourced 'src'
# package set     sdk.api '23'
#
# package get PACKAGE KEY
package() {
    unset __PACKAGE_KEY__

    if [ $# -lt 2 ] ; then
        die "package <set|add|get> <key> [value]..."
    fi
    if [ -z "$2" ] ; then
        die "key can not be empty."
    fi
    case $1 in
        set)
            shift
            __PACKAGE_KEY__="$1"
            shift
            __PACKAGE_KEY__="$(echo "$__PACKAGE_KEY__" | tr - _  | tr . _ | tr a-z A-Z)"
            eval "PACKAGE_$__PACKAGE_KEY__=\"$@\"" || exit 1
            ;;
        get)
            shift
            ___load_a_formula "$1"
            shift
            __PACKAGE_KEY__="$(echo "$1" | tr - _  | tr . _ | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_KEY__ || exit 1
            ;;
        add)
            shift
            __PACKAGE_KEY__="$1"
            shift
            __PACKAGE_KEY__="$(echo "$__PACKAGE_KEY__" | tr - _  | tr . _ | tr a-z A-Z)"
            __PACKAGE_VAL__="$(eval echo \$PACKAGE_$__PACKAGE_KEY__)"
            eval "PACKAGE_$__PACKAGE_KEY__=\"$__PACKAGE_VAL__ $@\"" || exit 1
            ;;
        '') die "operation can not be empty." ;;
        *)  die "$1: operation not support "
    esac
}

__parse_require_command_item() {
    case $1 in
        *\<=*) echo "required command $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required command $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required command $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required command $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required command $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required command $1"
    esac
}

__parse_require_python_module_item() {
    case $1 in
        *\<=*) echo "required module.py $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required module.py $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required module.py $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required module.py $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required module.py $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required module.py $1"
    esac
}

__parse_require_perl_module_item() {
    case $1 in
        *\<=*) echo "required module.pl $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required module.pl $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required module.pl $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required module.pl $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required module.pl $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required module.pl $1"
    esac
}

__parse_package_patches() {
    [ $# -lt 2 ]             && die "the number of arguments of patches command at least 2."
    [ $(expr $# % 2) -eq 1 ] && die "the number of arguments of patches command must be even integer."

    while [ -n "$1" ]
    do
        case $1 in
            *.diff)    PATCH_CONTENT_TYPE=patch  ; package add dep.cmd patch           ;;
            *.patch)   PATCH_CONTENT_TYPE=patch  ; package add dep.cmd patch           ;;
            *.zip)     PATCH_CONTENT_TYPE=zip    ; package add dep.cmd patch unzip     ;;
            *.tar.xz)  PATCH_CONTENT_TYPE=tar.xz ; package add dep.cmd patch tar xz    ;;
            *.tar.gz)  PATCH_CONTENT_TYPE=tar.gz ; package add dep.cmd patch tar gzip  ;;
            *.tar.lz)  PATCH_CONTENT_TYPE=tar.lz ; package add dep.cmd patch tar lzip  ;;
            *.tar.bz2) PATCH_CONTENT_TYPE=tar.bz2; package add dep.cmd patch tar bzip2 ;;
            *.tgz)     PATCH_CONTENT_TYPE=tar.gz ; package add dep.cmd patch tar gzip  ;;
            *.txz)     PATCH_CONTENT_TYPE=tar.xz ; package add dep.cmd patch tar xz    ;;
            *)  die "$1 : extension isn't recognized. the supported extensions are .diff .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
        esac

        [ ${#2} -eq 64 ] || die "$2 is not sha256sum. the length of sha256sum must be 64."

        shift 2
    done
}

# }}}
##############################################################################
# {{{ operations of formula

___load_a_formula() {
    die_if_package_is_not_available "$1"

    unset PACKAGE_NAME
    unset PACKAGE_SUMMARY
    unset PACKAGE_WEBPAGE
    unset PACKAGE_SRC_GIT
    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_SUM
    unset PACKAGE_SRC_NAME
    unset PACKAGE_SRC_PATH
    unset PACKAGE_SRC_TYPE
    unset PACKAGE_VERSION
    unset PACKAGE_LICENSE
    unset PACKAGE_PATCHES

    # relative to $WORKING_DIR, which contains build script such as configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, etc.
    unset PACKAGE_SOURCED

    unset PACKAGE_BSYSTEM
    unset PACKAGE_BINSRCD

    unset PACKAGE_BUILD_SYSTEM

    # if build in source dir, otherwise in build dir
    unset PACKAGE_BUILD_IN_SOURCE_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL

    # dependency commands
    unset PACKAGE_DEP_CMD

    # dependency python modules
    unset PACKAGE_DEP_PIP

    # dependency packages
    unset PACKAGE_DEP_PKG

    unset PACKAGE_CDEFINE
    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_FORMULA_FILEPATH

    unset PACKAGE_SDK_API

    unset -f build0
    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_NAME="$1"

    PACKAGE_FORMULA_FILEPATH="$(__pathof_a_formula $1)"

    . "$PACKAGE_FORMULA_FILEPATH" || die "$PACKAGE_FORMULA_FILEPATH is broken."

    PACKAGE_BUILD_SYSTEM=$PACKAGE_BSYSTEM
    PACKAGE_BUILD_IN_SOURCE_DIR=$PACKAGE_BINSRCD

    [ -z "$PACKAGE_SUMMARY" ] && die "summary must be configed in $PACKAGE_FORMULA_FILEPATH"

    [ -z "$PACKAGE_WEBPAGE" ] && PACKAGE_WEBPAGE="$PACKAGE_SRC_GIT"
    [ -z "$PACKAGE_WEBPAGE" ] && die "webpage or src.git must be configed in $PACKAGE_FORMULA_FILEPATH"

    [ -z "$PACKAGE_SRC_URL" ] && PACKAGE_SRC_URL="$PACKAGE_SRC_GIT"
    [ -z "$PACKAGE_SRC_URL" ] && die "src.url or src.git must be configed in $PACKAGE_FORMULA_FILEPATH"

    case $PACKAGE_SRC_URL in
        dir://*)   PACKAGE_SRC_TYPE=dir ;;
        *.git)     PACKAGE_SRC_TYPE=git    ; package add dep.cmd git ;;
        *.zip)     PACKAGE_SRC_TYPE=zip    ; package add dep.cmd curl unzip ;;
        *.tar.xz)  PACKAGE_SRC_TYPE=tar.xz ; package add dep.cmd curl tar xz ;;
        *.tar.gz)  PACKAGE_SRC_TYPE=tar.gz ; package add dep.cmd curl tar gzip ;;
        *.tar.lz)  PACKAGE_SRC_TYPE=tar.lz ; package add dep.cmd curl tar lzip ;;
        *.tar.bz2) PACKAGE_SRC_TYPE=tar.bz2; package add dep.cmd curl tar bzip2 ;;
        *.tgz)     PACKAGE_SRC_TYPE=tar.gz ; package add dep.cmd curl tar gzip ;;
        *.txz)     PACKAGE_SRC_TYPE=tar.xz ; package add dep.cmd curl tar xz ;;
        *.c)       PACKAGE_SRC_TYPE=c      ; package add dep.cmd curl ;;
        *.cc)      PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *.cxx)     PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *.cpp)     PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    case $PACKAGE_SRC_TYPE in
        dir)
            if command -v cut > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | cut -c7-${#PACKAGE_SRC_URL})
            elif command -v awk > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | awk '{print(substr($0, 7))}')
            else
                PACKAGE_SRC_PATH=$(expr substr "$PACKAGE_SRC_URL" 7 ${#PACKAGE_SRC_URL})
            fi
            [ -d "$PACKAGE_SRC_PATH" ] || die "src.url point to dir is not exist."
            ;;
        git)
            PACKAGE_SRC_NAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_PATH="$MY_CACHED_SOURCE_DIR/$PACKAGE_SRC_NAME"
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SUM" ] ; then
                die "src.sum is not configed in $PACKAGE_FORMULA_FILEPATH"
            fi
            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr _ - | sed 's|-stable||' | sed 's|-src||' | sed 's|\.src||' | sed 's|\.orig\.|.|' | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.lz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                if [ -z "$PACKAGE_VERSION" ] ; then
                    die "version is not configed in $PACKAGE_FORMULA_FILEPATH"
                else
                    case $PACKAGE_VERSION in
                        v*) if command -v cut > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | cut -c2-${#PACKAGE_VERSION})
                            elif command -v awk > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | awk '{print(substr($0, 2))}')
                            else
                                PACKAGE_VERSION=$(expr substr "$PACKAGE_VERSION" 2 ${#PACKAGE_VERSION})
                            fi
                    esac
                fi
            fi
            PACKAGE_SRC_NAME="$PACKAGE_NAME-$PACKAGE_VERSION.$PACKAGE_SRC_TYPE"
            PACKAGE_SRC_PATH="$MY_CACHED_SOURCE_DIR/$PACKAGE_SRC_NAME"
    esac

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     package add dep.cmd perl m4 autoconf automake make ;;
            autotools)   package add dep.cmd perl m4 autoconf automake make ;;
            configure)   package add dep.cmd make ;;
            ndk-build)   package add dep.cmd make ;;
            cmake)       package add dep.cmd cmake make  ;;
            cmake-make)  package add dep.cmd cmake make  ;;
            cmake-ninja) package add dep.cmd cmake ninja ;;
            meson)       package add dep.cmd meson ninja ;;
            make)        package add dep.cmd make  ;;
            ninja)       package add dep.cmd ninja ;;
            cargo)       package add dep.cmd rustup cargo ;;
            go)          package add dep.cmd go ;;
        esac
    done

    if [ -n "$PACKAGE_PATCHES" ] ; then
        __parse_package_patches $PACKAGE_PATCHES
    fi

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = 'false' ] ; then
        NJOBS=1
    fi

    if [ "$PACKAGE_BUILD_SYSTEM" = 'go' ] ; then
        PACKAGE_BINSRCD='true'
        PACKAGE_BUILD_IN_SOURCE_DIR='true'
    fi

    package add dep.cmd 'tree'

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        package add dep.cmd 'gsed'
    fi

    package add dep.cmd 'find'
}

____view_a_formula() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__pathof_a_formula $1)"

    [ -z "$PACKAGE_FORMULA_FILEPATH" ] && die "$1 package is not available."

    [ -z "$2" ] || warn "view action accept only one argument."
    
    if command -v bat > /dev/null ; then
        bat "$PACKAGE_FORMULA_FILEPATH"
    else
        cat "$PACKAGE_FORMULA_FILEPATH"
        echo
        prompt_user_to_install_bat
    fi    
}

____edit_a_formula() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__pathof_a_formula $1)"

    [ -z "$PACKAGE_FORMULA_FILEPATH" ] && die "$1 package is not available."

    [ -z "$2" ] || warn "edit action accept only one argument."

    [ -z "$EDITOR" ] && EDITOR=$(command -v nvim || command -v vim || command -v vi || command -v open)
    [ -z "$EDITOR" ] && die "please set EDITOR environment variable."

    "$EDITOR" "$PACKAGE_FORMULA_FILEPATH"
}

__create_a_formula() {
    die_if_package_is_not_specified "$1"

    unset REPO_NAME
    REPO_NAME=offical

    if [ -e "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh" ] ; then
        die "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh formula already exists."
    fi

    cat > "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh" <<EOF
package set summary "Summary of this package"

package set webpage "https://www.xx.com"

# the source code download url of this package. the value of src_url must end with one of .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz
package set src.url "https://www.xx.com/pkgname-x.y.z.tar.gz"

# the sha256sum of source code. If the value of src_url end with .git, this function is optional, otherwise, this function must be invoked.
package set src.sum "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1"

# the version of this package. If this function is not invoked, it will be calculated from src_url.
#package set version "x.y.z"

# the license of this package.
#package set license "MIT"

# the required commands of this package when installing. If specify multiple values, separate them with spaces.
#package set dep.cmd "a b c"

# the packages are depended by this package. If specify multiple values, separate them with spaces.
#package set dep.pkg "a b c"

prepare() {
    :
    #this function is optional, you can delete it, if don't use it.
}

build() {
    :
    #configure
    #cargow
    #mesonw
    #cmakew
    #makew
}
EOF
    ____edit_a_formula "$1"
}

__delete_a_formula() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__pathof_a_formula $1)"

    [ -z "$PACKAGE_FORMULA_FILEPATH" ] && die "$1 package is not available."

    if rm "$PACKAGE_FORMULA_FILEPATH" ; then
        success "delete $1 formula success."
    else
        die "delete $1 formula failed."
    fi
}

__rename_a_formula() {
    die_if_package_is_not_specified "$1"
    die_if_package_is_not_specified "$2"

    unset PACKAGE_FORMULA_REPO
    PACKAGE_FORMULA_REPO="$(__repoof_a_formula $1)"

    if [ -z "$PACKAGE_FORMULA_REPO" ] ; then
        die "$1 package is not available."
    fi

    unset PACKAGE_FORMULA_FILEPATH_OLD
    unset PACKAGE_FORMULA_FILEPATH_NEW

    PACKAGE_FORMULA_FILEPATH_OLD="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$1.sh"
    PACKAGE_FORMULA_FILEPATH_NEW="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$2.sh"

    if [ -f "$PACKAGE_FORMULA_FILEPATH_NEW" ] ; then
        die "$2 package is already exist."
    fi

    if mv "$PACKAGE_FORMULA_FILEPATH_OLD" "$PACKAGE_FORMULA_FILEPATH_NEW" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi
}

__list_formulas() {
    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -d  "$MY_FORMULA_REPO_DIR/$repo/formula" ] ; then
            ls "$MY_FORMULA_REPO_DIR/$repo/formula"/*.sh
        fi
    done
}

# __add_a_formula_repo NAME URL
__add_a_formula_repo() {
    [ -z "$1" ] && die "please specify a repo name."
    [ -z "$2" ] && die "please specify a repo url."

    case $2 in
        *.git)
            case $2 in
                http://*|https://*|git@*) ;;
                *)  die "$2: not a valid git url."
            esac
            ;;
        *)  die "$2: repo url must end with .git"
    esac

    for repoName in $(____list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            die "$1 formula repo already exists."
        fi
    done

    echo "$1=$2" >> "$MY_HOME_DIR/repos"
}

# __del_a_formula_repo NAME
__del_a_formula_repo() {
    [ -z "$1" ] && die "please specify a repo name."

    if [ "$1" = 'offical' ] ; then
        die "offical formula repo can not be deleted."
    fi

    unset REPO_EXISTS
    for repoName in $(____list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            REPO_EXISTS=true
        fi
    done
    if [ "$REPO_EXISTS" = 'true' ] ; then
        sed_in_place "/^$1=/d" "$MY_HOME_DIR/repos"
    else
        die "$1 formula repo not exists."
    fi
}

__repoof_a_formula() {
    die_if_package_is_not_specified "$1"

    for repo in $(____list_formula_repositories | cut -d= -f1)
    do
        if [ -e  "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh" ] ; then
            echo "$repo"
            return 0
        fi
    done

    return 1
}

__pathof_a_formula() {
    die_if_package_is_not_specified "$1"

    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -e  "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh" ] ; then
            echo "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh"
            return 0
        fi
    done

    return 1
}

____list_formula_repositories() {
    if [ -e "$MY_HOME_DIR/repos" ] ; then
        cat "$MY_HOME_DIR/repos"
    else
        install -d "$MY_HOME_DIR"
        echo "offical=$MY_OFFICAL_FORMULA_REPO_URL" | tee "$MY_HOME_DIR/repos"
    fi
}

__update_formula_repositories() {
    handle_dependency required command git || return 1

    for repo in $(____list_formula_repositories)
    do
        unset MY_FORMULA_REPO_NAME
        unset MY_FORMULA_REPO_URL_

        MY_FORMULA_REPO_NAME=$(echo "$repo" | cut -d= -f1)
        MY_FORMULA_REPO_URL_=$(echo "$repo" | cut -d= -f2)

        info "=== Updating repository ${COLOR_GREEN}$MY_FORMULA_REPO_NAME${COLOR_OFF}"
        fetch "$MY_FORMULA_REPO_URL_" --output-dir="$MY_FORMULA_REPO_DIR" --output-name="$MY_FORMULA_REPO_NAME" || return 1
    done
}

# }}}
##############################################################################

prompt_user_to_install_bat() {
    warn "if you want to have a better experience, I strongly recommend you install ${COLOR_RED}bat${COLOR_OFF} on your os. For more details, see ${COLOR_RED}https://github.com/sharkdp/bat${COLOR_OFF}"
}

__fetch_sources_of_a_package() {
    # fetch source code if needed
    if [ "$PACKAGE_SRC_TYPE" != 'dir' ] ; then
        fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SUM" --output-path="$PACKAGE_SRC_PATH"
    fi
}

__fetch_patches_of_a_package() {
    unset PACKAGE_PATCHES

    # fetch patches if posible
    while [ -n "$1" ]
    do
        fetch "$1" --sha256="$2" --output-dir="$MY_CACHED_PATCH__DIR/$PACKAGE_NAME" --output-name="$(basename $1)"

        if [ -z "$PACKAGE_PATCHES" ] ; then
            PACKAGE_PATCHES="$FETCH_OUTPUT_PATH"
        else
            PACKAGE_PATCHES="$PACKAGE_PATCHES $FETCH_OUTPUT_PATH"
        fi

        shift 2
    done
}

__fetch_resources_of_a_package() {
    __fetch_sources_of_a_package &&
    __fetch_patches_of_a_package $PACKAGE_PATCHES
}

die_if_package_is_not_specified() {
    [ -z "$1" ] && die "please specify a package name."
}

die_if_package_list_is_not_specified() {
    [ -z "$1" ] && die "please specify at least one package name."
}

die_if_package_is_not_available() {
    is_package_available "$1" || die "$1 is not available."
}

die_if_package_is_already_exist() {
    die_if_package_is_not_specified "$1"
    [ -n "$(__pathof_a_formula $1)" ] && die "$1 package is already exist."
}

die_from_package_is_not_installed() {
    die "$1 is not installed."
}

die_if_package_is_not_installed() {
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
}

is_package_available() {
    die_if_package_is_not_specified "$1"
    [ -n "$(__pathof_a_formula $1)" ]
}

is_package_installed() {
    die_if_package_is_not_specified "$1"
    
    [ -d "$MY_INSTALL_DIR/$1" ]                      || return 1
    [ -f "$MY_CACHED_LOG_DIR/$1/installed.log.txt" ] || return 1
}

is_package__outdated() {
    ___load_a_formula "$1"

    [ -d "$MY_INSTALL_DIR/$1" ]                      || die_from_package_is_not_installed "$1"
    [ -f "$MY_CACHED_LOG_DIR/$1/installed.log.txt" ] || die_from_package_is_not_installed "$1"
}

__gen_github_workflows() {
    unset BREAK
    unset NDEPENDED_PACKAGES
    unset AVAILABLE_PACKAGES
    unset GROUP_SIZE
    unset OUTPUT_DIR
    unset I

    while [ -n "$1" ]
    do
        case $1 in
            --group-size=*)
                GROUP_SIZE=$(getvalue "$1")
                is_integer "$GROUP_SIZE" || die "--group-size=INTEGER"
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                [ -z "$OUTPUT_DIR" ] && die "--output-dir=DIR DIR must be not empty."
                [ -d "$OUTPUT_DIR" ] || run install -d "$OUTPUT_DIR"
        esac
        shift
    done

    [ -z "$GROUP_SIZE" ] && die "please sepecify --group-size=INTEGER argument."
    [ -z "$OUTPUT_DIR" ] && die "please sepecify --output-dir=DIR argument."

    AVAILABLE_PACKAGES=$(__list_available_packages)

    for x in $AVAILABLE_PACKAGES
    do
        if [ "$x" = 'test' ] ; then
            continue
        fi
        for y in $AVAILABLE_PACKAGES
        do
            if [ "$x" = "$y" ] || [ 'test' = "$y" ] ; then
                continue
            else
                for z in $(get_direct_dependency_package_list_of_a_package "$y")
                do
                    if [ "$x" = "$z" ] ; then
                        BREAK=true
                        break 2
                    fi
                done
            fi
        done
        if [ "$BREAK" = 'true' ] ; then
            unset BREAK
        else
            if [ -z "$NDEPENDED_PACKAGES" ] ; then
                NDEPENDED_PACKAGES="$x"
            else
                NDEPENDED_PACKAGES="$NDEPENDED_PACKAGES $x"
            fi
            if [ "$(list_length $NDEPENDED_PACKAGES)" -eq "$GROUP_SIZE" ] ; then
                unset OUTPUT_FILEPATH

                I=$(expr ${I-0} + 1)
                OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
                NDEPENDED_PACKAGES=$(echo "$NDEPENDED_PACKAGES" | tr ' ' ,)

                echo
                run cp "$MY_HOME_DIR/github-workflow-template" "$OUTPUT_FILEPATH"
                sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
                sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"

                unset NDEPENDED_PACKAGES
            fi
        fi
    done
    if [ -n "$NDEPENDED_PACKAGES" ] ; then
        unset OUTPUT_FILEPATH

        I=$(expr ${I-0} + 1)
        OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
        NDEPENDED_PACKAGES=$(echo "$NDEPENDED_PACKAGES" | tr ' ' ,)

        run cp "$MY_HOME_DIR/github-workflow-template" "$OUTPUT_FILEPATH"
        sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
        sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"
    fi
}

__list_available_packages() {
    unset SILENT

    case $# in
        0)  ;;
        1)  if [ "$1" = '-q' ] ; then
                SILENT=true
            else
                die "list available action only accept -q argument."
            fi
            ;;
        *)  die "list available action only accept -q argument."
    esac

    for repo in $(____list_formula_repositories | cut -d= -f1)
    do
        if [ "$SILENT" = 'true' ] ; then
            cd "$MY_FORMULA_REPO_DIR/$repo/formula" 2>/dev/null || return 1
        else
            cd "$MY_FORMULA_REPO_DIR/$repo/formula" || return 1
        fi
        ls -1 *.sh | sed 's/\.sh//g'
    done
}

__list_installed_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

__list__outdated_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        echo "$packageName"
    done
}

__tree_installed_of_a_package() {
    die_if_package_is_not_installed "$1"
    handle_dependency required command tree
    run tree $(shiftn 1 $@) --dirsfirst "$MY_INSTALL_DIR/$1"
}

__uninstall_packages() {
    shift

    die_if_package_list_is_not_specified "$1"
    
    for packageName in $@
    do
        __uninstall_a_package "$packageName" || return 1
    done
}

__uninstall_a_package() {
    die_if_package_is_not_installed "$1"

    run rm -rf "$MY_INSTALL_DIR/$1"
}

__reinstall_packages() {
    parse_arguments $@

    die_if_package_list_is_not_specified "$USER_SPECIFIED_PACKAGE_LIST"

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done
    
    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        __install_a_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done
}

__upgrade_packages() {
    parse_arguments $@

    [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] && USER_SPECIFIED_PACKAGE_LIST=$(__list__outdated_packages)
    [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] && return 0

    __reinstall_packages
}

__upgrade_self() {
    set -e

    unset FETCH_SELF_OUTPUT_DIR
    FETCH_SELF_OUTPUT_DIR=$(mktemp -d)

    unset FETCH_SELF_OUTPUT_PATH
    FETCH_SELF_OUTPUT_PATH="$FETCH_SELF_OUTPUT_DIR/self"

    fetch "$MY_UPGRAGE_URL" --output-path="$FETCH_SELF_OUTPUT_PATH"

    run chmod a+x "$FETCH_SELF_OUTPUT_PATH"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_FILEPATH" ] ; then
            run      cp "$FETCH_SELF_OUTPUT_PATH" "$CURRENT_SCRIPT_FILEPATH"
        else
            run sudo cp "$FETCH_SELF_OUTPUT_PATH" "$CURRENT_SCRIPT_FILEPATH"
        fi
    }

    trap __upgrade_self_exit EXIT
}

__cleanup() {
    [ -d "$MY_CACHED_DIR" ] || return 0
    [ -d "$MY_CACHED_SOURCE_DIR" ] || return 0
    for repo in $(____list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" || return 1
        for item in $(ls)
        do
            if [ -f "$item" ] ; then
                case $item in
                    *.sh)
                        ___load_a_formula $(echo "$item" | sed 's/\.sh//g')
                esac
            fi
        done
    done
    success "Done."
}

__search_packages() {
    [ -z "$1" ] && die "please specify a keyword."

    for repo in $(____list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" && ls -1 *.sh | sed 's/\.sh//g' | grep "$*"
    done
}

__show_webpage_of_a_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        ___load_a_formula "$1"
    fi
    
    echo "$PACKAGE_WEBPAGE"

    if command -v open > /dev/null ; then
        open "$PACKAGE_WEBPAGE"
    fi
}

__show_depends_of_a_package() {
    die_if_package_is_not_specified "$1"

    __gen_dependency_tree "$1"

    if [ -f "$DEPENDENCIES_TXT" ] ; then
        cat "$DEPENDENCIES_TXT"
    elif [ -f "$DEPENDENCIES_PNG" ] ; then
        for item in open feh eog lsix
        do
            if command -v $item > /dev/null ; then
                $item "$DEPENDENCIES_PNG" && return 0
            fi
        done
    elif [ -f "$DEPENDENCIES__GV" ] ; then
        cat "$DEPENDENCIES__GV"
    fi
}

__show_prefix_of_a_package() {
    if [ -z "$1" ] ; then
        echo "$MY_HOME_DIR"
    else
        die_if_package_is_not_installed "$1"
        echo "$MY_INSTALL_DIR/$1"
    fi
}

__show_logs_of_a_package() {
    die_if_package_is_not_installed "$1"

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    for item in $(ls "$MY_CACHED_LOG_DIR/$1"/*)
    do
        if [ "$VIEWER" = 'bat' ] ; then
            case $item in
                *.png) ;;
                *.sh|*/installed.log.txt)
                    bat -l bash "$item" ;;
                *)  bat "$item"
            esac
        else
            "$VIEWER" "$item"
        fi
    done

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

__pack_bottle_of_a_package() {
    die_if_load_installed_log_failed "$1"

    install -d "$MY_CACHED_BINARY_DIR" || return 1

    if command -v 7za > /dev/null ; then
        SUFFIX=7z
    elif command -v zip > /dev/null ; then
        SUFFIX=zip
    elif command -v tar > /dev/null ; then
        if command -v gzip > /dev/null ; then
            SUFFIX=tar.gz
        elif command -v xz > /dev/null ; then
            SUFFIX=tar.xz
        elif command -v bzip2 > /dev/null ; then
            SUFFIX=tar.bz2
        else
            die "please install gzip or xz or bzip2 utility."
        fi
    else
        die "please install zip or tar utility."
    fi

    FILE_PATH="$MY_CACHED_BINARY_DIR/$1-$installed_pkg_vers-$NATIVE_OS_KIND-$NATIVE_OS_ARCH.$SUFFIX"

    if [ -f "$FILE_PATH" ] ; then
        rm  "$FILE_PATH" || return 1
    fi

    case $SUFFIX in
        7z)  run 7za a -t7z -r "$FILE_PATH" "$MY_INSTALL_DIR/$1" ;;
        zip) run cd "$MY_INSTALL_DIR" && run zip -9 -r "$FILE_PATH" "$1" ;;
        tar.gz)  run tar zvcf "$FILE_PATH" -C "$MY_INSTALL_DIR" "$1" ;;
        tar.xz)  run tar Jvcf "$FILE_PATH" -C "$MY_INSTALL_DIR" "$1" ;;
        tar.bz2) run tar jvcf "$FILE_PATH" -C "$MY_INSTALL_DIR" "$1" ;;
    esac
}

get_direct_dependency_package_list_of_a_package() {
    grep '^\s*package set dep\.pkg\s*".*"' $(__pathof_a_formula $1) | sed 's/.*package set dep\.pkg.*"\(.*\)"/\1/'
}

# $1 packageName, if packageName is not specified, USER_SPECIFIED_PACKAGE_LIST will be used
# $2 is invoked by myself
__gen_dependency_list() {
    if [ "$2" != 'true' ] ; then
        unset I
        unset DEPENDENCY_PACKAGE_LIST
    fi

    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    if [ -z "$1" ] ; then
        DIRECT_DEPENDENCY_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST"
    else
        DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_a_package "$1")
    fi
    
    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        die_if_package_is_not_available "$dependencyPkgName"

        DEPENDENCY_PACKAGE_LIST_TEMP=""

        for item in $DEPENDENCY_PACKAGE_LIST
        do
            if [ "$dependencyPkgName" = "$item" ] ; then
                continue
            else
                DEPENDENCY_PACKAGE_LIST_TEMP="$DEPENDENCY_PACKAGE_LIST_TEMP $item"
            fi
        done
        
        DEPENDENCY_PACKAGE_LIST="$dependencyPkgName $DEPENDENCY_PACKAGE_LIST_TEMP"

        __gen_dependency_list "$dependencyPkgName" true
    done
}

# $1 packageName
# $2 is invoked by myself | [output-dir]
__gen_dependency_tree() {
    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_a_package "$1")

    case $2 in
        true) ;;
        *)
            unset I

            unset DEPENDENCIES__GV
            unset DEPENDENCIES_PNG
            unset DEPENDENCIES_TXT

            unset DEPENDENCIES_OUTPUT_DIR

            if [ -z "$2" ] ; then
                DEPENDENCIES_OUTPUT_DIR=$(mktemp -d) || return 1
            else
                DEPENDENCIES_OUTPUT_DIR="$2"
            fi

            DEPENDENCIES__GV="$DEPENDENCIES_OUTPUT_DIR/$1.dependencies.gv"
            DEPENDENCIES_PNG="$DEPENDENCIES_OUTPUT_DIR/$1.dependencies.png"
            DEPENDENCIES_TXT="$DEPENDENCIES_OUTPUT_DIR/$1.dependencies.txt"
            
            if [ -n "$DIRECT_DEPENDENCY_PACKAGE_LIST" ] ; then
                echo "digraph \"$1\" {" > "$DEPENDENCIES__GV"
            fi
    esac

    if [ -f "$DEPENDENCIES__GV" ] ; then
        print "  \"$1\" -> {" >> "$DEPENDENCIES__GV"
        for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
        do
            print " \"$dependencyPkgName\"" >> "$DEPENDENCIES__GV"
        done
        echo " }" >> "$DEPENDENCIES__GV"
    fi

    I=$(expr ${I-0} + 1)

    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        __gen_dependency_tree "$dependencyPkgName" true
    done

    I=$(expr $I - 1)

    if [ "$I" -eq 0 ] ; then
        if [ -f "$DEPENDENCIES__GV" ] ; then
            echo "}" >> "$DEPENDENCIES__GV"

            if command -v dot > /dev/null ; then
                run dot -Tpng -o "$DEPENDENCIES_PNG" "$DEPENDENCIES__GV"
            else
                warn "graphviz is not installed. we do not generate png format dependency image."
            fi

            # https://github.com/ggerganov/dot-to-ascii
            curl \
                -o "$DEPENDENCIES_TXT" \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$(cat $DEPENDENCIES__GV)" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php" || true
        fi
    fi
}

__install_packages() {
    parse_arguments $@

    die_if_package_list_is_not_specified $USER_SPECIFIED_PACKAGE_LIST

    __gen_dependency_list || return 1

    if [ $(list_length $DEPENDENCY_PACKAGE_LIST) -gt 1 ] ; then
        echo "$COLOR_PURPLE==>$COLOR_OFF to install$COLOR_GREEN $DEPENDENCY_PACKAGE_LIST $COLOR_OFF\n"
    fi

    for INSTALLING_PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        if is_package_installed "$INSTALLING_PACKAGE" ; then
            printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$INSTALLING_PACKAGE"
        else
            PACKAGE_LOG_DIR="$MY_CACHED_LOG_DIR/$INSTALLING_PACKAGE"
            rm -rf     "$PACKAGE_LOG_DIR" || return 1
            install -d "$PACKAGE_LOG_DIR" || return 1
            __install_a_package "$INSTALLING_PACKAGE" | tee "$PACKAGE_LOG_DIR/install.log.txt" || die "install $INSTALLING_PACKAGE failed! you can go to $WORKING_DIR to see see."
        fi
    done
}

__install_a_package() {
    echo "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}$1${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"

    # brew install meson
    # Error: The current working directory doesn't exist, cannot proceed.
    # beacuse previous package's working direcotory is deleted.
    cd ~ || return 1

    unset STEP_NUM
    unset STEP_MESSAGE

    unset WORKING_DIR
    unset SOURCE_DIR
    unset BUILD_DIR

    unset PACKAGE_INSTALL_DIR
    unset PACKAGE_INCLUDE_DIR
    unset PACKAGE_LIBRARY_DIR
    unset PACKAGE_PKGCONF_DIR
    unset PACKAGE_BINARY__DIR

    unset MAP_REQUIRED_DEPENDENCIES
    MAP_REQUIRED_DEPENDENCIES='MAP_REQUIRED_DEPENDENCIES'

    step "show current machine os info"
    echo "NATIVE_OS_KIND  = $NATIVE_OS_KIND"
    echo "NATIVE_OS_TYPE  = $NATIVE_OS_TYPE"
    echo "NATIVE_OS_NAME  = $NATIVE_OS_NAME"
    echo "NATIVE_OS_VERS  = $NATIVE_OS_VERS"
    echo "NATIVE_OS_ARCH  = $NATIVE_OS_ARCH"
    echo "NATIVE_OS_LIBC  = $NATIVE_OS_LIBC"
    
    if [ "$NATIVE_OS_KIND" != 'windows' ] ; then
        [ "$(whoami)" = root ] || sudo=sudo
    fi
    
    step "show current machine os effective user info"
    id | tr ' ' '\n' | head -n 2

    step "show formula"
    run cat $(__pathof_a_formula $1)

    step "load formula"
    ___load_a_formula "$1"

    step "handle required commands"
    for item in $PACKAGE_DEP_CMD
    do
        handle_dependency $(__parse_require_command_item "$item")
    done

    step "printf required commands"
    __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
    for item in $PACKAGE_DEP_CMD
    do
        printf_dependency $(__parse_require_command_item "$item")
    done
    for item in $PACKAGE_DEP_PIP
    do
        printf_dependency $(__parse_require_python_module_item "$item")
    done

    unset PKG_CONFIG
    unset MESON
    unset CMAKE
    unset GMAKE
    unset NINJA

    PKG_CONFIG=$(command -v pkg-config)
    MESON=$(command -v meson)
    CMAKE=$(command -v cmake)
    GMAKE=$(command -v gmake || command -v make)
    NINJA=$(command -v ninja)

    step "calculate dependencies"
    unset DEPENDENCY_PACKAGE_LIST
    if [ -z "$PACKAGE_DEP_PKG" ] ; then
        warn "no dependencies."
    else
        __gen_dependency_list "$1"                         || return 1
        __gen_dependency_tree "$1" "$MY_CACHED_LOG_DIR/$1" || return 1
        if [ -f "$DEPENDENCIES_TXT" ] ; then
            cat "$DEPENDENCIES_TXT"
        fi
    fi

    step "fetch resources if needed"
    __fetch_resources_of_a_package "$1"

    step "create working directory"
    info "mktemp -d"
    WORKING_DIR=$(mktemp -d) || die "create working directory failed."

    if [ -z "$PACKAGE_SOURCED" ] ; then
        SOURCE_DIR="$WORKING_DIR"
    else
        SOURCE_DIR="$WORKING_DIR/$PACKAGE_SOURCED"
    fi

    BUILD_DIR="$WORKING_DIR/$TIMESTAMP_UNIX"
    mkdir "$BUILD_DIR" || return 1

    step "unpack sources to working directory"
    case $PACKAGE_SRC_URL in
        dir://*|*.git)
            PACKAGE_VERSION=$(cd "$PACKAGE_SRC_PATH" && git log -1 --pretty=format:%h) || return 1
            run cp -r "$PACKAGE_SRC_PATH/*" "$WORKING_DIR" || return 1
            ;;
        *.c|*.cc|*.cxx|*.cpp)
            run cp    "$PACKAGE_SRC_PATH"   "$WORKING_DIR" || return 1
            ;;
        *.zip)
            run unzip "$PACKAGE_SRC_PATH" -d "$WORKING_DIR" || return 1
            ;;
        *.tar.xz|*.tar.gz|*.tar.lz|*.tar.bz2|*.tgz|*.txz)
            run tar xf "$PACKAGE_SRC_PATH" -C "$WORKING_DIR" --strip-components 1 || return 1
            ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    step "change to source directory"
    run cd "$SOURCE_DIR" || return 1

    step "list content of source directory"
    run ls -l

    __config_build_variables "$1"
    __printf_build_variables "$1"

    step "do some preparation works"
    if command -v prepare > /dev/null ; then
        run prepare || return 1
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)
                warn "no prepare function defined in formula."
                run NOCONFIGURE=yes ./autogen.sh    || return 1
                ;;
            autotools)
                warn "no prepare function defined in formula."
                run autoreconf -ivf || return 1
                ;;
            *)  warn "no prepare function defined in formula, skipped."
        esac
    fi

    if [ "$DRYRUN" = 'true' ] ; then
        if [ -z "$SHELL" ] ; then
            SHELL=$(command -v zsh || command -v bash || command -v sh)
        fi
        exec "$SHELL" || return 1
    fi

    if [ -d "$PACKAGE_INSTALL_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALL_DIR" || return 1
    fi

    if [ "$PACKAGE_BUILD_IN_SOURCE_DIR" = 'true' ] ; then
        if [ "$PWD" != "$SOURCE_DIR" ] ; then
            run cd "$SOURCE_DIR" || return 1
        fi
    else
        run cd "$BUILD_DIR" || return 1
    fi

    step "building"
    if command -v build > /dev/null ; then
        build || return 1
    else
        {
            case $PACKAGE_BUILD_SYSTEM in
                autogen)   configure ;;
                autotools) configure ;;
                configure) configure ;;
                cmake*)    cmakew ;;
                meson)     mesonw ;;
                ninja)     ninja clean && ninja && ninja install ;;
                make)      makew clean && makew && makew install ;;
                cargo)     run cargo install -vv --path "$SOURCE_DIR" --root="$PACKAGE_INSTALL_DIR" ;;
                go)        run go build -v -trimpath ;;
            esac
        } || return 1
    fi

    [ -d "$PACKAGE_INSTALL_DIR" ] || {
        error "installed nothing."
        return 1
    }

    step "install logs"
    __install_logs "$1" || return 1

    step "clean working directory."
    if [ "$KEEP_WORKING_DIR" = 'true' ] ; then
        warn "keep  working directory."
    else
        run rm -rf "$WORKING_DIR"
    fi

    step "list installed content."
    __tree_installed_of_a_package "$1"

    echo
    success "$1 have been installed successfully."
}

__config_build_variables() {
    step "config build variables"

    unset CC
    unset CPP
    unset CXX
    unset AS
    unset LD
    unset AR
    unset NM
    unset RANLIB
    unset STRIP
    unset SIZE
    unset READELF
    unset STRINGS
    unset OBJCOPY
    unset OBJDUMP

    unset CFLAGS
    unset CPPFLAGS
    unset LDFLAGS

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_LIBDIR
    unset PKG_CONFIG_PATH

    unset TOOLCHAIN_ROOT_DIR
    unset TOOLCHAIN_BIN__DIR

    unset SYSROOT
    unset MACOSX_DEPLOYMENT_TARGET

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        TOOLCHAIN_ROOT_DIR="$(xcode-select -p)"
        TOOLCHAIN_BIN__DIR="$TOOLCHAIN_ROOT_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin"
        export PATH="$TOOLCHAIN_BIN__DIR:$PATH"

        SYSROOT="$TOOLCHAIN_ROOT_DIR/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
        MACOSX_DEPLOYMENT_TARGET="$(echo "$NATIVE_OS_VERS" | cut -d. -f1).$(echo "$NATIVE_OS_VERS" | cut -d. -f2)"

        CFLAGS="-isysroot $SYSROOT -arch $NATIVE_OS_ARCH -mmacosx-version-min=$MACOSX_DEPLOYMENT_TARGET -Qunused-arguments"
        CPPFLAGS="-isysroot $SYSROOT -Qunused-arguments"
        LDFLAGS="-isysroot $SYSROOT -arch $NATIVE_OS_ARCH -mmacosx-version-min=$MACOSX_DEPLOYMENT_TARGET"
    fi

    for tool in $(list_tools_in_the_toolchain)
    do
        if [ "$tool" = 'cpp' ] ; then
            CPP="$CC -E"
        else
            eval $(echo "$tool" | tr a-z A-Z)=$(echo_path_of_tool_in_the_toolchain "$tool")
        fi
    done

    for item in $PACKAGE_CDEFINE
    do
        CPPFLAGS="$CPPFLAGS -D$item"
    done

    if [ -n "$PACKAGE_CCFLAGS" ] ; then
        CFLAGS="$CFLAGS $PACKAGE_CCFLAGS"
    fi

    if [ -n "$PACKAGE_LDFLAGS" ] ; then
        LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"
    fi

    if [ "$VERBOSE" = 'true' ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi

    for PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        PKG=$(printf "$PACKAGE" | tr '-' '_')

        unset PKG_INSTALL_DIR
        unset PKG_BINARY__DIR
        unset PKG_INCLUDE_DIR
        unset PKG_LIBRARY_DIR
        unset PKG_PKGCONF_DIR

        PKG_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE"
        PKG_BINARY__DIR="$PKG_INSTALL_DIR/bin"
        PKG_INCLUDE_DIR="$PKG_INSTALL_DIR/include"
        PKG_LIBRARY_DIR="$PKG_INSTALL_DIR/lib"
        PKG_PKGCONF_DIR="$PKG_INSTALL_DIR/lib/pkgconfig"

        eval "${PKG}_INSTALL_DIR='$PKG_INSTALL_DIR'"
        eval "${PKG}_BINARY__DIR='$PKG_BINARY__DIR'"
        eval "${PKG}_INCLUDE_DIR='$PKG_INCLUDE_DIR'"
        eval "${PKG}_LIBRARY_DIR='$PKG_LIBRARY_DIR'"

        CPPFLAGS="-I$PKG_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$PKG_LIBRARY_DIR $LDFLAGS"

        if [ -z "$PKG_CONFIG_PATH" ] ; then
            PKG_CONFIG_PATH="$PKG_PKGCONF_DIR"
        else
            PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$PKG_PKGCONF_DIR"
        fi
    done

    if [ "$VERBOSE" = 'true' ] ; then
        CFLAGS="$CFLAGS -v"
    fi

    CXXFLAGS="$CFLAGS"

    if [ -n "$PACKAGE_XXFLAGS" ] ; then
        CXXFLAGS="$CXXFLAGS $PACKAGE_XXFLAGS"
    fi

    PACKAGE_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE_NAME"
    PACKAGE_BINARY__DIR="$PACKAGE_INSTALL_DIR/bin"
    PACKAGE_INCLUDE_DIR="$PACKAGE_INSTALL_DIR/include"
    PACKAGE_LIBRARY_DIR="$PACKAGE_INSTALL_DIR/lib"
    PACKAGE_PKGCONF_DIR="$PACKAGE_INSTALL_DIR/lib/pkgconfig"

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            cargo)
                # eval export CARGO_TARGET_${CARGO_TARGET_XXX}_AR=$AR
                # eval export CARGO_TARGET_${CARGO_TARGET_XXX}_LINKER=$CC

                # # https://libraries.io/cargo/cc
                # export HOST_CC="$CC_FOR_BUILD"
                # export HOST_CFLAGS="$CFLAGS_FOR_BUILD"

                # export HOST_CXX="$CXX_FOR_BUILD"
                # export HOST_CXXFLAGS="$CXXFLAGS_FOR_BUILD"

                # export HOST_AR="$AR_FOR_BUILD"
                ;;
               go)
                # https://golang.org/doc/install/source#environment
                export CGO_ENABLED=1
                export CGO_CFLAGS="$CFLAGS"
                export CGO_CXXFLAGS="$CXXFLAGS"
                export CGO_CPPFLAGS="$CPPFLAGS"
                export CGO_LDFLAGS="$LDFLAGS"

                export GO111MODULE="auto"
                export GOPROXY=https://goproxy.cn
                ;;
        esac
    done

    STATIC_LIBRARY_EXT=.a
    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        SHARED_LIBRARY_EXT=.dylib
    else
        SHARED_LIBRARY_EXT=.so
    fi
}

__printf_build_variables() {
    step "printf build variables"

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export $TOOL=\"\$$TOOL\"
        printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export $FLAG=\"\$$FLAG\"
        printf "\n%17s = " "$FLAG"
        FIRST=true
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = 'true' ] ; then
                FIRST=false
                echo "$item"
            else
                echo "                    $item"
            fi
        done
    done

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            cargo)
                echo
                env | grep CARGO
                echo
                echo "    HOST_AR       = $HOST_AR"
                echo "    HOST_CC       = $HOST_CC"
                echo "    HOST_CXX      = $HOST_CXX"
                echo "    HOST_CFLAGS   = $HOST_CFLAGS"
                echo "    HOST_CXXFLAGS = $HOST_CXXFLAGS"
                echo
                echo "  TARGET_AR       = $TARGET_AR"
                echo "  TARGET_CC       = $TARGET_CC"
                echo "  TARGET_CXX      = $TARGET_CXX"
                echo "  TARGET_CFLAGS   = $TARGET_CFLAGS"
                echo "  TARGET_CXXFLAGS = $TARGET_CXXFLAGS"
                ;;
               go)
                echo
                echo "      GO111MODULE = $GO111MODULE"
                echo "      GOPROXY     = $GOPROXY"
                echo
                echo "     CGO_ENABLED  = $CGO_ENABLED"
                echo "     CGO_CFLAGS   = $CGO_CFLAGS"
                echo "     CGO_CXXFLAGS = $CGO_CXXFLAGS"
                echo "     CGO_CPPFLAGS = $CGO_CPPFLAGS"
                echo "     CGO_LDFLAGS  = $CGO_LDFLAGS"
                ;;
        esac
    done

    echo
    echo
    echo " STATIC_LIBRARY_EXT = $STATIC_LIBRARY_EXT"
    echo " SHARED_LIBRARY_EXT = $SHARED_LIBRARY_EXT"
    echo
    echo "     TIMESTAMP_UNIX = $TIMESTAMP_UNIX"
    echo
    echo "        WORKING_DIR = $WORKING_DIR"
    echo "         SOURCE_DIR = $SOURCE_DIR"
    echo "          BUILD_DIR = $BUILD_DIR"
    echo
    echo "PACKAGE_INSTALL_DIR = $PACKAGE_INSTALL_DIR"
    echo "PACKAGE_BINARY__DIR = $PACKAGE_BINARY__DIR"
    echo "PACKAGE_INCLUDE_DIR = $PACKAGE_INCLUDE_DIR"
    echo "PACKAGE_LIBRARY_DIR = $PACKAGE_LIBRARY_DIR"
    echo "PACKAGE_PKGCONF_DIR = $PACKAGE_PKGCONF_DIR"
    echo
    echo "              NPROC = $NPROC"
    echo "              NJOBS = $NJOBS"

    step "list PATH"
    for item in $(echo "$PATH" | tr ' ' '|' | tr ':' ' ')
    do
        echo "$item" | tr '|' ' '
    done

    if [ "$VERBOSE" = 'true' ] ; then
        step "show export variables"
        run export -p
        echo
    fi
}

__install_logs() {
    install_installed_log

    for item in "$BUILD_DIR" "$SOURCE_DIR"
    do
        for item2 in 'config.log' 'compile_commands.json'
        do
            if [ -f "$item/$item2" ] ; then
                echo "-- Installing: $PACKAGE_LOG_DIR/$item2"
                install -m 644 "$item/$item2" "$PACKAGE_LOG_DIR" || return 1
            fi
        done
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(echo "$1" | cut -d: -f1)
        X2=$(echo "$1" | cut -d: -f2)

        [ "$X1" = "$X2" ] && unset X2

        install -v -d         "$PACKAGE_INCLUDE_DIR/$X2" || return 1
        install -v -m 644 $X1 "$PACKAGE_INCLUDE_DIR/$X2" || return 1

        shift
    done
}

install_libs() {
    install -v -d "$PACKAGE_LIBRARY_DIR" || return 1
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$PACKAGE_LIBRARY_DIR" || return 1 ;;
            *)   install -v -m 755 $item "$PACKAGE_LIBRARY_DIR" || return 1 ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$PACKAGE_PKGCONF_DIR" &&
    install -v -m 644 $@ "$PACKAGE_PKGCONF_DIR"
}

install_bins() {
    install -v -d        "$PACKAGE_BINARY__DIR" &&
    install -v -m 755 $@ "$PACKAGE_BINARY__DIR"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER"
    done
}

install_pc_file() {
    install -v -d "$PACKAGE_PKGCONF_DIR" &&
    cat >         "$PACKAGE_PKGCONF_DIR/$1.pc"
}

__show_infomation_of_packages() {
    unset OUTPUT_FORMAT
    unset PACKAGE_LIST

    while [ -n "$1" ]
    do
        case $1 in
            --json) OUTPUT_FORMAT=json ;;
            *)      die_if_package_is_not_available $1; PACKAGE_LIST="$PACKAGE_LIST $1"
        esac
        shift
    done

    if [ -z "$PACKAGE_LIST" ] ; then
        PACKAGE_LIST=$(__list_available_packages) || return 1
    fi

    unset I
    unset PACKAGE_LIST_LENGTH
    PACKAGE_LIST_LENGTH=$(list_length $PACKAGE_LIST)

    if [ "$OUTPUT_FORMAT" = 'json' ] ; then
        for PACKAGE in $PACKAGE_LIST
        do
            ___load_a_formula "$PACKAGE"

            I=$(expr ${I-0} + 1)

            if [ "$I" -eq 1 ] ; then
                echo "["
            fi

            if [ "$I" -eq "$PACKAGE_LIST_LENGTH" ] ; then
                printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"}]\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
            else
                printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"},\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
            fi
        done
    else
        for PACKAGE in $PACKAGE_LIST
        do
            I=$(expr ${I-0} + 1)

            if [ "$I" -gt 1 ] ; then
                echo "============================================================"
            fi

            __show_infomation_of_a_package "$PACKAGE"
        done
    fi
}

__show_infomation_of_a_package() {
    ___load_a_formula "$1"

    echo "name    : $(mark_is_package_installed_or_not $1)"

    if [ -n "$PACKAGE_VERSION" ] ; then
        echo "version : $PACKAGE_VERSION"
    fi

    echo "summary : $PACKAGE_SUMMARY"
    echo "webpage : $PACKAGE_WEBPAGE"

    [ -z "$PACKAGE_DEP_PKG" ] || {
        unset DEPENDENCIES

        for dependencyPkgName in $PACKAGE_DEP_PKG
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES="depends : $(mark_is_package_installed_or_not $dependencyPkgName)"
            else
                DEPENDENCIES="$DEPENDENCIES | $(mark_is_package_installed_or_not $dependencyPkgName)"
            fi
        done

        echo "$DEPENDENCIES"
    }

    echo "src_url : $PACKAGE_SRC_URL"

    case $PACKAGE_SRC_TYPE in
        dir) ;;
        git)
            if [ -d "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
            ;;
        *)
            if [ -f "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
    esac

    if is_package_installed "$1" ; then
        echo "installed ${COLOR_PURPLE}==>${COLOR_OFF} $(du -sh "$MY_INSTALL_DIR/$1" | awk '{print $2, $1}')"

        die_if_load_installed_log_failed "$1" "$ABI"
        __show_installed_log "$1" "$ABI"
    fi
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

__json_available_packages() {
    unset PACKAGE
    unset STR
    unset I
    unset AVAILABLE_PACKAGES
    unset AVAILABLE_PACKAGES_LENGTH

    AVAILABLE_PACKAGES=$(__list_available_packages)
    AVAILABLE_PACKAGES_LENGTH=$(list_length $AVAILABLE_PACKAGES)

    for item in $AVAILABLE_PACKAGES
    do
        I=$(expr ${I-0} + 1)

        ___load_a_formula "$item"

        if [ "$I" -eq 1 ] ; then
            echo "["
        fi

        if [ "$I" -eq "$AVAILABLE_PACKAGES_LENGTH" ] ; then
            printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"}]\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
        else
            printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"},\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
        fi
    done
}

install_installed_log() {
    echo "-- Installing: $PACKAGE_LOG_DIR/installed.log.txt"
    cat > "$PACKAGE_LOG_DIR/installed.log.txt" <<EOF
installed_datetime=$TIMESTAMP_UNIX
installed_pkg_name=$PACKAGE_NAME
installed_pkg_vers=$PACKAGE_VERSION
EOF
}

die_if_load_installed_log_failed() {
    die_if_package_is_not_installed "$1"

    INSTALLED_LOG_FILE_PATH="$MY_CACHED_LOG_DIR/$1/installed.log.txt"

    unset installed_datetime

    unset installed_pkg_name
    unset installed_pkg_vers

    . "$INSTALLED_LOG_FILE_PATH" || die "$INSTALLED_LOG_FILE_PATH is broken."
}

__show_installed_log() {
    echo "installed_datetime : $(format_unix_timestamp $installed_datetime '+%Y/%m/%d %H:%M:%S')"
    echo "installed_pkg_vers : $installed_pkg_vers"
}

# run in a subshell
configure() {
    if run "$SOURCE_DIR"/configure \
        --prefix="$PACKAGE_INSTALL_DIR" \
        --disable-option-checking \
        --enable-rpath \
        --disable-debug \
        --disable-nls\
        --enable-largefile \
        --enable-static \
        --enable-shared \
        CC="\"$CC\"" \
        CFLAGS="\"$CFLAGS\"" \
        CXX="\"$CXX\"" \
        CXXFLAGS="\"$CXXFLAGS\"" \
        CPP="\"$CPP\"" \
        CPPFLAGS="\"$CPPFLAGS\"" \
        LDFLAGS="\"$LDFLAGS\"" \
        AR="\"$AR\"" \
        RANLIB="\"$RANLIB\"" \
        PKG_CONFIG="\"$PKG_CONFIG\"" \
        PKG_CONFIG_PATH="\"$PKG_CONFIG_PATH\"" \
        PKG_CONFIG_LIBDIR="\"\"" \
        $@ ; then
        echo
    else
        if [ -f "$BUILD_DIR/config.log" ] ; then
            run cat "$BUILD_DIR/config.log"
        elif [ -f "$SOURCE_DIR/config.log" ] ; then
            run cat "$SOURCE_DIR/config.log"
        fi
        return 1
    fi

    if [ "$VERBOSE" = 'true' ] ; then
        for Makefile in $(find "$SOURCE_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi

    makew clean &&
    makew       &&
    makew install
}

# make wrapper
makew() {
    if [ "$DEBUG" = 'true' ] ; then
        run "$GMAKE -w -j$NJOBS --debug $*"
    else
        run "$GMAKE -w -j$NJOBS $*"
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
cmakew() {
    run "$CMAKE" \
        -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
        -DCMAKE_VERBOSE_MAKEFILE=ON \
        -DCMAKE_COLOR_MAKEFILE=ON \
        -DCMAKE_INSTALL_PREFIX="$PACKAGE_INSTALL_DIR" \
        -DCMAKE_BUILD_TYPE=Release \
        -DBUILD_SHARED_LIBS=OFF \
        -DBUILD_TESTING=OFF \
        -G "'Unix Makefiles'" \
        -Wno-dev \
        -S "$SOURCE_DIR" \
        -B "$BUILD_DIR" $@ &&
        makew -C "$BUILD_DIR" &&
        makew -C "$BUILD_DIR" install
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
mesonw() {
    run "$MESON" setup \
        --prefix="$PACKAGE_INSTALL_DIR" \
        --buildtype=release \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        $@ "$BUILD_DIR" "$SOURCE_DIR" &&
    {
        if command -v build_configed > /dev/null ; then
            build_configed
        fi
    } &&
    run ninja -C "$BUILD_DIR" &&
    run ninja -C "$BUILD_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}

########################################################################

list_all_installed_libs() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
        cd  "$MY_INSTALL_DIR" || return 1
    else
        return 0
    fi

    for item in *
    do
        if is_package_installed "$item" ; then
            if [ -d "$MY_INSTALL_DIR/$item/libs" ] ; then
                find "$MY_INSTALL_DIR/$item/libs" -name "lib*\.a"
            fi
        fi
    done
}

ldd() {
    die_if_package_is_not_installed "$1"
    [ -z "$3" ] && die "type is not specified."
    [ -z "$4" ] && die "name is not specified."

    READELF="$(echo_path_of_tool_in_the_toolchain readelf)"

    ldd_recursion() {
        die_if_package_is_not_installed "$1"
        [ -z "$3" ] && die "type is not specified."
        [ -z "$4" ] && die "name is not specified."

        FILE_PATH="$MY_INSTALL_DIR/$1/$2/$3/$4"
        [ -f "$FILE_PATH" ] || die "$FILE_PATH not exist."
        echo "$FILE_PATH"

        DLL=$("$READELF" -d "$FILE_PATH" | grep ".so" | sed 's/.*\[\(.*\)\].*/\1/')
        for item in $DLL
        do
            ldd_recursion $(read_ldd_cache $item) $(expr "$5" + 1)
        done
    }

    ldd_recursion "$1" "$2" "$3" "$4" 0
}

list_tools_in_the_toolchain() {
    list cc cxx cpp as ar ranlib ld nm strip size strings objdump objcopy readelf
}

list_flags_used_by_tools_in_the_toolchain() {
    list CFLAGS CXXFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH PKG_CONFIG_LIBDIR
}

echo_path_of_tool_in_the_toolchain() {
    case $1 in
        cc)  command -v cc  || command -v gcc || command -v clang   ;;
        cxx) command -v c++ || command -v g++ || command -v clang++ ;;
        *)   command -v "$1"
    esac
}

parse_arguments() {
    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    unset USER_SPECIFIED_PACKAGE_LIST

    unset DRYRUN
    unset XTRACE
    unset VERBOSE

    unset NPROC
    unset NJOBS

    unset WORKING_DIR
    unset KEEP_WORKING_DIR
    
    shift

    while test -n "$1"
    do
        case "$1" in
            --verbose|-v)
                VERBOSE=true
                ;;
            --xtrace|-x)
                XTRACE=true
                set -x
                ;;
            --dry-run)
                DRYRUN=true
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=true
                ;;
            --jobs=*)
                NJOBS=$(getvalue "$1")
                is_integer "$NJOBS" || die "--jobs=INTEGER argument's value must be a integer."
                ;;
            [a-z]*)
                if [ "$1" = 'all' ] ; then
                    USER_SPECIFIED_PACKAGE_LIST="$(__list_available_packages)"
                else
                    if [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] ; then
                        USER_SPECIFIED_PACKAGE_LIST="$1"
                    else
                        USER_SPECIFIED_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST $1"
                    fi
                fi
                ;;
            *)  die "$1 is a invalid argument."
        esac
        shift
    done

    NPROC=$(nproc)
    if [ -z "$NJOBS" ] ; then
        NJOBS=$NPROC
    fi
}

init() {
    # MY represents this software's
    MY_NAME=zpkg
    MY_VERSION=0.1.0
    MY_HOME_PAGE="https://github.com/leleliu008/zpkg"
    MY_OFFICAL_FORMULA_REPO_URL="https://github.com/leleliu008/zpkg-formula-repository.git"
    MY_UPGRAGE_URL='https://raw.githubusercontent.com/leleliu008/zpkg/master/bin/zpkg'

    if [ -z "$ZPKG_HOME_DIR" ] ; then
        MY_HOME_DIR="$HOME/.$MY_NAME"
    else
        MY_HOME_DIR="$ZPKG_HOME_DIR"
    fi

    MY_FORMULA_REPO_DIR="$MY_HOME_DIR/repos.d"
    MY_INSTALL_DIR="$MY_HOME_DIR/install.d"
    MY_CACHED_DIR="$MY_HOME_DIR/cache.d"
    MY_CACHED_SOURCE_DIR="$MY_CACHED_DIR/source.d"
    MY_CACHED_BINARY_DIR="$MY_CACHED_DIR/binary.d"
    MY_CACHED_BACKUP_DIR="$MY_CACHED_DIR/backup.d"
    MY_CACHED_PATCH__DIR="$MY_CACHED_DIR/patch.d"
    MY_CACHED_LOG_DIR="$MY_CACHED_DIR/log.d"

    if [ ! -e "$MY_HOME_DIR/repos" ] ; then
        install -d "$MY_HOME_DIR"
        echo "offical=$MY_OFFICAL_FORMULA_REPO_URL"  > "$MY_HOME_DIR/repos"
    fi

    if command -v date > /dev/null ; then
        TIMESTAMP_UNIX="$(date +%s)"
    else
        die "command not found: date. please make sure it in PATH."
    fi

    if command -v uname > /dev/null ; then
        NATIVE_OS_KIND=$(os kind)
        NATIVE_OS_TYPE=$(os type)
        NATIVE_OS_NAME=$(os name)
        NATIVE_OS_VERS=$(os vers)
        NATIVE_OS_ARCH=$(os arch)
        NATIVE_OS_LIBC=$(os libc)
    else
        die "command not found: uname. please make sure it in PATH."
    fi
}

help() {
    cat << EOF
$MY_NAME is a lightweight, portable package manager for UNIX.

Usage: $MY_NAME <ACTION> [ARGUMENT...]

ACTION:
    --help    | -h                --show help information.
    --version | -V                --print version of $MY_NAME.

    integrate zsh                 --integrate zsh-completion script.

    ls available                  --list the available packages.
    ls installed                  --list the installed packages.
    ls outdated                   --list the outdated packages.

    is available PACKAGE          --is PACKAGE available?
    is installed PACKAGE          --is PACKAGE installed?
    is outdated  PACKAGE          --is PACKAGE outdated?
    
    search KEYWORD                --search packages.
    
    formula create PACKAGE        --create a new formula.
    formula delete PACKAGE        --delete a exist formula.
    formula rename P1 P2          --rename a exist formula to new name.
    formula view PACKAGE          --view the formula of a package.
    formula edit PACKAGE          --edit the formula of a package.
    formula list                  --list all formulas.
    formula repo [list]           --list formula repos.
    formula repo add  NAME URL    --add a new formula repo.
    formula repo del  NAME        --delete a exist formula repo.

    tree PACKAGE                  --list contents of a installed package directory in a tree-like format.
    pack PACKAGE                  --pack a installed package.
    logs PACKAGE ABI              --print the logs of a installed package.
    info PACKAGE...               --print the information of packages.
    fetch PACKAGE                 --download formula resources of a package to the cache.
    prefix PACKAGE                --show the installation direcotory of a formula or the $MY_NAME home.
    homepage PACKAGE              --visit the homepage of a formula or the $MY_NAME project.

    install   PACKAGE... [--jobs=N -v -x --dry-run]     --install packages.
    reinstall PACKAGE... [--jobs=N -v -x --dry-run]     --reinstall packages.
    upgrade   PACKAGE... [--jobs=N -v -x --dry-run]     --upgrade packages.
    uninstall PACKAGE...          --uninstall packages.
    
    cleanup                       --cleanup the unused cache.
    update                        --update the formula repositories.
    upgrade-self                  --upgrade this software.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    init

    case $1 in
        --help|-h) 
            help
            ;;
        --version|-V)
            echo "$MY_VERSION"
            ;;
        get)
            shift
            package get "$1" "$2"
            ;;
        ls|list)
            shift
            case $1 in
                available) shift; __list_available_packages ;;
                installed) shift; __list_installed_packages ;;
                outdated)  shift; __list__outdated_packages ;;
                *) help 1
            esac
            ;;
        is)
            shift
            case $1 in
                available) shift; is_package_available "$@" ;;
                installed) shift; is_package_installed "$@" ;;
                outdated)  shift; is_package__outdated "$@" ;;
                *) help 1
            esac
            ;;
        search)  shift; __search_packages "$*" ;;
        formula) shift
            case $1 in
                create) shift; __create_a_formula "$@" ;;
                delete) shift; __delete_a_formula "$@" ;;
                rename) shift; __rename_a_formula "$@" ;;
                view)   shift; ____view_a_formula "$@" ;;
                edit)   shift; ____edit_a_formula "$@" ;;
                list)   shift; __list_formulas ;;
                repo)   shift;
                        case $1 in
                            list) shift; ____list_formula_repositories ;;
                            add)  shift; __add_a_formula_repo $@ ;;
                            del)  shift; __del_a_formula_repo $@ ;;
                            *) help 1
                        esac
                        ;;
                   *)   help 1
            esac
            ;;
        update)  __update_formula_repositories ;;
        cleanup) __cleanup ;;

        install)     __install_packages "$@" ;;
        reinstall) __reinstall_packages "$@" ;;
        uninstall) __uninstall_packages "$@" ;;
        upgrade)     __upgrade_packages "$@" ;;

        upgrade-self)__upgrade_self ;;

        integrate)
            shift;
            case $1 in
                zsh) __integrate_zsh_completions ;;
                *)   die "zpkg integrate $1: not support."
            esac
            ;;
        homepage) shift; __show_webpage_of_a_package    "$@" ;;
        depends)  shift; __show_depends_of_a_package    "$@" ;;
        prefix)   shift; __show_prefix_of_a_package     "$@" ;;
        fetch)    shift; ___load_a_formula   "$@" &&
                         __fetch_resources_of_a_package "$@" ;;
        logs)     shift; __show_logs_of_a_package       "$@" ;;
        pack)     shift; __pack_bottle_of_a_package     "$@" ;;
        tree)     shift; __tree_installed_of_a_package  "$@" ;;
        info)     shift; __show_infomation_of_packages  "$@" ;;

        ldd) shift; ldd "$@" ;;
        gen-github-workflows)
            shift; __gen_github_workflows $@ ;;
        *) help 1
    esac
}

unset CURRENT_SCRIPT_FILEPATH
CURRENT_SCRIPT_FILEPATH="$(realpath "$0")"

main "$@"