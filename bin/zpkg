#!/bin/sh


# https://github.com/leleliu008/zpkg


_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;34m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf "%b" "$*"
}

echo() {
    print "$*\n"
}

info() {
    echo "$COLOR_PURPLE==>$COLOR_OFF $COLOR_GREEN$@$COLOR_OFF"
}

success() {
    print "${COLOR_GREEN}[âœ”] $*\n${COLOR_OFF}"
}

warn() {
    print "${COLOR_YELLOW}ðŸ”¥  $*\n${COLOR_OFF}" >&2
}

error() {
    print "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}" >&2
}

die() {
    print "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}" >&2
    exit 1
}

# check if file exists
# $1 FILEPATH
file_exists() {
    [ -n "$1" ] && [ -e "$1" ]
}

# check if command exists in filesystem
# $1 command name or path
command_exists_in_filesystem() {
    case $1 in
        '') return 1 ;;
        */*)
            case $(uname | tr A-Z a-z) in
                cygwin*)
                    case $1 in
                        /cygdrive/*/choco) executable "$1" ;;
                        /cygdrive/*) return 1 ;;
                        *) executable "$1" ;;
                    esac
                    ;;
                *) executable "$1" ;;
            esac
            ;;
        *)  command_exists_in_filesystem $(command -v "$1" || true)
    esac
}

executable() {
    file_exists "$1" && [ -x "$1" ]
}

die_if_file_is_not_exist() {
    file_exists "$1" || die "$1 is not exist."
}

die_if_not_executable() {
    executable "$1" || die "$1 is not executable."
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$@"
    echo
    echo "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

run() {
    info "$*"
    eval "$*"
}

list() {
    for item in $@
    do
        echo "$item"
    done
}

list_length() {
    echo $#
}

shiftn() {
    shift "$1" && shift && echo "$@"
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        unset SED_IN_PLACE_ACTION
        SED_IN_PLACE_ACTION="$1"
        shift
        # contains ' but not contains \'
        if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
            run gsed -i "\"$SED_IN_PLACE_ACTION\"" $@
        else
            run gsed -i "'$SED_IN_PLACE_ACTION'" $@
        fi
    elif command -v sed  > /dev/null ; then
        if sed -i 's/a/b/g' $(mktemp) 2> /dev/null ; then
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i "'$SED_IN_PLACE_ACTION'" $@
            fi
        else
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i '""' "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i '""' "'$SED_IN_PLACE_ACTION'" $@
            fi
        fi
    else
        die "please install sed utility."
    fi
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        echo "$1" | cut -d= -f2
    fi
}

trim() {
    if [ $# -eq 0 ] ; then
        sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    else
        if [ -n "$*" ] ; then
            echo "$*" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
        fi
    fi
}

tolower() {
    if [ $# -eq 0 ] ; then
        if command -v tr > /dev/null ; then
            tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            gawk '{print(tolower($0))}'
        else
            die "please install GNU CoreUtils or awk."
        fi
    else
        if [ -z "$*" ] ; then
            return 0
        fi
        if command -v tr > /dev/null ; then
            echo "$*" | tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            echo "$*" | awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            echo "$*" | gawk '{print(tolower($0))}'
        elif command -v python > /dev/null ; then
            python  -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python3 > /dev/null ; then
            python3 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python2 > /dev/null ; then
            python2 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v perl > /dev/null ; then
            perl -e 'print @ARGV[0],"\n"' "$1"
        elif command -v node > /dev/null ; then
            node -e 'console.log(process.argv[2].toLowerCase())' - "$*"
        else
            die "please install GNU CoreUtils or awk."
        fi
    fi
}

nproc() {
    if command nproc --version > /dev/null 2>&1 ; then
        command nproc
    elif test -f /proc/cpuinfo ; then
        grep -c processor /proc/cpuinfo
    elif command -v sysctl > /dev/null ; then
        sysctl -n machdep.cpu.thread_count
    else
        echo 4
    fi
}

own() {
    if command -v awk > /dev/null ; then
        ls -ld "$1" | awk '{print $3":"$4}'
    else
        ls -ld "$1" | cut -d ' ' -f4,6 | tr ' ' ':'
    fi
}

is_integer () {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

# }}}
##############################################################################
# {{{ md5sum

#examples:
# printf ss | md5sum
# cat FILE  | md5sum
# md5sum < FILE
md5sum() {
    if [ $# -eq 0 ] ; then
        if echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl md5 | rev | cut -d ' ' -f1 | rev
        else
            return 1
        fi
    else
        if command -v openssl > /dev/null ; then
             openssl md5    "$1" | cut -d ' ' -f2
        elif echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum "$1" | cut -d ' ' -f1
        else
            die "please install openssl or GNU CoreUtils."
        fi
    fi
}

# }}}
##############################################################################
# {{{ sha256sum

#examples:
# printf ss | sha256sum
# cat FILE  | sha256sum
# sha256sum < FILE
sha256sum() {
    if [ $# -eq 0 ] ; then
        if echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl sha256 | rev | cut -d ' ' -f1 | rev
        else
            return 1
        fi
    else
        die_if_file_is_not_exist "$1"
        if command -v openssl > /dev/null ; then
             openssl sha256    "$1" | cut -d ' ' -f2
        elif echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum "$1" | cut -d ' ' -f1
        else
            die "please install openssl or GNU CoreUtils."
        fi
    fi
}

# $1 FILEPATH
# $2 expect sha256sum
file_exists_and_sha256sum_matched() {
    die_if_file_is_not_exist "$1"
    if [ -z "$2" ] ; then
        die "please specify expected sha256sum."
    fi

    [ "$(sha256sum $1)" = "$2" ]
}

# $1 FILEPATH
# $2 expect sha256sum
die_if_sha256sum_mismatch() {
    file_exists_and_sha256sum_matched "$1" "$2" || die "sha256sum mismatch.\n    expect : $2\n    actual : $(sha256sum $1)"
}

# }}}
##############################################################################
# {{{ map

# $1 map_name
__map_name_ref() {
    printf "map_%s\n" "$(printf '%s' "$1" | md5sum)"
}

# $1 map_name
# $2 key
__map_key_ref() {
    printf "%s_key_%s\n" "$(__map_name_ref "$1")" "$(printf '%s' "$2" | md5sum)"
}

# $1 map_name
# $2 key
map_contains() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"
    for item in $(eval echo \$$(__map_name_ref "$1"))
    do
        if [ "$item" = "$2" ] ; then
            return 0
        fi
    done
    return 1
}

# $1 map_name
# $2 key
# $3 value
map_set() {
    if ! map_contains "$1" "$2" ; then
        unset __MAP_NAME_REF__
        __MAP_NAME_REF__="$(__map_name_ref "$1")"
        __MAP_NAME_REF_VALUE__="$(eval echo \$$__MAP_NAME_REF__)"
        eval "$__MAP_NAME_REF__=\"$__MAP_NAME_REF_VALUE__ $2\""
    fi
    eval "$(__map_key_ref "$1" "$2")=$3"
}

# $1 map_name
# $2 key
# output: value
map_get() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"
    eval echo "\$$(__map_key_ref "$1" "$2")"
}

# $1 map_name
# $2 key
# output: value
map_remove() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    unset __MAP_KEYS__
    __MAP_KEYS__="$(map_keys "$1")"

    unset $__MAP_NAME_REF__

    for item in $__MAP_KEYS__
    do
        if [ "$item" = "$2" ] ; then
            continue
        else
            eval "$__MAP_NAME_REF__='$(eval echo \$$__MAP_NAME_REF__) $item'"
        fi
    done
    eval "unset $(__map_key_ref "$1" "$2")"
}

# $1 map_name
map_clear() {
    die_if_map_name_is_not_specified "$1"

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    for item in $(eval echo "\$$__MAP_NAME_REF__")
    do
        eval "unset $(__map_key_ref "$1" "$item")"
    done
    eval "unset $__MAP_NAME_REF__"
}

# $1 map_name
# output: key list
map_keys() {
    die_if_map_name_is_not_specified "$1"
    eval echo "\$$(__map_name_ref "$1")"
}

# $1 map_name
# output: key list length
map_size() {
    die_if_map_name_is_not_specified "$1"
    list_length $(map_keys "$1")
}

# $1 map_name
die_if_map_name_is_not_specified() {
    if [ -z "$1" ] ; then
        die "please specify a map name."
    fi
}

# $1 key
die_if_map_key__is_not_specified() {
    if [ -z "$1" ] ; then
        die "please specify a map key."
    fi
}

# }}}
##############################################################################
# {{{ fetch

# fetch <URL> [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    unset FETCH_PIPE_TO_CMD

    if [ -z "$1" ] ; then
        die "fetch() please specify a url."
    else
        FETCH_URL="$1"
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    die "fetch() --output-dir argument's value must not be empty."
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    die "fetch() --output-name argument's value must not be empty."
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    die "fetch() --output-path argument's value must not be empty."
                fi
                ;;
            --pipe=*)
                FETCH_PIPE_TO_CMD=$(getvalue "$1")
                if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                    die "fetch() --pipe=CMD argument's value must not be empty."
                fi
        esac
        shift
    done

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        if [ -z "$FETCH_OUTPUT_DIR" ] && [ -z "$FETCH_OUTPUT_NAME" ] ; then
            FETCH_OUTPUT_PATH='-'
        else
            if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                FETCH_OUTPUT_DIR="$PWD"
            fi
            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi
            FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"
            if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
                run install -d "$FETCH_OUTPUT_DIR"
            fi
        fi
    elif [ "$FETCH_OUTPUT_PATH" = '-' ] ; then
        unset FETCH_OUTPUT_DIR
        unset FETCH_OUTPUT_NAME
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
        if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR"
        fi
    fi

    case $FETCH_URL in
        *.git)
            if [ -d "$FETCH_OUTPUT_PATH" ] ; then
                run cd  "$FETCH_OUTPUT_PATH" || return 1
                if      git rev-parse 2> /dev/null ; then
                    run git pull &&
                    run git submodule update --recursive
                else
                    run cd .. &&
                    run rm -rf "$FETCH_OUTPUT_NAME" &&
                    run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
                fi
            else
                if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
                    run install -d "$FETCH_OUTPUT_DIR" || return 1
                fi
                run cd "$FETCH_OUTPUT_DIR" || return 1
                run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
            fi
            ;;
        *)
            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -f "$FETCH_OUTPUT_PATH" ] ; then
                if [ -n "$FETCH_SHA256" ] ; then
                    if file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                        success "$FETCH_OUTPUT_PATH already have been downloaded."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_PATH"
            fi

            for FETCH_TOOL in curl wget http lynx aria2c axel
            do
                if command_exists_in_filesystem "$FETCH_TOOL" ; then
                    break
                else
                    unset FETCH_TOOL
                fi
            done

            if [ -z "$FETCH_TOOL" ] ; then
                handle_dependency required exe curl
                FETCH_TOOL=curl
            fi

            case $FETCH_TOOL in
                curl)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "curl --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "curl --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                wget)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                http)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                lynx)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'"
                    else
                        run "lynx -source '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                aria2c)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'"
                    else
                        run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                axel)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                *)  die "fetch() unimplementation: $FETCH_TOOL"
                    ;;
            esac

            [ $? -eq 0 ] || return 1

            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -n "$FETCH_SHA256" ] ; then
                die_if_sha256sum_mismatch "$FETCH_OUTPUT_PATH" "$FETCH_SHA256"
            fi
    esac
}

install_ca_certificates_on_netbsd() {
    # https://www.cambus.net/installing-ca-certificates-on-netbsd/
    if [ "$(uname)" = NetBSD ] ; then
        if command -v pkgin > /dev/null ; then
            if [ "$(whoami)" = root ] ; then
                run      pkgin -y install mozilla-rootcerts || return 1
            else
                run sudo pkgin -y install mozilla-rootcerts || return 1
            fi
            run mozilla-rootcerts install
        fi
    fi
}

# }}}
##############################################################################
# {{{ get_china_mirror_url

contains_china_argument() {
    for arg in $@
    do
        case $arg in
            --china) return 0
        esac
    done
    return 1
}

# get_china_mirror_url <ORIGIN_URL> [--china]
get_china_mirror_url() {
    if [ -z "$1" ] ; then
        die "get_china_mirror_url() please specify a url."
    fi

    if contains_china_argument $@ ; then
        case $1 in
            *githubusercontent.com*)
                printf "%s" "$1" | sed 's@githubusercontent.com@githubusercontents.com@'
                ;;
            *github.com*)
                printf "%s" "$1" | sed 's@github.com@github.com.cnpm.org@'
                ;;
        esac
    else
        printf "%s" "$1"
    fi
}

# }}}
##############################################################################
# {{{ __upgrade_self

# __upgrade_self <UPGRAGE_URL> [-x | --china]
__upgrade_self() {
    set -e

    if [ -z "$1" ] ; then
        die "__upgrade_self() please specify a url."
    fi

    for arg in $@
    do
        case $arg in
            -x) set -x ; break
        esac
    done

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f $CURRENT_SCRIPT_FILEPATH)
        else
            handle_dependency required exe realpath
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    info "mktemp -d"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$(get_china_mirror_url $@)" --output-path="$WORKING_DIR/self"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
            run      install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        else
            run sudo install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        fi

        run rm -rf $WORKING_DIR
    }

    trap __upgrade_self_exit EXIT
}

# }}}
##############################################################################
# {{{ __integrate_zsh_completions

# __integrate_zsh_completions <ZSH_COMPLETIONS_SCRIPT_URL> [-x | --china]
__integrate_zsh_completions() {
    set -e

    if [ -z "$1" ] ; then
        die "__integrate_zsh_completions() please specify a url."
    fi

    for arg in $@
    do
        case $arg in
            -x) set -x ; break
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        else
            handle_dependency required exe realpath
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        fi
    fi

    info "mktemp -d"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$(get_china_mirror_url $@)" --output-path="$WORKING_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"
        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf $WORKING_DIR

    echo "\n${COLOR_YELLOW}Note: you need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ os

__get_os_kind_from_uname() {
    case $1 in
        msys*)    printf '%s\n' 'windows' ;;
        mingw32*) printf '%s\n' 'windows' ;;
        mingw64*) printf '%s\n' 'windows' ;;
        cygwin*)  printf '%s\n' 'windows' ;;
        *)        printf '%s\n' "$1"
    esac
}

__get_os_type_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_type_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f1 | tr A-Z a-z ;;
            *)   return 1
        esac
    fi
}

__get_os_version_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_version_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f2 ;;
            *)   return 1
        esac
    fi
}

# https://www.freedesktop.org/software/systemd/man/os-release.html
__get_os_type_from_etc_os_release() {
    if [ -e /etc/os-release ] ; then
        (
            . /etc/os-release || return 1
            if [ -z "$ID" ] ; then
                return 1
            else
                printf '%s\n' "$ID" | tr A-Z a-z
            fi
        )
    else
        return 1
    fi
}

__get_os_version_from_etc_os_release() {
    if [ -f /etc/os-release ] ; then
        (
            . /etc/os-release || return 1
            if [ -z "$VERSION_ID" ] ; then
                printf '%s\n' 'rolling'
            else
                printf '%s\n' "$VERSION_ID"
            fi
        )
    else
        return 1
    fi
}

# https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/lsbrelease.html
__get_os_type_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --id | cut -f2 | tr A-Z a-z
    else
        return 1
    fi
}

__get_os_version_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --release | cut -f2
    else
        return 1
    fi
}

__get_os_type_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_type_from_etc_redhat_release "$(cat /etc/redhat-release)"
        else
            return 1
        fi
    else
        case $1 in
            'Red Hat Enterprise Linux release'*)
                printf '%s\n' rhel
                ;;
            'Fedora release'*)
                printf '%s\n' fedora
                ;;
            'CentOS release'*)
                printf '%s\n' centos
                ;;
            'CentOS Linux release'*)
                printf '%s\n' centos
                ;;
            *)  printf '%s\n' "$1" | cut -d ' ' -f1 | tr A-Z a-z
        esac
    fi
}

__get_os_version_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_version_from_etc_redhat_release $(cat /etc/redhat-release)
        else
            return 1
        fi
    else
        while [ -n "$1" ]
        do
            case $1 in
                [1-9]*) printf '%s\n' "$1"; return 0
            esac
            shift
        done
        return 1
    fi
}

__get_os_version_from_getprop() {
    if command -v getprop > /dev/null ; then
        getprop ro.build.version.release
    else
        return 1
    fi
}

__get_os_arch_from_uname() {
    if command -v uname > /dev/null ; then
        uname -m 2> /dev/null
    else
        return 1
    fi
}

__get_os_arch_from_arch() {
    if command -v arch > /dev/null ; then
        arch
    else
        return 1
    fi
}

__get_os_type_from_os_kind() {
    case $1 in
        darwin)  printf '%s\n' macos ;;
        linux)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                printf '%s\n' android
            else
                __get_os_type_from_etc_redhat_release ||
                __get_os_type_from_etc_os_release ||
                __get_os_type_from_lsb_release ||
                __get_os_type_from_uname_a
            fi
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_name_from_os_type() {
    case $1 in
        debian)  printf '%s\n' 'Debian' ;;
        ubuntu)  printf '%s\n' 'Ubuntu' ;;
        linuxmint) printf '%s\n' 'LinuxMint' ;;
        centos)  printf '%s\n' 'CentOS' ;;
        fedora)  printf '%s\n' 'Fedora' ;;
        rhel)    printf '%s\n' 'RHEL' ;;
        opensuse-leap)
                 printf '%s\n' 'openSUSE-Leap' ;;
        gentoo)  printf '%s\n' 'Gentoo' ;;
        manjaro) printf '%s\n' 'Manjaro' ;;
        alpine)  printf '%s\n' 'AlpineLinux' ;;
        arch)    printf '%s\n' 'ArchLinux' ;;
        void)    printf '%s\n' 'VoidLinux' ;;
        freebsd) printf '%s\n' 'FreeBSD' ;;
        netbsd)  printf '%s\n' 'NetBSD' ;;
        openbsd) printf '%s\n' 'OpenBSD' ;;
        macos)   printf '%s\n' 'macOS' ;;
        android) printf '%s\n' 'Android' ;;
        windows)
            systeminfo | grep 'OS Name:' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//'
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_version_from_os_kind() {
    case $1 in
        freebsd) freebsd-version ;;
        openbsd) uname -r ;;
        netbsd)  uname -r ;;
        darwin)  sw_vers -productVersion ;;
        linux)
            __get_os_version_from_etc_redhat_release ||
            __get_os_version_from_etc_os_release ||
            __get_os_version_from_lsb_release ||
            __get_os_version_from_getprop ||
            __get_os_version_from_uname_a
            ;;
        windows)
            systeminfo | grep 'OS Version:' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//' | cut -d ' ' -f1
            ;;
    esac
}

__get_os_sub_system() {
    case $(uname | tr A-Z a-z) in
        msys*)    printf '%s\n' "msys"    ;;
        mingw32*) printf '%s\n' "mingw32" ;;
        mingw64*) printf '%s\n' "mingw64" ;;
        cygwin*)  printf '%s\n' 'cygwin'  ;;
        *)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                if [ -n "$TERMUX_VERSION" ] ; then
                    printf '%s\n' termux
                fi
            fi
    esac
}

__get_os_arch() {
    __get_os_arch_from_uname ||
    __get_os_arch_from_arch
}

__get_os_libc_from_os_kind() {
    case $1 in
        linux)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                printf '%s\n' bionic
                return 0
            fi
            # https://pubs.opengroup.org/onlinepubs/7908799/xcu/getconf.html
            if command -v getconf > /dev/null ; then
                if getconf GNU_LIBC_VERSION > /dev/null 2>&1 ; then
                    printf '%s\n' glibc
                    return 0
                fi
            fi
            if command -v ldd > /dev/null ; then
                if ldd --version 2>&1 | head -n 1 | grep -q GLIBC ; then
                    printf '%s\n' glibc
                    return 0
                fi
                if ldd --version 2>&1 | head -n 1 | grep -q musl ; then
                    printf '%s\n' musl
                    return 0
                fi
            fi
            return 1
    esac
}

os() {
    if [ $# -eq 0 ] ; then
        printf "current-machine-os-kind : %s\n" "$(os kind)"
        printf "current-machine-os-type : %s\n" "$(os type)"
        printf "current-machine-os-name : %s\n" "$(os name)"
        printf "current-machine-os-vers : %s\n" "$(os vers)"
        printf "current-machine-os-arch : %s\n" "$(os arch)"
        printf "current-machine-os-libc : %s\n" "$(os libc)"
        printf "current-machine-os-subs : %s\n" "$(os subs)"
    elif [ $# -eq 1 ] ; then
        case $1 in
            -h|--help)
                cat <<'EOF'
os -h | --help
os -V | --version
os kind
os type
os name
os vers
os arch
os libc
os subs
EOF
                ;;
            -V|--version)
                printf "%s\n" '2021.10.01.03'
                ;;
            kind)
                __get_os_kind_from_uname $(uname | tr A-Z a-z)
                ;;
            type)
                __get_os_type_from_os_kind $(os kind)
                ;;
            name)
                __get_os_name_from_os_type $(os type)
                ;;
            vers)
                __get_os_version_from_os_kind $(os kind)
                ;;
            subs)
                __get_os_sub_system
                ;;
            arch)
                __get_os_arch
                ;;
            libc)
                __get_os_libc_from_os_kind $(os kind)
                ;;
            *)  printf '%s\n' "unrecognized argument: $1" >&2; return 1
        esac
    else
        printf '%s\n' "os command only support one argument." >&2; return 1
    fi
}

# }}}
##############################################################################
# {{{ version

version_of_python_module() {
    unset PIP_COMMAND
    PIP_COMMAND=$(command -v pip3 || command -v pip)
    if [ -z "$PIP_COMMAND" ] ; then
        die "can't found pip command."
    else
        "$PIP_COMMAND" show $1 | grep 'Version:' | cut -d ' ' -f2
    fi
}

# retrive the version of a command from it's name or path
version_of_command() {
    case $(basename "$1") in
        cmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$1"   version | cut -d ' ' -f3 | cut -c3- ;;
         tree) "$1" --version | cut -d ' ' -f2 | cut -c2- ;;
   pkg-config) "$1" --version 2> /dev/null | head -n 1 ;;
       m4|gm4) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
    autopoint) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     automake|aclocal)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      objcopy) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
         flex) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        groff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     help2man) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 sphinx-build) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         file) "$1" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       protoc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
     rst2man|rst2man.py|rst2man-3|rst2man-3.6|rst2man-3.7|rst2man-3.8|rst2man-3.9)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         gzip) "$1" --version 2>&1 | head -n 1 | awk '{print($NF)}' ;;
         lzip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$1" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$1" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2) "$1" --help 2>&1 | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1 ;;
          tar)
            VERSION_MSG=$("$1" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) echo "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) echo "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         cpan) ;;
         find) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         diff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         grep) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$1" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
    python|python2|python3)
               "$1" --version 2>&1 | head -n 1 | cut -d ' ' -f2 ;;
         pip)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         pip3) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         node) "$1" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
       base64) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
            *) "$1" --version 2> /dev/null | head -n 1
    esac
}

# retrive the major part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_major_of_command() {
    version_of_command "$1" | cut -d. -f1
}

# retrive the minor part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_minor_of_command() {
    version_of_command "$1" | cut -d. -f2
}

# retrive the major part of the given version
# Note: the given version must have form: major.minor.patch
version_major_of_version() {
    echo "$1" | cut -d. -f1
}

# retrive the minor part of the given version
# Note: the given version must have form: major.minor.patch
version_minor_of_version() {
    echo "$1" | cut -d. -f2
}

version_sort() {
    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html
    # https://man.netbsd.org/NetBSD-8.1/i386/sort.1
    #
    # sort: unrecognized option: V
    # BusyBox v1.29.3 (2019-01-24 07:45:07 UTC) multi-call binary.
    # Usage: sort [-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...
    if  echo | (sort -V > /dev/null 2>&1) ; then
        echo "$@" | tr ' ' '\n' | sort -V
    else
        echo "$@" | tr ' ' '\n' | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4
    fi
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  die "version_compare: $2: not supported operator."
    esac
}

# check if the version of give installed command match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# command_exists_in_filesystem_and_version_matched automake eq 1.16.0
# command_exists_in_filesystem_and_version_matched automake lt 1.16.0
# command_exists_in_filesystem_and_version_matched automake gt 1.16.0
# command_exists_in_filesystem_and_version_matched automake le 1.16.0
# command_exists_in_filesystem_and_version_matched automake ge 1.16.0
# command_exists_in_filesystem_and_version_matched automake
command_exists_in_filesystem_and_version_matched() {
    if command_exists_in_filesystem "$1" ; then
        if [ $# -eq 3 ] ; then
            version_match "$(version_of_command "$1")" "$2" "$3"
        fi
    else
        return 1
    fi
}

# }}}
##############################################################################
# {{{ package_manager

# check if the version of give package match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available_and_version_matched_in_package_manager apt automake eq 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake lt 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake gt 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake le 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake ge 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake
is_package_available_and_version_matched_in_package_manager() {
    if is_package_available_in_package_manager "$1" "$2" ; then
        if [ $# -eq 4 ] ; then
            case $1 in
                apt|apk|yum|dnf) version_match "$(get_package_version_by_package_name_in_package_manager "$1" "$2")" "$3" "$4" ;;
                *)       return 0 ;;
            esac
        fi
    else
        return 1
    fi
}

# check if the given package is in the given package manager's repo
#
# examples:
# is_package_available_in_package_manager apt automake
is_package_available_in_package_manager() {
    case $1 in
        #pkg) pkg show "$2" > /dev/null 2>&1 ;;
        apt) apt show "$2" > /dev/null 2>&1 ;;
        apk) apk info "$2" > /dev/null 2>&1 ;;
        yum) yum info "$2" > /dev/null 2>&1 ;;
        dnf) dnf info "$2" > /dev/null 2>&1 ;;
    esac
}

# get the version of the given package in the given package manager's repo
#
# examples:
# get_package_version_by_package_name_in_package_manager apt automake
get_package_version_by_package_name_in_package_manager() {
    case $1 in
        pkg) pkg show "$2" 2> /dev/null | grep 'Version: '      | head -n 1 | cut -d ' ' -f2 | cut -d- -f1 ;;
        apt) apt show "$2" 2> /dev/null | grep 'Version: '      | head -n 1 | cut -d ' ' -f2 | cut -d- -f1 ;;
        apk) apk info "$2" 2> /dev/null | head -n 1 | cut -d ' ' -f1 | cut -d- -f2 ;;
        yum) yum info "$2" 2> /dev/null | grep 'Version     :'  | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
        dnf) dnf info "$2" 2> /dev/null | grep 'Version      :' | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
    esac
}

# }}}
##############################################################################
# {{{ get_package_name_by_command_name_in_package_manager_XX

# https://cygwin.com/packages/package_list.html
get_package_name_by_command_name_in_package_manager_choco() {
    case $1 in
          go) echo 'golang' ;;
      cc|gcc|c++|g++)
              echo 'gcc-g++';;
       gmake) echo 'make'   ;;
         gm4) echo 'm4'     ;;
        gsed) echo 'gnu-sed';;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    sphinx-build) echo 'python38-sphinx' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_pkg_add() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
    realpath) echo 'coreutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py3-pip' ;;
    libtool|libtoolize|glibtool|glibtoolize)
              echo "libtool" ;;
    autoreconf|autoconf|autoreconf-2.69|autoconf-2.69)
              echo "autoconf-2.69p3" ;;
    automake|autoheader|automake-1.16|autoheader-1.16)
            if [ "$NATIVE_OS_VERS" = '6.9' ] ; then
                echo "automake-1.16.3"
            else
                echo "automake-1.16.2"
            fi
            ;;
    autopoint) echo "gettext" ;;
    pkg-config) echo "pkgconf" ;;
        *) echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_pkgin() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py38-pip'  ;;
    python3)  echo 'python38' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_pkg() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py38-pip' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_emerge() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      xz)     echo 'xz-utils' ;;
      tree)   echo 'app-text/tree' ;;
      rst2man|rst2html)
              echo "docutils" ;;
    sphinx-build)
              echo "sphinx" ;;
    pip3|pip) echo "dev-python/pip" ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

__get_package_name_by_command_name_in_package_manager_pacman() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python-docutils" ;;
    sphinx-build)
              echo "python-sphinx" ;;
    pip3|pip) echo "python-pip" ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

__mingw_w64_i686() {
    if pacman -S -i "mingw-w64-i686-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-i686-$1"
    else
        echo "$1"
    fi
}

__mingw_w64_x86_64() {
    if pacman -S -i "mingw-w64-x86_64-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-x86_64-$1"
    else
        echo "$1"
    fi
}

get_package_name_by_command_name_in_package_manager_pacman() {
    if [ "$1" = 'make' ] || [ "$1" = 'gmake' ] ; then
        echo make
    fi
    case $NATIVE_OS_SUBS in
        mingw32) __mingw_w64_i686   $(__get_package_name_by_command_name_in_package_manager_pacman "$1") ;;
        mingw64) __mingw_w64_x86_64 $(__get_package_name_by_command_name_in_package_manager_pacman "$1") ;;
        *) __get_package_name_by_command_name_in_package_manager_pacman "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_xbps() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip|pip3) echo "python3-pip" ;;
    rst2man|rst2html)
              echo "python3-docutils" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_apk() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py3-pip' ;;
    rst2man|rst2html)
              echo "py3-docutils" ;;
    sphinx-build)
              echo "sphinx"  ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *) echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_zypper() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'gcc-g++';;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-Sphinx" ;;
    pip3|pip) echo "python3-pip" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_dnf() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-sphinx" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_yum() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'gcc-g++';;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    sphinx-build) echo "python-sphinx" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_apt_get() {
    get_package_name_by_command_name_in_package_manager_apt $@
}

get_package_name_by_command_name_in_package_manager_apt() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
        xz)   echo 'xz-utils' ;;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo "python3-pip" ;;
    rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-sphinx" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        ninja)
            if [ "$NATIVE_OS_SUBS" = termux ] ; then
                echo ninja
            else
                echo ninja-build
            fi
            ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_brew() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
     rst2man.py|rst2html.py)
              echo "docutils" ;;
    grpc_cpp_plugin)
                echo "grpc" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    python|python3)
                echo 'python@3.9' ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_pip3() {
    get_package_name_by_command_name_in_package_manager_pip $@
}

get_package_name_by_command_name_in_package_manager_pip() {
    case $1 in
        sphinx-build) echo "sphinx"   ;;
        rst2man.py)   echo "docutils" ;;
    esac
}

# }}}
##############################################################################
# {{{ __get_available_package_manager_list

__add_available_package_manager() {
    if command_exists_in_filesystem "$1" ; then
        if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
            AVAILABLE_PACKAGE_MANAGER_LIST="$2"
        else
            AVAILABLE_PACKAGE_MANAGER_LIST="$AVAILABLE_PACKAGE_MANAGER_LIST $2"
        fi
    fi
}

__get_available_package_manager_list() {
    if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
        for pm in brew apt dnf zypper apk xbps-install emerge pacman choco pkg pkgin pkg_add
        do
            case $pm in
                apt)
                    if command_exists_in_filesystem apt && apt show apt > /dev/null 2>&1 ; then
                        __add_available_package_manager apt apt
                    else
                        __add_available_package_manager apt-get apt-get
                    fi
                    ;;
                dnf)
                    if command_exists_in_filesystem dnf ; then
                        __add_available_package_manager dnf dnf
                    else
                        __add_available_package_manager yum yum
                    fi
                    ;;
                xbps-install)
                    __add_available_package_manager xbps-install xbps
                    ;;
                *)  __add_available_package_manager "$pm" "$pm"
            esac
        done
    fi
    echo "$AVAILABLE_PACKAGE_MANAGER_LIST"
}

# }}}
##############################################################################
# {{{ __install_required

# $1 package manager name
# $2 package name
# examples:
# __install_package_via_package_manager apt make ge 3.80
# __install_package_via_package_manager apt make
__install_package_via_package_manager() {
    if [ -z "$2" ] ; then
        return 1
    fi

    is_package_available_and_version_matched_in_package_manager $@ || return 1

    case $1 in
        pip3)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip3 install --user -U "$2" ;;
                *)          run pip3 install        -U "$2"
            esac
            ;;
        pip)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip  install --user -U "$2" ;;
                *)          run pip  install        -U "$2"
            esac
            ;;
        brew)
            if run brew install "$2" ; then
                if [ "$(brew info --json=v2 "$2" | grep keg_only | sed 's/ //g' | cut -d: -f2 | sed 's/,//')" = 'true' ] ; then
                    if [ -d "$(brew --prefix "$2")/bin" ] ; then
                        export PATH="$(brew --prefix "$2")/bin:$PATH"
                    fi
                fi
            else
                return 1
            fi
            ;;
        pkg)     run $sudo pkg install -y "$2" ;;
        pkgin)   run $sudo pkgin -y install "$2" ;;
        pkg_add) run $sudo pkg_add "$2" ;;
        apt)     run $sudo apt     -y install "$2" ;;
        apt-get) run $sudo apt-get -y install "$2" ;;
        dnf)     run $sudo dnf -y install "$2" ;;
        yum)     run $sudo yum -y install "$2" ;;
        zypper)  run $sudo zypper install -y "$2" ;;
        apk)     run $sudo apk add "$2" ;;
        xbps)    run $sudo xbps-install -Sy "$2" ;;
        emerge)  run $sudo emerge "$2" ;;
        pacman)  run $sudo pacman -Syy --noconfirm && run $sudo pacman -S --noconfirm "$2" ;;
        choco)   run choco install -y --source cygwin "$2" ;;
    esac
    echo
}

# $1 package manager name
# $2 command name
# examples:
# __install_command_via_package_manager apt make ge 3.80
# __install_command_via_package_manager apt make
__install_command_via_package_manager() {
    unset __PACKAGE_NAME__
    __PACKAGE_NAME__="$(eval get_package_name_by_command_name_in_package_manager_$(echo "$1" | tr - _) $2)"

    if [ -z "$__PACKAGE_NAME__" ] ; then
        return 1
    fi

    is_package_available_and_version_matched_in_package_manager "$1" "$__PACKAGE_NAME__" $3 $4 || return 1

    print "ðŸ”¥  ${COLOR_GREEN}$(shiftn 1 $@)${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found, I will install it via${COLOR_OFF} ${COLOR_GREEN}$1${COLOR_OFF}\n"

    __install_package_via_package_manager "$1" "$__PACKAGE_NAME__" $3 $4
}

# examples:
# __install_command_via_available_package_manager python3 ge 3.5
# __install_command_via_available_package_manager make
__install_command_via_available_package_manager() {
    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi
 
    if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
        AVAILABLE_PACKAGE_MANAGER_LIST=$(__get_available_package_manager_list)
        if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
            warn "no package manager found."
            return 1
        else
            echo "    Found $(list_length $AVAILABLE_PACKAGE_MANAGER_LIST) package manager : ${COLOR_GREEN}$AVAILABLE_PACKAGE_MANAGER_LIST${COLOR_OFF}"
        fi
    fi
    for pm in $AVAILABLE_PACKAGE_MANAGER_LIST
    do
        if __install_command_via_package_manager "$pm" $@ ; then
            return 0
        fi
    done
    return 1
}

handle_dependency_from_url() {
    case $1 in
        *.zip)
            handle_dependency required exe unzip
            ;;
        *.tar.xz)
            handle_dependency required exe tar
            handle_dependency required exe xz
            ;;
        *.tar.gz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        *.tar.lz)
            handle_dependency required exe tar
            handle_dependency required exe lzip
            ;;
        *.tar.bz2)
            handle_dependency required exe tar
            handle_dependency required exe bzip2
            ;;
        *.tgz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        *.txz)
            handle_dependency required exe tar
            handle_dependency required exe xz
    esac
}

get_suffix_from_filename() {
    case $1 in
        *.zip)     echo '.zip' ;;
        *.tar.xz)  echo '.tar.xz' ;;
        *.tar.gz)  echo '.tar.gz' ;;
        *.tar.lz)  echo '.tar.lz' ;;
        *.tar.bz2) echo '.tar.bz2' ;;
        *.tgz)     echo '.tgz' ;;
        *.txz)     echo '.txz' ;;
    esac
}

# examples:
# pkg-config ge 0.18
# python3    ge 3.5
# make
__install_command_via_fetch_prebuild_binary() {
    unset PREBUILD_BINARY_FETCH_URL
    PREBUILD_BINARY_FETCH_URL=$(__get_prebuild_binary_fetch_url_by_command_name "$1")
    if [ -z "$PREBUILD_BINARY_FETCH_URL" ] ; then
        return 1
    fi

    handle_dependency_from_url "$PREBUILD_BINARY_FETCH_URL"

    print "ðŸ”¥  ${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found, I will install it via${COLOR_OFF} ${COLOR_GREEN}fetch prebuild binary${COLOR_OFF}\n"

    unset PREBUILD_BINARY_FETCH_URL
    PREBUILD_BINARY_FETCH_URL=$(__get_prebuild_binary_fetch_url_by_command_name "$1")

    unset PREBUILD_BINARY_FILENAME_PREFIX
    unset PREBUILD_BINARY_FILENAME_SUFFIX
    unset PREBUILD_BINARY_FILENAME
    unset PREBUILD_BINARY_FILEPATH

    PREBUILD_BINARY_FILENAME=$(basename "$PREBUILD_BINARY_FETCH_URL")
    PREBUILD_BINARY_FILENAME_SUFFIX=$(get_suffix_from_filename "$PREBUILD_BINARY_FILENAME")
    PREBUILD_BINARY_FILENAME_PREFIX=$(basename "$PREBUILD_BINARY_FILENAME" "$PREBUILD_BINARY_FILENAME_SUFFIX")

    if [ -z "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
        PREBUILD_BINARY_INSTALL_PREFIX_DIR='/opt'
    fi

    unset PREBUILD_BINARY_INSTALL_DIR
    PREBUILD_BINARY_INSTALL_DIR="$PREBUILD_BINARY_INSTALL_PREFIX_DIR/$PREBUILD_BINARY_FILENAME_PREFIX"

    PREBUILD_BINARY_FILEPATH="$PREBUILD_BINARY_INSTALL_DIR/$PREBUILD_BINARY_FILENAME"

    if [ -d "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
        if [ -d "$PREBUILD_BINARY_INSTALL_DIR" ] ; then
            if [ -r "$PREBUILD_BINARY_INSTALL_DIR" ] && [ -w "$PREBUILD_BINARY_INSTALL_DIR" ] && [ -x "$PREBUILD_BINARY_INSTALL_DIR" ] ; then
                rm -rf "$PREBUILD_BINARY_INSTALL_DIR" || return 1
                install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            else
                sudo rm -rf "$PREBUILD_BINARY_INSTALL_DIR" || return 1
                sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            fi
        else
            if [ -r "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] && [ -w "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] && [ -x "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
                     install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            else
                sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            fi
        fi
    else
        if [ -r / ] && [ -w / ] && [ -x / ] ; then
                 install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
        else
            sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
        fi
    fi

    fetch "$PREBUILD_BINARY_FETCH_URL" --output-dir="$PREBUILD_BINARY_INSTALL_DIR" --output-name="$PREBUILD_BINARY_FILENAME" || return 1

    case $PREBUILD_BINARY_FILENAME_SUFFIX in
        .zip)
            run unzip  "$PREBUILD_BINARY_FILEPATH" -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1 ;;
        .tar.xz|.tar.gz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz)
            run tar xf "$PREBUILD_BINARY_FILEPATH" -C "$PREBUILD_BINARY_INSTALL_DIR" --strip-components 1 || return 1 ;;
    esac

    if [ -d "$PREBUILD_BINARY_INSTALL_DIR/bin" ] ; then
        export PATH="$PREBUILD_BINARY_INSTALL_DIR/bin:$PATH"
    fi

    case $1 in
        autoconf)
            for xx in $(grep '/root/.zpkg/install.d/autoconf' -rl "$PREBUILD_BINARY_INSTALL_DIR")
            do
                sed_in_place "s|/root/.zpkg/install.d/autoconf|$PREBUILD_BINARY_INSTALL_DIR|" "$xx"
            done
            ;;
    esac
}

# examples:
# __get_prebuild_binary_fetch_url_by_command_name python3 ge 3.5
# __get_prebuild_binary_fetch_url_by_command_name cmake
__get_prebuild_binary_fetch_url_by_command_name() {
    # https://github.com/leleliu008/python-prebuild
    # https://cmake.org/download
{
    cat <<EOF
python    |glibc|linux |x86_64|https://github.com/leleliu008/python-prebuild/releases/download/3.9.5/python-3.9.5-x86_64-linux-glibc.tar.xz
python3   |glibc|linux |x86_64|https://github.com/leleliu008/python-prebuild/releases/download/3.9.5/python-3.9.5-x86_64-linux-glibc.tar.xz
git       |glibc|linux |x86_64|https://github.com/leleliu008/git-prebuild/releases/download/2.30.2/git-2.30.2-x86_64-linux-glibc.tar.xz
autoconf  |glibc|linux |x86_64|https://github.com/leleliu008/autoconf-prebuild/releases/download/2.69/autoconf-2.69-glibc-linux-x86_64.tar.gz
autoreconf|glibc|linux |x86_64|https://github.com/leleliu008/autoconf-prebuild/releases/download/2.69/autoconf-2.69-glibc-linux-x86_64.tar.gz
cmake     |glibc|linux |x86_64|https://github.com/Kitware/CMake/releases/download/v3.20.2/cmake-3.20.2-linux-x86_64.tar.gz
cmake     |     |darwin|      |https://github.com/Kitware/CMake/releases/download/v3.20.2/cmake-3.20.2-macos-universal.tar.gz
EOF
} | while read LINE
    do
        LINE=$(printf '%s' "$LINE" | sed 's/[[:space:]]//g')

        unset __PB_COMMAND__
        unset __PB_OS_LIBC__
        unset __PB_OS_KIND__
        unset __PB_OS_ARCH__
        unset __PB_URL__

        __PB_COMMAND__=$(printf '%s' "$LINE" | cut -d '|' -f1)

        if [ "$__PB_COMMAND__" != "$1" ] ; then
            continue
        fi

        __PB_OS_LIBC__=$(printf '%s' "$LINE" | cut -d '|' -f2)

        if [ -n "$__PB_OS_LIBC__" ] && [ "$__PB_OS_LIBC__" != "$NATIVE_OS_LIBC" ] ; then
            continue
        fi

        __PB_OS_KIND__=$(printf '%s' "$LINE" | cut -d '|' -f3)

        if [ "$__PB_OS_KIND__" != "$NATIVE_OS_KIND" ] ; then
            continue
        fi

        __PB_OS_ARCH__=$(printf '%s' "$LINE" | cut -d '|' -f4)

        if [ -n "$__PB_OS_ARCH__" ] && [ "$__PB_OS_ARCH__" != "$NATIVE_OS_ARCH" ] ; then
            continue
        fi

        __PB_URL__=$(printf '%s' "$LINE" | cut -d '|' -f5)

        echo "$__PB_URL__"
    done
}

__install_command_via_run_install_script() {
    case $1 in
        rustup)
            # https://www.rust-lang.org/tools/install
            print "ðŸ”¥  ${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found, I will install it via running shell script.${COLOR_OFF}\n"

            handle_dependency required exe bash:zsh

            fetch 'https://sh.rustup.rs' --pipe="$(command -v bash || command -v zsh || command -v dash || command -v ash || echo sh)"

            export CARGO_HOME=$HOME/.cargo
            export PATH="$CARGO_HOME/bin:$PATH"
            ;;
        nvm)
            # https://github.com/nvm-sh/nvm
            print "ðŸ”¥  ${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found, I will install it via running bash shell script.${COLOR_OFF}\n"

            handle_dependency required exe bash:zsh

	        fetch "$(github_user_content_base_url)/nvm-sh/nvm/master/install.sh" --pipe="$(command -v bash || command -v zsh || echo bash)"

	        export NVM_DIR="${HOME}/.nvm"
	        . "${HOME}/.nvm/nvm.sh"
            ;;
        *)  return 1
    esac
}

__install_command_via_pip() {
    if [ -z "$(get_package_name_by_command_name_in_package_manager_pip3 "$1")" ] ; then
        return 1
    fi

    handle_dependency required exe pip3:pip

    (
        unset __PIP_COMMAND__
        __PIP_COMMAND__="$(command -v pip3.8)"

        if [ -n "$__PIP_COMMAND__" ] && [ -d '/usr/local/bin' ] ; then
            $sudo ln -sf "$__PIP_COMMAND__" /usr/local/bin/pip3
        fi
    )

    if   command_exists_in_filesystem pip3 ; then
        __install_package_via_package_manager pip3 "$(get_package_name_by_command_name_in_package_manager_pip3 "$1")"
    elif command_exists_in_filesystem pip ; then
        __install_package_via_package_manager pip  "$(get_package_name_by_command_name_in_package_manager_pip "$1")"
    else
        return 1
    fi
}

# examples:
# __install_command python3 ge 3.5
# __install_command make
__install_command() {
    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi

    if __install_command_via_run_install_script $@ ; then
        return 0
    fi

    if __install_command_via_pip $@ ; then
        return 0
    fi

    if __install_command_via_available_package_manager $@ ; then
        return 0
    fi

    if __install_command_via_fetch_prebuild_binary $@ ; then
        return 0
    fi

    print "ðŸ”¥  ${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}command is required, but I found no way to install it.${COLOR_OFF}\n"
    return 1
}

# examples:
# handle_dependency required exe   pkg-config ge 0.18
# handle_dependency required exe   python     ge 3.5
# handle_dependency required py    libxml2    ge 2.19
#
# handle_dependency optional exe   pkg-config ge 0.18
# handle_dependency optional exe   python     ge 3.5
# handle_dependency optional py    libxml2    ge 2.19
handle_dependency() {
    [ "$1" = 'required' ] || return 0

    shift

    case $1 in
        exe)
            shift
            case $1 in
                *:*)
                    for command in $(echo "$1" | tr ':' ' ')
                    do
                        if command_exists_in_filesystem_and_version_matched "$command" $2 $3 ; then
                            map_set MAP_REQUIRED_DEPENDENCIES "$1" "$command"
                            return 0
                        fi
                    done
                    for command in $(echo "$1" | tr ':' ' ')
                    do
                        if __install_command "$command" $2 $3 ; then
                            map_set MAP_REQUIRED_DEPENDENCIES "$1" "$command"
                            return 0
                        fi
                    done
                    return 1
                    ;;
                *)  __install_command $@
            esac
            ;;
        py)
            shift
            python_module install "$1"
            ;;
        pm)
            shift
            perl_module install "$1"
            ;;
        *) die "handle_dependency() unrecognized argument:$1"
    esac
}

__handle_required_dependencies() {
    step "handle required dependencies"

    for dependency in $REQUIRED_DEPENDENCY_LIST
    do
        handle_dependency $(__decode_dependency "$dependency") || return 1
    done
}

# }}}
##############################################################################
# {{{ __printf_dependencies

# examples:
# __printf_dependency required exe   pkg-config ge 0.18
# __printf_dependency required exe   python     ge 3.5
# __printf_dependency required py    libxml2    ge 2.19
#
# __printf_dependency optional exe   pkg-config ge 0.18
# __printf_dependency optional exe   python     ge 3.5
# __printf_dependency optional py    libxml2    ge 2.19
__printf_dependency() {
    printf "%-10s %-15s %-2s %-10s %-10s %s\n" "$1" "$2" "$3" "$4" "$5" "$6"
}

# examples:
# printf_dependency required exe   pkg-config ge 0.18
# printf_dependency required exe   python     ge 3.5
# printf_dependency required py    libxml2    ge 2.19
#
# printf_dependency optional exe   pkg-config ge 0.18
# printf_dependency optional exe   python     ge 3.5
# printf_dependency optional py    libxml2    ge 2.19
printf_dependency() {
    case $2 in
        exe)
            case $3 in
                *:*)
                    if [ "$1" = 'required' ] ; then
                        REQUIRED_ITEM="$(map_get MAP_REQUIRED_DEPENDENCIES "$3")"
                        __printf_dependency "$2" "$REQUIRED_ITEM" "$4" "$5" "$(version_of_command $REQUIRED_ITEM)" "$(command -v $REQUIRED_ITEM)"
                    else
                        for item in $(echo "$3" | tr ':' ' ')
                        do
                            __printf_dependency "$2" "$item" "$4" "$5" "$(version_of_command $item)" "$(command -v $item)"
                        done
                    fi
                    ;;
                *)  __printf_dependency "$2" "$3" "$4" "$5" "$(version_of_command $3)" "$(command -v $3)"
            esac
            ;;
        py)
            __printf_dependency "$2" "$3" "$4" "$5" "$(python_module get version "$item")" "$(python_module get location "$item")"
            ;;
        pm)
            __printf_dependency "$2" "$3" "$4" "$5" "$(perl_module get version "$item")" "$(perl_module get location "$item")"
            ;;
        *)  die "printf_dependency() unrecognized argument: $2"
    esac
}

__printf_required_dependencies() {
    step "printf required dependencies"
    if [ -z "$REQUIRED_DEPENDENCY_LIST" ] ; then
        warn "no required dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $REQUIRED_DEPENDENCY_LIST
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

__printf_optional_dependencies() {
    step "printf optional dependencies"
    if [ -z "$OPTIONAL_DEPENDENCY_LIST" ] ; then
        warn "no optional dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $OPTIONAL_DEPENDENCY_LIST
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

# }}}
##############################################################################
# {{{ python_module

# examples:
# python_module is  installed libxml2
# python_module get version   libxml2
# python_module get location  libxml2
# python_module install       libxml2
python_module() {
    case $1 in
        is)
            [ $# -eq 3 ] || die "[python_module is] command accept 2 arguments."

            handle_dependency required exe python3:python3.9:python3.8:python3.7:python3.6:python3.5:python
            handle_dependency required exe pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || echo python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || echo pip)

            case $2 in
                installed)  "$__PYTHON_COMMAND__" -c "import $3" 2> /dev/null ;;
                *) die "python_module is $2: not support."
            esac
            ;;
        get)
            [ $# -eq 3 ] || die "[python_module get] command accept 2 arguments."

            handle_dependency required exe python3:python3.9:python3.8:python3.7:python3.6:python3.5:python
            handle_dependency required exe pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || echo python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || echo pip)

            case $2 in
                version)  "$__PIP_COMMAND__" show "$3" 2> /dev/null | grep 'Version:'  | cut -d ' ' -f2 ;;
                location) "$__PIP_COMMAND__" show "$3" 2> /dev/null | grep 'Location:' | cut -d ' ' -f2 ;;
                *) die "python_module get $2: not support."
            esac
            ;;
        install)
            if [ -z "$2" ] ; then
                die "please specify a python module name."
            fi
            if ! python_module is installed "$2" ; then
                print "ðŸ”¥  ${COLOR_GREEN}$2${COLOR_OFF} ${COLOR_YELLOW}python module is required, but it is not found, I will install it via${COLOR_OFF} ${COLOR_GREEN}$__PIP_COMMAND__${COLOR_OFF}\n"
                run "$__PIP_COMMAND__" install -U pip  || return 1
                run "$__PIP_COMMAND__" install -U "$2" || return 1
            fi
            ;;
        *)  die "python_module $1: not support."
    esac
}

# }}}
##############################################################################
# {{{ perl_module

# examples:
# perl_module is  installed libxml2
# perl_module get version   libxml2
# perl_module get location  libxml2
# perl_module install       libxml2
perl_module() {
    case $1 in
        is)
            [ $# -eq 4 ] || die "perl_module command accept 4 arguments."
            handle_dependency required exe perl
            case $2 in
                installed)  perl -M"$3" -le 'print "installed"' > /dev/null 2>&1 ;;
                *) die "perl_module is $2: not support."
            esac
            ;;
        get)
            ;;
        install)
            if ! perl_module is installed "$3" ; then
                handle_dependency required exe cpan:cpanm
                if   command_exists_in_filesystem cpan  ; then
                    cpan -i "$3"
                elif command_exists_in_filesystem cpanm ; then
                    cpanm "$3"
                else
                    die "no perl module installer found."
                fi
            fi
            ;;
        *)  die "perl_module $1: not support."
    esac
}

# }}}
##############################################################################
# {{{ encode/decode dependency

__encode_dependency() {
    if [ $# -eq 0 ] ; then
        tr ' ' '|'
    else
        printf "%s" "$*" | tr ' ' '|'
    fi
}

__decode_dependency() {
    if [ $# -eq 0 ] ; then
        tr '|' ' '
    else
        printf "%s" "$*" | tr '|' ' '
    fi
}

# }}}
##############################################################################
# {{{ regist dependency

# regist dependency required|optional exe|lib|dev|py|pm|pip|npm|gem|pub|cargo|go NAME
#
# required this is a required dependency
# optional this is a optional dependency
#
# exe  this dependency is a command
# py   this dependency is a python  module
# py2  this dependency is a python2 module
# py3  this dependency is a python3 module
# pm   this dependency is a perl module
#
# gt VERSION
# ge VERSION
# lt VERSION
# le VERSION
# eq VERSION
# ne VERSION
#
# examples:
# regist_dependency required exe pkg-config ge 0.18
# regist_dependency required exe python     ge 3.5
# regist_dependency required py  libxml2    ge 2.19
#
# regist_dependency optional exe pkg-config ge 0.18
# regist_dependency optional exe python     ge 3.5
# regist_dependency optional py  libxml2    ge 2.19
regist_dependency() {
    case $1 in
        required)
            if [ -z "$REQUIRED_DEPENDENCY_LIST" ] ; then
                REQUIRED_DEPENDENCY_LIST="$(__encode_dependency "$*")"
            else
                REQUIRED_DEPENDENCY_LIST="$REQUIRED_DEPENDENCY_LIST $(__encode_dependency "$*")"
            fi
            ;;
        optional)
            if [ -z "$OPTIONAL_DEPENDENCY_LIST" ] ; then
                OPTIONAL_DEPENDENCY_LIST=$(__encode_dependency "$*")
            else
                OPTIONAL_DEPENDENCY_LIST="$OPTIONAL_DEPENDENCY_LIST $(__encode_dependency "$*")"
            fi
    esac
}

# }}}
##############################################################################
# {{{ define formula syntax

# set package informations
# 
# examples:
# package set|add summary "JPEG image codec that aids compression and decompression"
# package set|add webpage "https://www.libjpeg-turbo.org"
# package set|add src.git "https://github.com/libjpeg-turbo/libjpeg-turbo.git"
# package set|add src.url "https://downloads.sourceforge.net/project/libjpeg-turbo/2.0.6/libjpeg-turbo-2.0.6.tar.gz"
# package set|add src.sum "d74b92ac33b0e3657123ddcf6728788c90dc84dcb6a52013d758af3c4af481bb"
# package set|add license "IJG"
# package set|add dep.cmd "nasm"
# package set|add dep.pkg "libxx"
# package set|add bsystem "cmake"
# package set     binsrcd 'true'
# package set     sourced 'src'
# package set     sdk.api '23'
#
# package get PACKAGE KEY
package() {
    unset __PACKAGE_KEY__

    if [ $# -lt 2 ] ; then
        die "package <set|add|get> <key> [value]..."
    fi
    if [ -z "$2" ] ; then
        die "key can not be empty."
    fi
    case $1 in
        set)
            shift
            __PACKAGE_KEY__="$1"
            shift
            __PACKAGE_KEY__="$(echo "$__PACKAGE_KEY__" | tr - _  | tr . _ | tr a-z A-Z)"
            eval "PACKAGE_$__PACKAGE_KEY__=\"$@\"" || exit 1
            ;;
        get)
            shift
            ___load_formula_of_the_given_package "$1"
            shift
            __PACKAGE_KEY__="$(echo "$1" | tr - _  | tr . _ | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_KEY__ || exit 1
            ;;
        add)
            shift
            __PACKAGE_KEY__="$1"
            shift
            __PACKAGE_KEY__="$(echo "$__PACKAGE_KEY__" | tr - _  | tr . _ | tr a-z A-Z)"
            __PACKAGE_VAL__="$(eval echo \$PACKAGE_$__PACKAGE_KEY__)"
            eval "PACKAGE_$__PACKAGE_KEY__=\"$__PACKAGE_VAL__ $@\"" || exit 1
            ;;
        '') die "operation can not be empty." ;;
        *)  die "$1: operation not support "
    esac
}

__parse_require_command_item() {
    case $1 in
        *\<=*) echo "required exe $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required exe $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required exe $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required exe $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required exe $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required exe $1"
    esac
}

__parse_require_python_module_item() {
    case $1 in
        *\<=*) echo "required py $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required py $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required py $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required py $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required py $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required py $1"
    esac
}

__parse_require_perl_module_item() {
    case $1 in
        *\<=*) echo "required pm $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required pm $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required pm $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required pm $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required pm $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required pm $1"
    esac
}

__parse_package_patches() {
    if [ $# -lt 2 ] ; then
        die "the number of arguments of patches command at least 2."
    fi

    if [ $(expr $# % 2) -eq 1 ] ; then
        die "the number of arguments of patches command must be even integer."
    fi

    while [ -n "$1" ]
    do
        case $1 in
            *.diff)    PATCH_CONTENT_TYPE=patch  ; package add dep.cmd patch           ;;
            *.patch)   PATCH_CONTENT_TYPE=patch  ; package add dep.cmd patch           ;;
            *.zip)     PATCH_CONTENT_TYPE=zip    ; package add dep.cmd patch unzip     ;;
            *.tar.xz)  PATCH_CONTENT_TYPE=tar.xz ; package add dep.cmd patch tar xz    ;;
            *.tar.gz)  PATCH_CONTENT_TYPE=tar.gz ; package add dep.cmd patch tar gzip  ;;
            *.tar.lz)  PATCH_CONTENT_TYPE=tar.lz ; package add dep.cmd patch tar lzip  ;;
            *.tar.bz2) PATCH_CONTENT_TYPE=tar.bz2; package add dep.cmd patch tar bzip2 ;;
            *.tgz)     PATCH_CONTENT_TYPE=tar.gz ; package add dep.cmd patch tar gzip  ;;
            *.txz)     PATCH_CONTENT_TYPE=tar.xz ; package add dep.cmd patch tar xz    ;;
            *)  die "unrecognized extension : $1. the supported extensions are .diff .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
        esac

        [ ${#2} -eq 64 ] || die "$2 is not sha256sum. the length of sha256sum must be 64."

        shift 2
    done
}

# }}}
##############################################################################
# {{{ operations of formula

___load_formula_of_the_given_package() {
    die_if_package_is_not_available "$1"

    unset PACKAGE_NAME
    unset PACKAGE_SUMMARY
    unset PACKAGE_WEBPAGE
    unset PACKAGE_SRC_GIT
    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_SUM
    unset PACKAGE_SRC_NAME
    unset PACKAGE_SRC_PATH
    unset PACKAGE_SRC_TYPE
    unset PACKAGE_VERSION
    unset PACKAGE_LICENSE
    unset PACKAGE_PATCHES

    # relative to $WORKING_DIR, which contains build script such as configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, etc.
    unset PACKAGE_SOURCED

    unset PACKAGE_BSYSTEM
    unset PACKAGE_BINSRCD

    unset PACKAGE_BUILD_SYSTEM

    # if build in source dir, otherwise in build dir
    unset PACKAGE_BUILD_IN_SOURCE_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL

    # dependency commands
    unset PACKAGE_DEP_CMD

    # dependency python modules
    unset PACKAGE_DEP_PIP

    # dependency packages
    unset PACKAGE_DEP_PKG

    unset PACKAGE_CDEFINE
    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_FORMULA_FILEPATH

    unset PACKAGE_SDK_API

    unset -f build0
    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_NAME="$1"

    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        die "$1 package's formula is not found."
    fi

    . "$PACKAGE_FORMULA_FILEPATH" || die "$PACKAGE_FORMULA_FILEPATH is broken."

    PACKAGE_BUILD_SYSTEM=$PACKAGE_BSYSTEM
    PACKAGE_BUILD_IN_SOURCE_DIR=$PACKAGE_BINSRCD

    if [ -z "$PACKAGE_SUMMARY" ] ; then
        die "summary must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_WEBPAGE" ] ; then
        PACKAGE_WEBPAGE="$PACKAGE_SRC_GIT"
    fi

    if [ -z "$PACKAGE_WEBPAGE" ] ; then
        die "webpage or src.git must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        PACKAGE_SRC_URL="$PACKAGE_SRC_GIT"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        die "src.url or src.git must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    case $PACKAGE_SRC_URL in
        dir://*)   PACKAGE_SRC_TYPE=dir ;;
        *.git)     PACKAGE_SRC_TYPE=git    ; package add dep.cmd git ;;
        *.zip)     PACKAGE_SRC_TYPE=zip    ; package add dep.cmd curl unzip ;;
        *.tar.xz)  PACKAGE_SRC_TYPE=tar.xz ; package add dep.cmd curl tar xz ;;
        *.tar.gz)  PACKAGE_SRC_TYPE=tar.gz ; package add dep.cmd curl tar gzip ;;
        *.tar.lz)  PACKAGE_SRC_TYPE=tar.lz ; package add dep.cmd curl tar lzip ;;
        *.tar.bz2) PACKAGE_SRC_TYPE=tar.bz2; package add dep.cmd curl tar bzip2 ;;
        *.tgz)     PACKAGE_SRC_TYPE=tar.gz ; package add dep.cmd curl tar gzip ;;
        *.txz)     PACKAGE_SRC_TYPE=tar.xz ; package add dep.cmd curl tar xz ;;
        *.c)       PACKAGE_SRC_TYPE=c      ; package add dep.cmd curl ;;
        *.cc)      PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *.cxx)     PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *.cpp)     PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *)  die "unrecognized extension : $PACKAGE_SRC_URL. the supported extensions are .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    case $PACKAGE_SRC_TYPE in
        dir)
            if command -v cut > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | cut -c7-${#PACKAGE_SRC_URL})
            elif command -v awk > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | awk '{print(substr($0, 7))}')
            else
                PACKAGE_SRC_PATH=$(expr substr "$PACKAGE_SRC_URL" 7 ${#PACKAGE_SRC_URL})
            fi
            [ -d "$PACKAGE_SRC_PATH" ] || die "src.url point to dir is not exist."
            ;;
        git)
            PACKAGE_SRC_NAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_PATH="$MY_SOURCE_DIR/$PACKAGE_SRC_NAME"
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SUM" ] ; then
                die "src.sum is not configed in $PACKAGE_FORMULA_FILEPATH"
            fi
            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr _ - | sed 's|-stable||' | sed 's|-src||' | sed 's|\.src||' | sed 's|\.orig\.|.|' | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.lz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                if [ -z "$PACKAGE_VERSION" ] ; then
                    die "version is not configed in $PACKAGE_FORMULA_FILEPATH"
                else
                    case $PACKAGE_VERSION in
                        v*) if command -v cut > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | cut -c2-${#PACKAGE_VERSION})
                            elif command -v awk > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | awk '{print(substr($0, 2))}')
                            else
                                PACKAGE_VERSION=$(expr substr "$PACKAGE_VERSION" 2 ${#PACKAGE_VERSION})
                            fi
                    esac
                fi
            fi
            PACKAGE_SRC_NAME="$PACKAGE_NAME-$PACKAGE_VERSION.$PACKAGE_SRC_TYPE"
            PACKAGE_SRC_PATH="$MY_SOURCE_DIR/$PACKAGE_SRC_NAME"
    esac

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     package add dep.cmd perl m4 autoconf automake make ;;
            autotools)   package add dep.cmd perl m4 autoconf automake make ;;
            configure)   package add dep.cmd make ;;
            ndk-build)   package add dep.cmd make ;;
            cmake)       package add dep.cmd cmake make  ;;
            cmake-make)  package add dep.cmd cmake make  ;;
            cmake-ninja) package add dep.cmd cmake ninja ;;
            meson)       package add dep.cmd meson ninja ;;
            make)        package add dep.cmd make  ;;
            ninja)       package add dep.cmd ninja ;;
            cargo)       package add dep.cmd rustup cargo ;;
            go)          package add dep.cmd go ;;
        esac
    done

    if [ -n "$PACKAGE_PATCHES" ] ; then
        __parse_package_patches $PACKAGE_PATCHES
    fi

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = 'false' ] ; then
        NJOBS=1
    fi

    if [ "$PACKAGE_BUILD_SYSTEM" = 'go' ] ; then
        PACKAGE_BINSRCD='true'
        PACKAGE_BUILD_IN_SOURCE_DIR='true'
    fi

    package add dep.cmd 'tree'

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        package add dep.cmd 'gsed'
    fi

    package add dep.cmd 'find'
}

____view_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        die "$1 package is not available."
    fi

    [ -z "$2" ] || warn "view action accept only one argument."
    
    if command -v bat > /dev/null ; then
        bat "$PACKAGE_FORMULA_FILEPATH"
    else
        cat "$PACKAGE_FORMULA_FILEPATH"
        echo
        prompt_user_to_install_bat
    fi    
}

____edit_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        die "$1 package is not available."
    fi

    [ -z "$2" ] || warn "edit action accept only one argument."

    if [ -z "$EDITOR" ] ; then
        EDITOR=$(command -v nvim || command -v vim || command -v vi || command -v open) || die "please set EDITOR environment variable."
    fi

    "$EDITOR" "$PACKAGE_FORMULA_FILEPATH"
}

__create_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    unset REPO_NAME
    REPO_NAME=offical

    if [ -e "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh" ] ; then
        die "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh formula already exists."
    fi

    cat > "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh" <<EOF
package set summary "Summary of this package"

package set webpage "https://www.xx.com"

# the source code download url of this package. the value of src_url must end with one of .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz
package set src.url "https://www.xx.com/pkgname-x.y.z.tar.gz"

# the sha256sum of source code. If the value of src_url end with .git, this function is optional, otherwise, this function must be invoked.
package set src.sum "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1"

# the version of this package. If this function is not invoked, it will be calculated from src_url.
#package set version "x.y.z"

# the license of this package.
#package set license "MIT"

# the required commands of this package when installing. If specify multiple values, separate them with spaces.
#package set dep.cmd "a b c"

# the packages are depended by this package. If specify multiple values, separate them with spaces.
#package set dep.pkg "a b c"

prepare() {
    :
    #this function is optional, you can delete it, if don't use it.
}

build() {
    :
    #configure
    #cargow
    #mesonw
    #cmakew
    #makew
}
EOF
    ____edit_formula_of_the_given_package "$1"
}

__delete_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        die "$1 package is not available."
    fi

    run rm "$PACKAGE_FORMULA_FILEPATH"
}

__rename_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"
    die_if_package_is_not_specified "$2"

    unset PACKAGE_FORMULA_REPO
    PACKAGE_FORMULA_REPO="$(__repo_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_REPO" ] ; then
        die "$1 package is not available."
    fi

    unset PACKAGE_FORMULA_FILEPATH_OLD
    unset PACKAGE_FORMULA_FILEPATH_NEW

    PACKAGE_FORMULA_FILEPATH_OLD="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$1.sh"
    PACKAGE_FORMULA_FILEPATH_NEW="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$2.sh"

    if [ -f "$PACKAGE_FORMULA_FILEPATH_NEW" ] ; then
        die "$2 package is already exist."
    fi

    if mv "$PACKAGE_FORMULA_FILEPATH_OLD" "$PACKAGE_FORMULA_FILEPATH_NEW" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi
}

__list_formulas() {
    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -d  "$MY_FORMULA_REPO_DIR/$repo/formula" ] ; then
            ls "$MY_FORMULA_REPO_DIR/$repo/formula"/*.sh
        fi
    done
}

# __add_a_formula_repo NAME URL
__add_a_formula_repo() {
    if [ -z "$1" ] ; then
        die "please specify a repo name."
    fi

    if [ -z "$2" ] ; then
        die "please specify a repo url."
    fi

    case $2 in
        *.git)
            case $2 in
                http://*|https://*|git@*) ;;
                *)  die "$2: not a valid git url."
            esac
            ;;
        *)  die "$2: repo url must end with .git"
    esac

    for repoName in $(____list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            die "$1 formula repo already exists."
        fi
    done

    echo "$1=$2" >> "$MY_HOME_DIR/repos"
}

# __del_a_formula_repo NAME
__del_a_formula_repo() {
    if [ -z "$1" ] ; then
        die "please specify a repo name."
    fi

    if [ "$1" = 'offical' ] ; then
        die "offical formula repo can not be deleted."
    fi

    unset REPO_EXISTS
    for repoName in $(____list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            REPO_EXISTS=true
        fi
    done
    if [ "$REPO_EXISTS" = 'true' ] ; then
        sed_in_place "/^$1=/d" "$MY_HOME_DIR/repos"
    else
        die "$1 formula repo not exists."
    fi
}

__repo_of_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    for repo in $(____list_formula_repositories | cut -d= -f1)
    do
        if [ -e "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh" ] ; then
            echo "$repo"
            return 0
        fi
    done

    return 1
}

__path_of_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -e  "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh" ] ; then
            echo "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh"
            return 0
        fi
    done
}

____list_formula_repositories() {
    if [ -e "$MY_HOME_DIR/repos" ] ; then
        cat "$MY_HOME_DIR/repos"
    else
        install -d "$MY_HOME_DIR"
        echo "offical=$MY_OFFICAL_FORMULA_REPO_URL" | tee "$MY_HOME_DIR/repos"
    fi
}

__update_formula_repositories() {
    set -e

    handle_dependency required exe git

    for repo in $(____list_formula_repositories)
    do
        unset MY_FORMULA_REPO_NAME
        unset MY_FORMULA_REPO_URL_

        MY_FORMULA_REPO_NAME=$(echo "$repo" | cut -d= -f1)
        MY_FORMULA_REPO_URL_=$(echo "$repo" | cut -d= -f2)

        info "=== Updating repository ${COLOR_GREEN}$MY_FORMULA_REPO_NAME${COLOR_OFF}"
        fetch "$MY_FORMULA_REPO_URL_" --output-dir="$MY_FORMULA_REPO_DIR" --output-name="$MY_FORMULA_REPO_NAME"
    done
}

# }}}
##############################################################################

prompt_user_to_install_bat() {
    echo "${COLOR_YELLOW}Note: if you want to have a better experience, I strongly recommend you to install${COLOR_OFF} ${COLOR_GREEN}bat${COLOR_OFF} ${COLOR_YELLOW}on your os. For more details, please visit website${COLOR_OFF} ${COLOR_GREEN}https://github.com/sharkdp/bat${COLOR_OFF}"
}

__fetch_sources_of_the_given_package() {
    # fetch source code if needed
    if [ "$PACKAGE_SRC_TYPE" != 'dir' ] ; then
        fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SUM" --output-path="$PACKAGE_SRC_PATH"
    fi
}

__fetch_patches_of_the_given_package() {
    unset PACKAGE_PATCHES

    # fetch patches if posible
    while [ -n "$1" ]
    do
        fetch "$1" --sha256="$2" --output-dir="$MY_PATCH__DIR/$PACKAGE_NAME" --output-name="$(basename $1)"

        if [ -z "$PACKAGE_PATCHES" ] ; then
            PACKAGE_PATCHES="$FETCH_OUTPUT_PATH"
        else
            PACKAGE_PATCHES="$PACKAGE_PATCHES $FETCH_OUTPUT_PATH"
        fi

        shift 2
    done
}

__fetch_resources_of_the_given_package() {
    __fetch_sources_of_the_given_package &&
    __fetch_patches_of_the_given_package $PACKAGE_PATCHES
}

die_if_package_is_not_specified() {
    [ -n "$1" ] || die "no package is specified."
}

die_if_package_is_not_available() {
    is_package_available "$1" || die "$1 is not available."
}

die_if_package_is_not_installed() {
    is_package_installed "$1" || die "$1 is not installed."
}

# check if the given package is available
# if the version condition is given, check if the condition is matched
#
# condition operator:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available automake eq 1.16.0
# is_package_available automake lt 1.16.0
# is_package_available automake gt 1.16.0
# is_package_available automake le 1.16.0
# is_package_available automake ge 1.16.0
# is_package_available automake
is_package_available() {
    case $# in
        0)  die_if_package_is_not_specified ;;
        1)  [ -n "$(__path_of_formula_of_the_given_package $1)" ] ;;
        3)  ___load_formula_of_the_given_package "$1"
            shift
            version_match $PACKAGE_VERSION $@
            ;;
        *)  die "is available command only accept 1 or 3 argument."
    esac
}

is_package_installed() {
    die_if_package_is_not_specified "$1"

    [ -d "$MY_INSTALL_DIR/$1" ]                    || return 1
    [ -f "$MY_INSTALL_DIR/$1/installed-metadata" ] || return 1
    [ -f "$MY_INSTALL_DIR/$1/installed-files" ]    || return 1
}

is_package__outdated() {
    ___load_formula_of_the_given_package "$1"

    __load_installed_metadata_of_the_given_package "$1"

    version_match "$PACKAGE_VERSION" gt "$INSTALLED_PKG_VERS"
}

__gen_github_workflows() {
    set -e

    unset BREAK
    unset NDEPENDED_PACKAGES
    unset AVAILABLE_PACKAGES
    unset GROUP_SIZE
    unset OUTPUT_DIR
    unset I

    while [ -n "$1" ]
    do
        case $1 in
            --group-size=*)
                GROUP_SIZE=$(getvalue "$1")
                is_integer "$GROUP_SIZE" || die "--group-size=INTEGER"
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                case "$OUTPUT_DIR" in
                    '') die "--output-dir=DIR, DIR must not be empty." ;;
                    /*) ;;
                    \~|\~/) OUTPUT_DIR="${HOME}" ;;
                    \~/*)   OUTPUT_DIR="${HOME}$(printf "$OUTPUT_DIR" | awk '{print(substr($0, 2))}')" ;;
                    .|./)   OUTPUT_DIR="${PWD}" ;;
                    *)      OUTPUT_DIR="${PWD}/$OUTPUT_DIR" ;;
                esac
                [ -d "$OUTPUT_DIR" ] || run install -d "$OUTPUT_DIR"
        esac
        shift
    done

    if [ -z "$GROUP_SIZE" ] ; then
        die "please sepecify --group-size=INTEGER argument."
    fi

    if [ -z "$OUTPUT_DIR" ] ; then
        OUTPUT_DIR="$MY_HOME_DIR/repos.d/offical/.github/workflows"
    fi

    GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH="$MY_HOME_DIR/repos.d/offical/.github/workflows/template"

    if [ ! -f "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" ] ; then
        __update_formula_repositories
    fi

    AVAILABLE_PACKAGES=$(__list_available_packages)

    for x in $AVAILABLE_PACKAGES
    do
        if [ "$x" = 'test' ] ; then
            continue
        fi
        for y in $AVAILABLE_PACKAGES
        do
            if [ "$x" = "$y" ] || [ 'test' = "$y" ] ; then
                continue
            else
                for z in $(get_direct_dependency_package_list_of_the_given_package "$y")
                do
                    if [ "$x" = "$z" ] ; then
                        BREAK=true
                        break 2
                    fi
                done
            fi
        done
        if [ "$BREAK" = 'true' ] ; then
            unset BREAK
        else
            if [ -z "$NDEPENDED_PACKAGES" ] ; then
                NDEPENDED_PACKAGES="$x"
            else
                NDEPENDED_PACKAGES="$NDEPENDED_PACKAGES $x"
            fi
            if [ "$(list_length $NDEPENDED_PACKAGES)" -eq "$GROUP_SIZE" ] ; then
                unset OUTPUT_FILEPATH

                I=$(expr ${I-0} + 1)
                OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
                NDEPENDED_PACKAGES=$(echo "$NDEPENDED_PACKAGES" | tr ' ' ,)

                echo
                run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
                sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
                sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"

                unset NDEPENDED_PACKAGES
            fi
        fi
    done
    if [ -n "$NDEPENDED_PACKAGES" ] ; then
        unset OUTPUT_FILEPATH

        I=$(expr ${I-0} + 1)
        OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
        NDEPENDED_PACKAGES=$(echo "$NDEPENDED_PACKAGES" | tr ' ' ,)

        run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
        sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
        sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"
    fi
}

__list_available_packages() {
    for repo in $(____list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" || return 1
        ls -1 *.sh | sed 's/\.sh//g' || return 1
    done
}

__list_installed_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

__list__outdated_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        echo "$packageName"
    done
}

__tree_the_given_installed_package() {
    die_if_package_is_not_installed "$1"
    handle_dependency required exe tree
    run tree $(shiftn 1 $@) --dirsfirst "$MY_INSTALL_DIR/$1"
}

__uninstall_the_given_packages() {
    shift

    die_if_package_is_not_specified "$1"
    
    for packageName in $@
    do
        __uninstall_the_given_package "$packageName" || return 1
    done
}

__uninstall_the_given_package() {
    die_if_package_is_not_installed "$1"

    run rm -rf "$MY_INSTALL_DIR/$1"
}

__reinstall_the_given_packages() {
    inspect_install_arguments $@

    die_if_package_is_not_specified $USER_SPECIFIED_PACKAGE_LIST

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        __install_the_given_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done
}

__upgrade_packages() {
    inspect_install_arguments $@

    if [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] ; then
        USER_SPECIFIED_PACKAGE_LIST=$(__list__outdated_packages)
    fi

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        __install_the_given_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done

}

__cleanup() {
    [ -d "$MY_SOURCE_DIR" ] || return 0
    for repo in $(____list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" || return 1
        for item in $(ls)
        do
            if [ -f "$item" ] ; then
                case $item in
                    *.sh)
                        ___load_formula_of_the_given_package $(echo "$item" | sed 's/\.sh//g')
                esac
            fi
        done
    done
    success "Done."
}

__search_packages() {
    if [ -z "$1" ] ; then
        die "please specify a keyword."
    fi

    for repo in $(____list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" && ls -1 *.sh | sed 's/\.sh//g' | grep "$*"
    done
}

__show_or_open_homepage_of_the_given_package() {
    unset ACTION
    unset PACKAGE

    while [ -n "$1" ]
    do
        case $1 in
            --open)
                ACTION=open
                ;;
            -*|--*)
                die "unrecognized argument: 41"
                ;;
            *)  if [ -z "$PACKAGE" ] ; then
                    PACKAGE=$1
                else
                    die "too many packages given."
                fi
        esac
        shift
    done

    if [ "$ACTION" = open ] ; then
        __open_homepage_of_the_given_package $PACKAGE
    else
        __show_homepage_of_the_given_package $PACKAGE
    fi
}

__show_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        ___load_formula_of_the_given_package "$1"
    fi

    echo "$PACKAGE_WEBPAGE"
}

__open_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        ___load_formula_of_the_given_package "$1"
    fi
    
    if command -v open > /dev/null ; then
        run "open '$PACKAGE_WEBPAGE'"
    elif command -v termux-open-url > /dev/null ; then
        run "termux-open-url '$PACKAGE_WEBPAGE'"
    else
        warn "I don't konw how to open"
    fi
}

__show_depends_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    __gen_dependency_tree_of_the_given_package "$1"

    if [ -f "$DEPENDENCIES_TXT" ] ; then
        cat "$DEPENDENCIES_TXT"
    elif [ -f "$DEPENDENCIES_PNG" ] ; then
        for item in open feh eog lsix
        do
            if command -v $item > /dev/null && $item "$DEPENDENCIES_PNG" ; then
                return 0
            fi
        done
    elif [ -f "$DEPENDENCIES__GV" ] ; then
        cat "$DEPENDENCIES__GV"
    fi
}

# if $1 is     given, show installed directory of the given package.
# if $1 is not given, show this software's home direcotory.
__show_prefix() {
    if [ -z "$1" ] ; then
        echo "$MY_HOME_DIR"
    else
        die_if_package_is_not_installed "$1"
        echo "$MY_INSTALL_DIR/$1"
    fi
}

__logs_the_given_installed_package() {
    die_if_package_is_not_installed "$1"

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    __logs_the_given_dir() {
        for item in $(ls "$1")
        do
            item="$1/$item"
            if [ -d "$item" ] ; then
                continue
            fi
            if [ "$VIEWER" = 'bat' ] ; then
                case $item in
                    *.png) ;;
                    *.sh|*/installed-metadata)
                        bat -l bash "$item" ;;
                    *)  bat "$item"
                esac
            else
                "$VIEWER" "$item"
            fi
        done
    }

    __logs_the_given_dir "$MY_INSTALL_DIR/$1"
    __logs_the_given_dir "$MY_INSTALL_DIR/$1/$2/share/log"

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

# examples:
# __pack_the_given_installed_package autoconf
# __pack_the_given_installed_package autoconf --type=tar.xz
__pack_the_given_installed_package() {
    set -e

    __load_installed_metadata_of_the_given_package "$1"

    shift

    unset PACKED_FILE_SUFFIX

    for arg in $@
    do
        case $arg in
            --type=*)
                PACKED_FILE_SUFFIX=$(getvalue $arg)
                if [ -z "$PACKED_FILE_SUFFIX" ] ; then
                    die "--type=VALUE : VALUE must not be empty."
                fi
                ;;
            *)  die "unrecognized argument: $arg"
        esac
    done

    if [ -z "$PACKED_FILE_SUFFIX" ] ; then
        if command -v 7za > /dev/null ; then
            PACKED_FILE_SUFFIX=7z
        elif command -v zip > /dev/null ; then
            PACKED_FILE_SUFFIX=zip
        elif command -v tar > /dev/null ; then
            if command -v xz > /dev/null ; then
                PACKED_FILE_SUFFIX=tar.xz
            elif command -v bzip2 > /dev/null ; then
                PACKED_FILE_SUFFIX=tar.bz2
            elif command -v gzip > /dev/null ; then
                PACKED_FILE_SUFFIX=tar.gz
            else
                handle_dependency required exe xz
                PACKED_FILE_SUFFIX=tar.xz
            fi
        else
            handle_dependency required exe zip
            PACKED_FILE_SUFFIX=tar.xz
        fi
    else
        case $PACKED_FILE_SUFFIX in
            7z) handle_dependency required exe 7za ;;
            zip)handle_dependency required exe zip ;;
            tar.gz)
                handle_dependency required exe tar
                handle_dependency required exe gzip
                ;;
            tar.xz)
                handle_dependency required exe tar
                handle_dependency required exe xz
                ;;
            tar.bz2)
                handle_dependency required exe tar 
                handle_dependency required exe bzip2 
                ;;
            *) die "unsupported type: $PACKED_FILE_SUFFIX, the supported types are 7z zip tar.gz tar.xz tar.bz2."
        esac
    fi

    unset PACKED_DIR_NAME
    if [ -z "$NATIVE_OS_LIBC" ] ; then
        PACKED_DIR_NAME="$INSTALLED_PKG_NAME-$INSTALLED_PKG_VERS-$NATIVE_OS_TYPE-$NATIVE_OS_ARCH"
    else
        PACKED_DIR_NAME="$INSTALLED_PKG_NAME-$INSTALLED_PKG_VERS-$NATIVE_OS_LIBC-$NATIVE_OS_TYPE-$NATIVE_OS_ARCH"
    fi

    unset PACKED_FILE_NAME
    PACKED_FILE_NAME="$PACKED_DIR_NAME.$PACKED_FILE_SUFFIX"

    step "create working directory"
    info "mktemp -d"
    WORKING_DIR=$(mktemp -d)

    step "change to working directory"
    run cd $WORKING_DIR

    step "make link refer to installed package root dir"
    run ln -s "$MY_INSTALL_DIR/$INSTALLED_PKG_NAME" "$PACKED_DIR_NAME"

    step "packing"
    case $PACKED_FILE_SUFFIX in
        7z)  run 7za a -t7z -r "$PACKED_FILE_NAME" "$PACKED_DIR_NAME" ;;
        zip) run zip -9 -r     "$PACKED_FILE_NAME" "$PACKED_DIR_NAME" ;;
        tar.gz)  run tar zvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        tar.xz)  run tar Jvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        tar.bz2) run tar jvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
    esac

    if [ ! -d "$MY_BINARY_DIR" ] ; then
        step "create cached binary dir"
        run install -d "$MY_BINARY_DIR"
    fi

    step "copy packed file to cached binary dir"
    run cp "$PACKED_FILE_NAME" "$MY_BINARY_DIR/"

    step "show disk usage statistics"
    run du -sh "$PACKED_FILE_NAME"

    step "delete working directory"
    run rm -rf $WORKING_DIR
}

get_direct_dependency_package_list_of_the_given_package() {
    grep '^\s*package set dep\.pkg\s*".*"' $(__path_of_formula_of_the_given_package $1) | sed 's/.*package set dep\.pkg.*"\(.*\)"/\1/'
}

# $1 packageName, if packageName is not specified, USER_SPECIFIED_PACKAGE_LIST will be used
# $2=true invoked by myself
__gen_dependency_list_of_the_given_package() {
    if [ "$2" != 'true' ] ; then
        unset I
        unset DEPENDENCY_PACKAGE_LIST
    fi

    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    if [ -z "$1" ] ; then
        DIRECT_DEPENDENCY_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST"
    else
        DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_the_given_package "$1")
    fi

    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        die_if_package_is_not_available "$dependencyPkgName"

        DEPENDENCY_PACKAGE_LIST_TEMP=""

        for item in $DEPENDENCY_PACKAGE_LIST
        do
            if [ "$dependencyPkgName" = "$item" ] ; then
                continue
            else
                DEPENDENCY_PACKAGE_LIST_TEMP="$DEPENDENCY_PACKAGE_LIST_TEMP $item"
            fi
        done

        DEPENDENCY_PACKAGE_LIST="$dependencyPkgName $DEPENDENCY_PACKAGE_LIST_TEMP"

        __gen_dependency_list_of_the_given_package "$dependencyPkgName" true
    done
}

# __gen_dependency_tree_of_the_given_package PKG [OUTPUT-DIR]
__gen_dependency_tree_of_the_given_package() {
    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    DIRECT_DEPENDENCY_PACKAGE_LIST="$(get_direct_dependency_package_list_of_the_given_package "$1")"

    if [ -z "$DIRECT_DEPENDENCY_PACKAGE_LIST" ] ; then
        return 0
    fi

    unset DEPENDENCIES__GV
    unset DEPENDENCIES_PNG
    unset DEPENDENCIES_TXT

    unset DEPENDENCIES_OUTPUT_DIR

    if [ -z "$2" ] ; then
        DEPENDENCIES_OUTPUT_DIR=$(mktemp -d) || return 1
    else
        DEPENDENCIES_OUTPUT_DIR="$2"
    fi

    DEPENDENCIES__GV="$DEPENDENCIES_OUTPUT_DIR/dependencies.gv"
    DEPENDENCIES_PNG="$DEPENDENCIES_OUTPUT_DIR/dependencies.png"
    DEPENDENCIES_TXT="$DEPENDENCIES_OUTPUT_DIR/dependencies.txt"

    printf 'digraph "%s\n" {' "$1" > "$DEPENDENCIES__GV"

    for dependencyPkgName in $1 $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        unset DIRECT_DEPENDENCY_PACKAGE_LIST
        DIRECT_DEPENDENCY_PACKAGE_LIST="$(get_direct_dependency_package_list_of_the_given_package "$dependencyPkgName")"
        if [ -z "$DIRECT_DEPENDENCY_PACKAGE_LIST" ] ; then
            continue
        fi
        printf '"%s" -> { "%s" }\n' "$dependencyPkgName" "$(printf '%s\n' "$DIRECT_DEPENDENCY_PACKAGE_LIST" | sed 's/ /" "/g')" >> "$DEPENDENCIES__GV"
    done

    printf "}\n" >> "$DEPENDENCIES__GV"

    if command -v dot > /dev/null ; then
        run dot -Tpng -o "$DEPENDENCIES_PNG" "$DEPENDENCIES__GV"
    else
        warn "graphviz is not installed. we do not generate png format dependency image."
    fi

    # https://github.com/ggerganov/dot-to-ascii
    curl \
        -o "$DEPENDENCIES_TXT" \
        -s \
        -G \
        --data-urlencode "boxart=1" \
        --data-urlencode "src=$(cat $DEPENDENCIES__GV)" \
        "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php" || true
}

__install_the_given_packages() {
    inspect_install_arguments $@

    die_if_package_is_not_specified $USER_SPECIFIED_PACKAGE_LIST

    __gen_dependency_list_of_the_given_package || return 1

    if [ $(list_length $DEPENDENCY_PACKAGE_LIST) -gt 1 ] ; then
        echo "$COLOR_PURPLE==>$COLOR_OFF to install$COLOR_GREEN $DEPENDENCY_PACKAGE_LIST $COLOR_OFF\n"
    fi

    for INSTALLING_PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        if is_package_installed "$INSTALLING_PACKAGE" ; then
            printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$INSTALLING_PACKAGE"
        else
            PACKAGE_LOG_DIR="$MY_INSTALL_DIR/$INSTALLING_PACKAGE"
            rm -rf     "$PACKAGE_LOG_DIR" || return 1
            install -d "$PACKAGE_LOG_DIR" || return 1
            __install_the_given_package "$INSTALLING_PACKAGE" | tee "$PACKAGE_LOG_DIR/install.log.txt" || die "install $INSTALLING_PACKAGE failed! you can go to $WORKING_DIR to see see."
        fi
    done
}

__install_the_given_package() {
    echo "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}$1${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"

    # brew install meson
    # Error: The current working directory doesn't exist, cannot proceed.
    # beacuse previous package's working direcotory is deleted.
    cd ~ || return 1

    unset STEP_NUM
    unset STEP_MESSAGE

    unset WORKING_DIR
    unset SOURCE_DIR
    unset BUILD_DIR

    unset PACKAGE_INSTALL_DIR
    unset PACKAGE_INCLUDE_DIR
    unset PACKAGE_LIBRARY_DIR
    unset PACKAGE_PKGCONF_DIR
    unset PACKAGE_BINARY__DIR

    step "show current machine os info"
    echo "NATIVE_OS_KIND  = $NATIVE_OS_KIND"
    echo "NATIVE_OS_TYPE  = $NATIVE_OS_TYPE"
    echo "NATIVE_OS_NAME  = $NATIVE_OS_NAME"
    echo "NATIVE_OS_VERS  = $NATIVE_OS_VERS"
    echo "NATIVE_OS_ARCH  = $NATIVE_OS_ARCH"
    echo "NATIVE_OS_LIBC  = $NATIVE_OS_LIBC"
    echo "NATIVE_OS_SUBS  = $NATIVE_OS_SUBS"
    
    if [ -z "$NATIVE_OS_SUBS" ] ; then
        [ "$(whoami)" = root ] || sudo=sudo
    fi
    
    step "show current machine os effective user info"
    id | tr ' ' '\n' | head -n 2

    step "show formula"
    run cat $(__path_of_formula_of_the_given_package $1)

    step "load formula"
    ___load_formula_of_the_given_package "$1"

    step "handle required commands"
    for item in $PACKAGE_DEP_CMD
    do
        handle_dependency $(__parse_require_command_item "$item")
    done

    step "printf required commands"
    __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
    for item in $PACKAGE_DEP_CMD
    do
        printf_dependency $(__parse_require_command_item "$item")
    done
    for item in $PACKAGE_DEP_PIP
    do
        printf_dependency $(__parse_require_python_module_item "$item")
    done

    unset PKG_CONFIG
    unset MESON
    unset CMAKE
    unset GMAKE
    unset NINJA

    PKG_CONFIG=$(command -v pkg-config)
    MESON=$(command -v meson)
    CMAKE=$(command -v cmake)
    GMAKE=$(command -v gmake || command -v make)
    NINJA=$(command -v ninja)

    step "calculate dependencies"
    unset DEPENDENCY_PACKAGE_LIST
    if [ -z "$PACKAGE_DEP_PKG" ] ; then
        warn "no dependencies."
    else
        __gen_dependency_list_of_the_given_package "$1"                         || return 1
        __gen_dependency_tree_of_the_given_package "$1" "$MY_INSTALL_DIR/$1" || return 1
        if [ -f "$DEPENDENCIES_TXT" ] ; then
            cat "$DEPENDENCIES_TXT"
        fi
    fi

    step "fetch resources if needed"
    __fetch_resources_of_the_given_package "$1"

    step "create working directory"
    info "mktemp -d"
    WORKING_DIR=$(mktemp -d) || die "create working directory failed."

    if [ -z "$PACKAGE_SOURCED" ] ; then
        SOURCE_DIR="$WORKING_DIR"
    else
        SOURCE_DIR="$WORKING_DIR/$PACKAGE_SOURCED"
    fi

    BUILD_DIR="$WORKING_DIR/$TIMESTAMP_UNIX"
    mkdir "$BUILD_DIR" || return 1

    step "unpack sources to working directory"
    case $PACKAGE_SRC_URL in
        dir://*|*.git)
            PACKAGE_VERSION=$(cd "$PACKAGE_SRC_PATH" && git log -1 --pretty=format:%h) || return 1
            run cp -r "$PACKAGE_SRC_PATH/." "$WORKING_DIR" || return 1
            ;;
        *.c|*.cc|*.cxx|*.cpp)
            run cp    "$PACKAGE_SRC_PATH"   "$WORKING_DIR" || return 1
            ;;
        *.zip)
            run unzip "$PACKAGE_SRC_PATH" -d "$WORKING_DIR" || return 1
            ;;
        *.tar.xz|*.tar.gz|*.tar.lz|*.tar.bz2|*.tgz|*.txz)
            run tar xf "$PACKAGE_SRC_PATH" -C "$WORKING_DIR" --strip-components 1 || return 1
            ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    step "change to source directory"
    run cd "$SOURCE_DIR" || return 1

    step "list content of source directory"
    run ls -l

    __config_build_variables "$1"
    __printf_build_variables "$1"

    step "do some preparation works"
    if command -v prepare > /dev/null ; then
        run prepare || return 1
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)
                warn "no prepare function defined in formula."
                run NOCONFIGURE=yes ./autogen.sh    || return 1
                ;;
            autotools)
                warn "no prepare function defined in formula."
                run autoreconf -ivf || return 1
                ;;
            *)  warn "no prepare function defined in formula, skipped."
        esac
    fi

    if [ "$DRYRUN" = 'true' ] ; then
        if [ -z "$SHELL" ] ; then
            SHELL=$(command -v zsh || command -v bash || command -v sh)
        fi
        exec "$SHELL" || return 1
    fi

    if [ -d "$PACKAGE_INSTALL_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALL_DIR" || return 1
    fi

    if [ "$PACKAGE_BUILD_IN_SOURCE_DIR" = 'true' ] ; then
        if [ "$PWD" != "$SOURCE_DIR" ] ; then
            run cd "$SOURCE_DIR" || return 1
        fi
    else
        run cd "$BUILD_DIR" || return 1
    fi

    step "building"
    if command -v build > /dev/null ; then
        build || return 1
    else
        {
            case $PACKAGE_BUILD_SYSTEM in
                autogen)   configure ;;
                autotools) configure ;;
                configure) configure ;;
                cmake*)    cmakew ;;
                meson)     mesonw ;;
                ninja)     ninja clean && ninja && ninja install ;;
                make)      makew clean && makew && makew install ;;
                cargo)     run cargo install -vv --path "$SOURCE_DIR" --root="$PACKAGE_INSTALL_DIR" ;;
                go)        run go build -v -trimpath ;;
            esac
        } || return 1
    fi

    [ -d "$PACKAGE_INSTALL_DIR" ] || {
        error "installed nothing."
        return 1
    }

    step "install logs"
    __install_logs "$1" || return 1

    step "record installed metadata"
    __record_installed_metadata_of_the_given_package "$1"

    step "record installed files"
    __record_installed_files_of_the_given_package "$1"


    step "clean working directory."
    if [ "$KEEP_WORKING_DIR" = 'true' ] ; then
        warn "keep  working directory."
    else
        run rm -rf "$WORKING_DIR"
    fi

    step "list installed content."
    __tree_the_given_installed_package "$1"

    echo
    success "$1 have been installed successfully."
}

__config_build_variables() {
    step "config build variables"

    unset CC
    unset CPP
    unset CXX
    unset AS
    unset LD
    unset AR
    unset NM
    unset RANLIB
    unset STRIP
    unset SIZE
    unset READELF
    unset STRINGS
    unset OBJCOPY
    unset OBJDUMP

    unset CFLAGS
    unset CPPFLAGS
    unset LDFLAGS

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_LIBDIR
    unset PKG_CONFIG_PATH

    unset TOOLCHAIN_ROOT_DIR
    unset TOOLCHAIN_BIN__DIR

    unset SYSROOT
    unset MACOSX_DEPLOYMENT_TARGET

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        TOOLCHAIN_ROOT_DIR="$(xcode-select -p)"
        TOOLCHAIN_BIN__DIR="$TOOLCHAIN_ROOT_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin"
        export PATH="$TOOLCHAIN_BIN__DIR:$PATH"

        SYSROOT="$TOOLCHAIN_ROOT_DIR/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
        MACOSX_DEPLOYMENT_TARGET="$(echo "$NATIVE_OS_VERS" | cut -d. -f1).$(echo "$NATIVE_OS_VERS" | cut -d. -f2)"

        CFLAGS="-isysroot $SYSROOT -arch $NATIVE_OS_ARCH -mmacosx-version-min=$MACOSX_DEPLOYMENT_TARGET -Qunused-arguments"
        CPPFLAGS="-isysroot $SYSROOT -Qunused-arguments"
        LDFLAGS="-isysroot $SYSROOT -arch $NATIVE_OS_ARCH -mmacosx-version-min=$MACOSX_DEPLOYMENT_TARGET"
    fi

    for tool in $(list_tools_in_the_toolchain)
    do
        if [ "$tool" = 'cpp' ] ; then
            CPP="$CC -E"
        else
            eval $(echo "$tool" | tr a-z A-Z)=$(echo_path_of_tool_in_the_toolchain "$tool")
        fi
    done

    for item in $PACKAGE_CDEFINE
    do
        CPPFLAGS="$CPPFLAGS -D$item"
    done

    if [ -n "$PACKAGE_CCFLAGS" ] ; then
        CFLAGS="$CFLAGS $PACKAGE_CCFLAGS"
    fi

    if [ -n "$PACKAGE_LDFLAGS" ] ; then
        LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"
    fi

    if [ "$VERBOSE" = 'true' ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi

    for PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        PKG=$(printf "$PACKAGE" | tr '-' '_')

        unset PKG_INSTALL_DIR
        unset PKG_BINARY__DIR
        unset PKG_INCLUDE_DIR
        unset PKG_LIBRARY_DIR
        unset PKG_PKGCONF_DIR

        PKG_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE"
        PKG_BINARY__DIR="$PKG_INSTALL_DIR/bin"
        PKG_INCLUDE_DIR="$PKG_INSTALL_DIR/include"
        PKG_LIBRARY_DIR="$PKG_INSTALL_DIR/lib"
        PKG_PKGCONF_DIR="$PKG_INSTALL_DIR/lib/pkgconfig"

        eval "${PKG}_INSTALL_DIR='$PKG_INSTALL_DIR'"
        eval "${PKG}_BINARY__DIR='$PKG_BINARY__DIR'"
        eval "${PKG}_INCLUDE_DIR='$PKG_INCLUDE_DIR'"
        eval "${PKG}_LIBRARY_DIR='$PKG_LIBRARY_DIR'"

        CPPFLAGS="-I$PKG_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$PKG_LIBRARY_DIR $LDFLAGS"

        if [ -z "$PKG_CONFIG_PATH" ] ; then
            PKG_CONFIG_PATH="$PKG_PKGCONF_DIR"
        else
            PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$PKG_PKGCONF_DIR"
        fi
    done

    if [ "$VERBOSE" = 'true' ] ; then
        CFLAGS="$CFLAGS -v"
    fi

    CXXFLAGS="$CFLAGS"

    if [ -n "$PACKAGE_XXFLAGS" ] ; then
        CXXFLAGS="$CXXFLAGS $PACKAGE_XXFLAGS"
    fi

    PACKAGE_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE_NAME"
    PACKAGE_BINARY__DIR="$PACKAGE_INSTALL_DIR/bin"
    PACKAGE_INCLUDE_DIR="$PACKAGE_INSTALL_DIR/include"
    PACKAGE_LIBRARY_DIR="$PACKAGE_INSTALL_DIR/lib"
    PACKAGE_PKGCONF_DIR="$PACKAGE_INSTALL_DIR/lib/pkgconfig"

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            cargo)
                # eval export CARGO_TARGET_${CARGO_TARGET_XXX}_AR=$AR
                # eval export CARGO_TARGET_${CARGO_TARGET_XXX}_LINKER=$CC

                # # https://libraries.io/cargo/cc
                # export HOST_CC="$CC_FOR_BUILD"
                # export HOST_CFLAGS="$CFLAGS_FOR_BUILD"

                # export HOST_CXX="$CXX_FOR_BUILD"
                # export HOST_CXXFLAGS="$CXXFLAGS_FOR_BUILD"

                # export HOST_AR="$AR_FOR_BUILD"
                ;;
               go)
                # https://golang.org/doc/install/source#environment
                export CGO_ENABLED=1
                export CGO_CFLAGS="$CFLAGS"
                export CGO_CXXFLAGS="$CXXFLAGS"
                export CGO_CPPFLAGS="$CPPFLAGS"
                export CGO_LDFLAGS="$LDFLAGS"

                export GO111MODULE="auto"
                export GOPROXY=https://goproxy.cn
                ;;
        esac
    done

    STATIC_LIBRARY_EXT=.a
    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        SHARED_LIBRARY_EXT=.dylib
    else
        SHARED_LIBRARY_EXT=.so
    fi
}

__printf_build_variables() {
    step "printf build variables"

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export "$TOOL=\"\$$TOOL\""
        printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export "$FLAG=\"\$$FLAG\""
        printf "\n%17s = " "$FLAG"
        FIRST=true
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = 'true' ] ; then
                FIRST=false
                echo "$item"
            else
                echo "                    $item"
            fi
        done
    done

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            cargo)
                echo
                env | grep CARGO
                echo
                echo "    HOST_AR       = $HOST_AR"
                echo "    HOST_CC       = $HOST_CC"
                echo "    HOST_CXX      = $HOST_CXX"
                echo "    HOST_CFLAGS   = $HOST_CFLAGS"
                echo "    HOST_CXXFLAGS = $HOST_CXXFLAGS"
                echo
                echo "  TARGET_AR       = $TARGET_AR"
                echo "  TARGET_CC       = $TARGET_CC"
                echo "  TARGET_CXX      = $TARGET_CXX"
                echo "  TARGET_CFLAGS   = $TARGET_CFLAGS"
                echo "  TARGET_CXXFLAGS = $TARGET_CXXFLAGS"
                ;;
               go)
                echo
                echo "      GO111MODULE = $GO111MODULE"
                echo "      GOPROXY     = $GOPROXY"
                echo
                echo "     CGO_ENABLED  = $CGO_ENABLED"
                echo "     CGO_CFLAGS   = $CGO_CFLAGS"
                echo "     CGO_CXXFLAGS = $CGO_CXXFLAGS"
                echo "     CGO_CPPFLAGS = $CGO_CPPFLAGS"
                echo "     CGO_LDFLAGS  = $CGO_LDFLAGS"
                ;;
        esac
    done

    echo
    echo
    echo " STATIC_LIBRARY_EXT = $STATIC_LIBRARY_EXT"
    echo " SHARED_LIBRARY_EXT = $SHARED_LIBRARY_EXT"
    echo
    echo "     TIMESTAMP_UNIX = $TIMESTAMP_UNIX"
    echo
    echo "        WORKING_DIR = $WORKING_DIR"
    echo "         SOURCE_DIR = $SOURCE_DIR"
    echo "          BUILD_DIR = $BUILD_DIR"
    echo
    echo "PACKAGE_INSTALL_DIR = $PACKAGE_INSTALL_DIR"
    echo "PACKAGE_BINARY__DIR = $PACKAGE_BINARY__DIR"
    echo "PACKAGE_INCLUDE_DIR = $PACKAGE_INCLUDE_DIR"
    echo "PACKAGE_LIBRARY_DIR = $PACKAGE_LIBRARY_DIR"
    echo "PACKAGE_PKGCONF_DIR = $PACKAGE_PKGCONF_DIR"
    echo
    echo "              NPROC = $NPROC"
    echo "              NJOBS = $NJOBS"

    step "list PATH"
    for item in $(echo "$PATH" | tr ' ' '|' | tr ':' ' ')
    do
        echo "$item" | tr '|' ' '
    done

    if [ "$VERBOSE" = 'true' ] ; then
        step "show export variables"
        run export -p
        echo
    fi
}

__install_logs() {
    for item in "$BUILD_DIR" "$SOURCE_DIR"
    do
        for item2 in 'config.log' 'compile_commands.json'
        do
            if [ -f "$item/$item2" ] ; then
                echo "-- Installing: $PACKAGE_LOG_DIR/$item2"
                install -m 644 "$item/$item2" "$PACKAGE_LOG_DIR" || return 1
            fi
        done
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(echo "$1" | cut -d: -f1)
        X2=$(echo "$1" | cut -d: -f2)

        [ "$X1" = "$X2" ] && unset X2

        install -v -d         "$PACKAGE_INCLUDE_DIR/$X2" || return 1
        install -v -m 644 $X1 "$PACKAGE_INCLUDE_DIR/$X2" || return 1

        shift
    done
}

install_libs() {
    install -v -d "$PACKAGE_LIBRARY_DIR" || return 1
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$PACKAGE_LIBRARY_DIR" || return 1 ;;
            *)   install -v -m 755 $item "$PACKAGE_LIBRARY_DIR" || return 1 ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$PACKAGE_PKGCONF_DIR" &&
    install -v -m 644 $@ "$PACKAGE_PKGCONF_DIR"
}

install_bins() {
    install -v -d        "$PACKAGE_BINARY__DIR" &&
    install -v -m 755 $@ "$PACKAGE_BINARY__DIR"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER"
    done
}

install_pc_file() {
    install -v -d "$PACKAGE_PKGCONF_DIR" &&
    cat >         "$PACKAGE_PKGCONF_DIR/$1.pc"
}

__show_infomation_of_all_available_packages() {
    shift

    unset OUTPUT_FORMAT

    while [ -n "$1" ]
    do
        case $1 in
            --json) OUTPUT_FORMAT=json ;;
            *)      die "unrecognized argument: $1"
        esac
        shift
    done

    unset I
    unset PACKAGE_LIST
    unset PACKAGE_LIST_LENGTH

    PACKAGE_LIST=$(__list_available_packages) || return 1
    PACKAGE_LIST_LENGTH=$(list_length $PACKAGE_LIST)

    if [ "$OUTPUT_FORMAT" = 'json' ] ; then
        for PACKAGE in $PACKAGE_LIST
        do
            ___load_formula_of_the_given_package "$PACKAGE"

            I=$(expr ${I-0} + 1)

            if [ "$I" -eq 1 ] ; then
                echo "["
            fi

            if [ "$I" -eq "$PACKAGE_LIST_LENGTH" ] ; then
                printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"}]\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
            else
                printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"},\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
            fi
        done
    else
        for PACKAGE in $PACKAGE_LIST
        do
            I=$(expr ${I-0} + 1)

            if [ "$I" -gt 1 ] ; then
                echo "============================================================"
            fi

            __show_infomation_of_the_given_package "$PACKAGE"
        done
    fi
}

# examples:
# __show_infomation_of_the_given_package curl
# __show_infomation_of_the_given_package curl version
# __show_infomation_of_the_given_package curl webpage
__show_infomation_of_the_given_package() {
    if [ $# -eq 0 ] ; then
        die_if_package_is_not_specified
    fi

    if [ $# -gt 2 ] ; then
        die "too many arguments."
    fi

    if [ $# -eq 2 ] ; then
        case $2 in
            installed-dir)
                die_if_package_is_not_installed "$1"
                echo "$MY_INSTALL_DIR/$1"
                ;;
            installed-metadata)
                die_if_package_is_not_installed "$1"
                cat "$MY_INSTALL_DIR/$1/installed-metadata"
                ;;
            installed-datetime-unix)
                __load_installed_metadata_of_the_given_package "$1"
                echo "$INSTALLED_DATETIME"
                ;;
            installed-datetime-formatted)
                __load_installed_metadata_of_the_given_package "$1"
                format_unix_timestamp "$INSTALLED_DATETIME" '+%Y/%m/%d %H:%M:%S'
                ;;
            installed-pkg-version)
                __load_installed_metadata_of_the_given_package "$1"
                echo "$INSTALLED_PKG_VERS"
                ;;
            *)  package get "$1" "$2"
        esac
        return $?
    fi

    ___load_formula_of_the_given_package "$1"

    echo "name    : $(mark_is_package_installed_or_not $1)"

    if [ -n "$PACKAGE_VERSION" ] ; then
        echo "version : $PACKAGE_VERSION"
    fi

    echo "summary : $PACKAGE_SUMMARY"
    echo "webpage : $PACKAGE_WEBPAGE"

    [ -z "$PACKAGE_DEP_PKG" ] || {
        unset DEPENDENCIES

        for dependencyPkgName in $PACKAGE_DEP_PKG
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES="depends : $(mark_is_package_installed_or_not $dependencyPkgName)"
            else
                DEPENDENCIES="$DEPENDENCIES | $(mark_is_package_installed_or_not $dependencyPkgName)"
            fi
        done

        echo "$DEPENDENCIES"
    }

    echo "src_url : $PACKAGE_SRC_URL"

    case $PACKAGE_SRC_TYPE in
        dir) ;;
        git)
            if [ -d "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
            ;;
        *)
            if [ -f "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
    esac

    is_package_installed "$1" || return 0

    __load_installed_metadata_of_the_given_package "$1"

    echo "installed ${COLOR_PURPLE}==>${COLOR_OFF} $(du -sh "$MY_INSTALL_DIR/$1" | awk '{print $2, $1}')"
    echo "installed pkg version : $INSTALLED_PKG_VERS"
    echo "build with toolchain  : $BUILD_WITH_TOOLCHAIN_NAME $BUILD_WITH_TOOLCHAIN_VERS"
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

__record_installed_files_of_the_given_package() {
    if [ -z "$2" ] ; then
        INSTALLED_FILES_FILEPATH="$MY_INSTALL_DIR/$1/installed-files"
        echo "-- Installing: $INSTALLED_FILES_FILEPATH"

        exec 7> "$INSTALLED_FILES_FILEPATH"

        __record_installed_files_of_the_given_package "$1" "$MY_INSTALL_DIR/$1"

        exec 7>&-

        sed_in_place "s|$MY_INSTALL_DIR/$1/||" "$INSTALLED_FILES_FILEPATH"
    else
        for file in $(ls $2)
        do
            file="$2/$file"
            if [ -d "$file" ] ; then
                __record_installed_files_of_the_given_package "$1" "$file"
            else
                printf '%s %s\n' $(md5sum "$file") "$file" >&7
            fi
        done
    fi
}

__record_installed_metadata_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    INSTALLED_METADATA_FILEPATH="$MY_INSTALL_DIR/$1/installed-metadata"

    echo "-- Installing: $INSTALLED_METADATA_FILEPATH"

    cat > "$INSTALLED_METADATA_FILEPATH" <<EOF
INSTALLED_DATETIME='$TIMESTAMP_UNIX'

INSTALLED_PKG_NAME='$PACKAGE_NAME'
INSTALLED_PKG_VERS='$PACKAGE_VERSION'

BUILD_WITH_TOOLCHAIN_NAME='$TOOLCHAIN_NAME'
BUILD_WITH_TOOLCHAIN_VERS='$TOOLCHAIN_VERSION'
EOF
}

__load_installed_metadata_of_the_given_package() {
    die_if_package_is_not_installed "$1"

    unset INSTALLED_DATETIME
    unset INSTALLED_PKG_NAME
    unset INSTALLED_PKG_VERS

    unset BUILD_WITH_TOOLCHAIN_NAME
    unset BUILD_WITH_TOOLCHAIN_VERS

    INSTALLED_METADATA_FILEPATH="$MY_INSTALL_DIR/$1/installed-metadata"

    . "$INSTALLED_METADATA_FILEPATH" || die "$INSTALLED_METADATA_FILEPATH is broken."
}

# run in a subshell
configure() {
    if run "$SOURCE_DIR"/configure \
        --prefix="$PACKAGE_INSTALL_DIR" \
        --disable-option-checking \
        --enable-rpath \
        --disable-debug \
        --disable-nls\
        --enable-largefile \
        --enable-static \
        --enable-shared \
        CC="\"$CC\"" \
        CFLAGS="\"$CFLAGS\"" \
        CXX="\"$CXX\"" \
        CXXFLAGS="\"$CXXFLAGS\"" \
        CPP="\"$CPP\"" \
        CPPFLAGS="\"$CPPFLAGS\"" \
        LDFLAGS="\"$LDFLAGS\"" \
        AR="\"$AR\"" \
        RANLIB="\"$RANLIB\"" \
        PKG_CONFIG="\"$PKG_CONFIG\"" \
        PKG_CONFIG_PATH="\"$PKG_CONFIG_PATH\"" \
        PKG_CONFIG_LIBDIR="\"\"" \
        $@ ; then
        echo
    else
        if [ -f "$BUILD_DIR/config.log" ] ; then
            run cat "$BUILD_DIR/config.log"
        elif [ -f "$SOURCE_DIR/config.log" ] ; then
            run cat "$SOURCE_DIR/config.log"
        fi
        return 1
    fi

    if [ "$VERBOSE" = 'true' ] ; then
        for Makefile in $(find "$SOURCE_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi

    makew clean &&
    makew       &&
    makew install
}

# make wrapper
makew() {
    if [ "$DEBUG" = 'true' ] ; then
        run "$GMAKE -w -j$NJOBS --debug $*"
    else
        run "$GMAKE -w -j$NJOBS $*"
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
cmakew() {
    run "$CMAKE" \
        -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
        -DCMAKE_VERBOSE_MAKEFILE=ON \
        -DCMAKE_COLOR_MAKEFILE=ON \
        -DCMAKE_INSTALL_PREFIX="$PACKAGE_INSTALL_DIR" \
        -DCMAKE_BUILD_TYPE=Release \
        -DBUILD_SHARED_LIBS=OFF \
        -DBUILD_TESTING=OFF \
        -G "'Unix Makefiles'" \
        -Wno-dev \
        -S "$SOURCE_DIR" \
        -B "$BUILD_DIR" $@ &&
        makew -C "$BUILD_DIR" &&
        makew -C "$BUILD_DIR" install
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
mesonw() {
    run "$MESON" setup \
        --prefix="$PACKAGE_INSTALL_DIR" \
        --buildtype=release \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        $@ "$BUILD_DIR" "$SOURCE_DIR" &&
    {
        if command -v build_configed > /dev/null ; then
            build_configed
        fi
    } &&
    run ninja -C "$BUILD_DIR" &&
    run ninja -C "$BUILD_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}


########################################################################

list_all_installed_libs() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
        cd  "$MY_INSTALL_DIR" || return 1
    else
        return 0
    fi

    for item in *
    do
        if is_package_installed "$item" ; then
            if [ -d "$MY_INSTALL_DIR/$item/libs" ] ; then
                find "$MY_INSTALL_DIR/$item/libs" -name "lib*\.a"
            fi
        fi
    done
}

__ldd() {
    die_if_package_is_not_installed "$1"
    [ -z "$3" ] && die "type is not specified."
    [ -z "$4" ] && die "name is not specified."

    READELF="$(echo_path_of_tool_in_the_toolchain readelf)"

    ldd_recursion() {
        die_if_package_is_not_installed "$1"
        [ -z "$3" ] && die "type is not specified."
        [ -z "$4" ] && die "name is not specified."

        FILE_PATH="$MY_INSTALL_DIR/$1/$2/$3/$4"
        [ -f "$FILE_PATH" ] || die "$FILE_PATH not exist."
        echo "$FILE_PATH"

        DLL=$("$READELF" -d "$FILE_PATH" | grep ".so" | sed 's/.*\[\(.*\)\].*/\1/')
        for item in $DLL
        do
            ldd_recursion $(read_ldd_cache $item) $(expr "$5" + 1)
        done
    }

    ldd_recursion "$1" "$2" "$3" "$4" 0
}

list_tools_in_the_toolchain() {
    list cc cxx cpp as ar ranlib ld nm strip size strings objdump objcopy readelf
}

list_flags_used_by_tools_in_the_toolchain() {
    list CFLAGS CXXFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH PKG_CONFIG_LIBDIR
}

echo_path_of_tool_in_the_toolchain() {
    case $1 in
        cc)  command -v cc  || command -v gcc || command -v clang   ;;
        cxx) command -v c++ || command -v g++ || command -v clang++ ;;
        *)   command -v "$1"
    esac
}

inspect_install_arguments() {
    unset ACTION
    ACTION=$1

    shift

    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    unset USER_SPECIFIED_PACKAGE_LIST

    unset DRYRUN
    unset VERBOSE

    unset NPROC
    unset NJOBS

    unset KEEP_WORKING_DIR

    while [ -n "$1" ]
    do
        case "$1" in
            --verbose|-v)
                VERBOSE=true
                ;;
            --xtrace|-x)
                ;;
            --dry-run)
                DRYRUN=true
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=true
                ;;
            --jobs=*)
                NJOBS=$(getvalue "$1")
                is_integer "$NJOBS" || die "--jobs=INTEGER argument's value must be a integer."
                ;;
            [a-z]*)
                if [ "$1" = 'all' ] ; then
                    USER_SPECIFIED_PACKAGE_LIST="$(__list_available_packages)"
                else
                    if [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] ; then
                        USER_SPECIFIED_PACKAGE_LIST="$1"
                    else
                        USER_SPECIFIED_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST $1"
                    fi
                fi
                ;;
            *)  die "unrecognized argument: $1"
        esac
        shift
    done

    NPROC=$(nproc)
    if [ -z "$NJOBS" ] ; then
        NJOBS=$NPROC
    fi
}

init() {
    # MY represents this software's
    if [ -n "$ZPKG_HOME_DIR" ] && [ -d "$ZPKG_HOME_DIR" ] ; then
        MY_HOME_DIR="$ZPKG_HOME_DIR"
    else
        MY_HOME_DIR="$HOME/.zpkg"
    fi

    MY_ENV_FILEPATH="$MY_HOME_DIR/env"

    if [ -e "$MY_ENV_FILEPATH" ] ; then
        . "$MY_ENV_FILEPATH" || return 1
    fi

    MY_NAME=zpkg
    MY_VERSION=0.1.1
    MY_HOME_PAGE="https://github.com/leleliu008/zpkg"
    MY_OFFICAL_FORMULA_REPO_URL="https://github.com/leleliu008/zpkg-formula-repository.git"
    MY_UPGRAGE_URL='https://raw.githubusercontent.com/leleliu008/zpkg/master/bin/zpkg'

    MY_FORMULA_REPO_DIR="$MY_HOME_DIR/repos.d"
    MY_INSTALL_DIR="$MY_HOME_DIR/install.d"
    MY_SOURCE_DIR="$MY_HOME_DIR/source.d"
    MY_BINARY_DIR="$MY_HOME_DIR/binary.d"
    MY_BACKUP_DIR="$MY_HOME_DIR/backup.d"
    MY_PATCH__DIR="$MY_HOME_DIR/patch.d"

    if [ ! -e "$MY_HOME_DIR/repos" ] ; then
        install -d "$MY_HOME_DIR"
        echo "offical=$MY_OFFICAL_FORMULA_REPO_URL"  > "$MY_HOME_DIR/repos"
    fi

    if command -v date > /dev/null ; then
        TIMESTAMP_UNIX="$(date +%s)"
    else
        die "command not found: date. please make sure it in PATH."
    fi

    if command -v uname > /dev/null ; then
        unset NATIVE_OS_KIND
        unset NATIVE_OS_TYPE
        unset NATIVE_OS_NAME
        unset NATIVE_OS_VERS
        unset NATIVE_OS_ARCH
        unset NATIVE_OS_LIBC
        unset NATIVE_OS_SUBS

        NATIVE_OS_KIND=$(os kind)
        NATIVE_OS_TYPE=$(os type)
        NATIVE_OS_NAME=$(os name)
        NATIVE_OS_VERS=$(os vers)
        NATIVE_OS_ARCH=$(os arch)
        NATIVE_OS_LIBC=$(os libc)
        NATIVE_OS_SUBS=$(os subs)
    else
        die "command not found: uname. please make sure it in PATH."
    fi
}

help() {
    cat << EOF
$_0 is a lightweight, portable package manager for UNIX.

Usage: $_0 <ACTION> [ARGUMENT...]

ACTION:
    --help    | -h                --show help of this command.

    --version | -V                --show version of this command.

    env                           --show current machine os and environment variables.

    integrate zsh [-x | --china]        --download a zsh-completion script file to a approprivate location.

    update                        --update the formula repositories.

    cleanup                       --cleanup the unused cache.

    ls available                  --list the available packages.

    ls installed                  --list the installed packages.

    ls outdated                   --list the outdated packages.

    is available PACKAGE [eq|ne|ge|gt|le|lt VERSION]          --is PACKAGE available?

    is installed PACKAGE          --is PACKAGE installed?

    is outdated  PACKAGE          --is PACKAGE outdated?
    
    search KEYWORD                --search packages.
    
    formula create PACKAGE        --create a new formula.

    formula delete PACKAGE        --delete a exist formula.

    formula rename P1 P2          --rename a exist formula to new name.

    formula view PACKAGE          --view the formula of the given package.

    formula edit PACKAGE          --edit the formula of the given package.

    formula list                  --list all formulas.

    formula repo [list]           --list formula repos.

    formula repo add  NAME URL    --add a new formula repo.

    formula repo del  NAME        --delete a exist formula repo.

    tree PACKAGE [-L N]           --list installed files of the given installed package in a tree-like format.

    pack PACKAGE                  --pack the given installed package.

    logs PACKAGE                 --show logs of the given installed package.

    info PACKAGE [KEY]            --show information of the given package.

    info @all [--json]            --show information of all the available packages.

    fetch PACKAGE                 --download formula resources of the given package to the cache.

    prefix [PACKAGE]              --show the installed direcotory of the given installed package or the home directory of this software.

    homepage [PACKAGE] [--open]   --open homepage of the given package or this project in web browser.

    install   PACKAGE... [--jobs=N -v -x --dry-run]     --install packages.

    reinstall PACKAGE... [--jobs=N -v -x --dry-run]     --reinstall packages.

    upgrade  [PACKAGE]... [--jobs=N -v -x --dry-run]    --upgrade packages.

    upgrade @self  [-x | --china]   --upgrade this software.

    uninstall PACKAGE...          --uninstall packages.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    unset XTRACE

    for arg in $@
    do
        case $arg in
            --xtrace|-x)
                XTRACE=true
                set -x
                break
                ;;
        esac
    done

    init

    case $1 in
        ''|--help|-h) 
            help
            ;;
        --version|-V)
            echo "$MY_VERSION"
            ;;
        env)
            echo "zpkg ($MY_VERSION)  is a lightweight, portable package manager for UNIX."
            echo
            os
            ;;
        ls|list)
            shift
            case $1 in
                available) shift; __list_available_packages ;;
                installed) shift; __list_installed_packages ;;
                outdated)  shift; __list__outdated_packages ;;
                *) help 1
            esac
            ;;
        is)
            shift
            case $1 in
                available) shift; is_package_available $@ ;;
                installed) shift; is_package_installed $@ ;;
                outdated)  shift; is_package__outdated $@ ;;
                *) help 1
            esac
            ;;
        search)
            shift
            __search_packages "$*"
            ;;
        formula)
            shift
            case $1 in
                create) shift; __create_formula_of_the_given_package $@ ;;
                delete) shift; __delete_formula_of_the_given_package $@ ;;
                rename) shift; __rename_formula_of_the_given_package $@ ;;
                view)   shift; ____view_formula_of_the_given_package $@ ;;
                edit)   shift; ____edit_formula_of_the_given_package $@ ;;
                list)   shift; __list_formulas ;;
                repo)   shift;
                        case $1 in
                            list) shift; ____list_formula_repositories ;;
                            add)  shift; __add_a_formula_repo $@ ;;
                            del)  shift; __del_a_formula_repo $@ ;;
                            *) help 1
                        esac
                        ;;
                   *)   help 1
            esac
            ;;
        update)  __update_formula_repositories ;;
        cleanup) __cleanup ;;

          install)   __install_the_given_packages $@ ;;
        reinstall) __reinstall_the_given_packages $@ ;;
        uninstall) __uninstall_the_given_packages $@ ;;
        upgrade)
            shift
            case $1 in
                @self)
                    shift
                    __upgrade_self "$MY_UPGRAGE_URL" $@ ;;
                *)  __upgrade_packages $@ ;;
                esac
            ;;
        integrate)
            shift
            case $1 in
                zsh) __integrate_zsh_completions 'https://raw.githubusercontent.com/leleliu008/zpkg/master/zsh-completion/_zpkg' ;;
                *)   die "zpkg integrate $1: not support."
            esac
            ;;
        homepage) shift; __show_or_open_homepage_of_the_given_package $@ ;;
        depends)  shift; __show_depends_of_the_given_package    $@ ;;
        prefix)   shift; __show_prefix     $@ ;;
        fetch)    shift; ___load_formula_of_the_given_package $@ &&
                         __fetch_resources_of_the_given_package $@ ;;

        logs) shift; __logs_the_given_installed_package $@ ;;
        pack) shift; __pack_the_given_installed_package $@ ;;
        tree) shift; __tree_the_given_installed_package $@ ;;

        info)
            shift
            case $1 in
                @all) __show_infomation_of_all_available_packages $@ ;;
                *)    __show_infomation_of_the_given_package $@ ;;
            esac
            ;;

        ldd)shift; __ldd $@ ;;

        gen-github-workflows)
            shift; __gen_github_workflows $@ ;;

        *) help 1
    esac
}

main $@
