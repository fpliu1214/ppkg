#!/bin/sh


# https://github.com/leleliu008/ppkg


_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;94m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf '%b' "$*"
}

echo() {
    printf '%b\n' "$*"
}

note() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ””  $*${COLOR_OFF}" >&2
}

warn() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ”¥  $*${COLOR_OFF}" >&2
}

success() {
    printf '%b\n' "${COLOR_GREEN}[âœ”] $*${COLOR_OFF}" >&2
}

error() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
}

die() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
    exit 1
}

bppend_to_PATH() {
    case ":${PATH}:" in
        *:"$1":*) ;;
        *) export PATH="$1:$PATH" ;;
    esac
}

# check if file exists
# $1 FILEPATH
file_exists() {
    [ -n "$1" ] && [ -e "$1" ]
}

# check if command exists in filesystem
# $1 command name or path
command_exists_in_filesystem() {
    case $1 in
        '') return 1 ;;
        */*)
            case $(uname | tr A-Z a-z) in
                cygwin*)
                    case $1 in
                        /cygdrive/*/choco) executable "$1" ;;
                        /cygdrive/*) return 1 ;;
                        *) executable "$1" ;;
                    esac
                    ;;
                *) executable "$1" ;;
            esac
            ;;
        *)  command_exists_in_filesystem $(command -v "$1" || true)
    esac
}

executable() {
    file_exists "$1" && [ -x "$1" ]
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$@"
    printf '%s\n'
    printf '%b\n' "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

step2() {
    STEP2_NUM=$(expr ${STEP2_NUM-0} + 1)
    STEP2_MESSAGE="$@"
    printf '%s\n'
    printf '%b\n' "${COLOR_BLUE}>>> STEP ${STEP_NUM}.${STEP2_NUM} : ${STEP2_MESSAGE} ${COLOR_OFF}"
}

run() {
    if [ "$RUN_SILENT" != yes ] ; then
        echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}$@${COLOR_OFF}"
    fi

    eval "$*"
}

list() {
    for item in $@
    do
        printf '%s\n' "$item"
    done
}

list_length() {
    printf '%s\n' $#
}

shiftn() {
    shift "$1" && shift && printf '%s\n' "$@"
}

globing() {
    case $1 in
        '')   ;;
        \~/*) printf '%s\n' "$HOME/$(printf '%s\n' "$1" | cut -c3-)" ;;
        *)    printf '%s\n' "$1"
    esac
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        unset SED_IN_PLACE_ACTION
        SED_IN_PLACE_ACTION="$1"
        shift
        # contains ' but not contains \'
        if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
            run gsed -i "\"$SED_IN_PLACE_ACTION\"" $@
        else
            run gsed -i "'$SED_IN_PLACE_ACTION'" $@
        fi
    elif command -v sed  > /dev/null ; then
        if sed -i 's/a/b/g' $(mktemp) 2> /dev/null ; then
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i "'$SED_IN_PLACE_ACTION'" $@
            fi
        else
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i '""' "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i '""' "'$SED_IN_PLACE_ACTION'" $@
            fi
        fi
    else
        error "please install sed utility."
        return 1
    fi
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        printf '%s\n' "$1" | cut -d= -f2
    fi
}

trim() {
    if [ $# -eq 0 ] ; then
        sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    else
        if [ -n "$*" ] ; then
            printf '%s\n' "$*" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
        fi
    fi
}

tolower() {
    if [ $# -eq 0 ] ; then
        if command -v tr > /dev/null ; then
            tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            gawk '{print(tolower($0))}'
        else
            error "please install GNU CoreUtils or awk."
            return 1
        fi
    else
        if [ -z "$*" ] ; then
            return 0
        fi
        if command -v tr > /dev/null ; then
            printf '%s\n' "$*" | tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            printf '%s\n' "$*" | awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            printf '%s\n' "$*" | gawk '{print(tolower($0))}'
        elif command -v python > /dev/null ; then
            python  -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python3 > /dev/null ; then
            python3 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python2 > /dev/null ; then
            python2 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v perl > /dev/null ; then
            perl -e 'print @ARGV[0],"\n"' "$1"
        elif command -v node > /dev/null ; then
            node -e 'console.log(process.argv[2].toLowerCase())' - "$*"
        else
            error "please install GNU CoreUtils or awk."
            return 1
        fi
    fi
}

git() {
    if [ -f "$MY_HOME_DIR/core/etc/ssl/certs/cacert.pem" ] ; then
        command git -c http.sslCAInfo="$MY_HOME_DIR/core/etc/ssl/certs/cacert.pem" $*
    else
        command git $*
    fi
}

own() {
    ls -ld "$1" | cut -d ' ' -f3,4 | tr ' ' ':'
}

is_integer() {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

is_elf_file() {
    [ -z "$1" ] && {
        error "is_elf_file <FILE-PATH>, <FILE-PATH> is not given."
        return 1
    }

    [ -e "$1" ] || {
        error "is_elf_file <FILE-PATH>, <FILE-PATH> is not exist."
        return 2
    }

    # http://www.sco.com/developers/gabi/latest/ch4.eheader.html

    if command -v hexdump > /dev/null ; then
        [ "$(hexdump -n 4 -v -e '1/1 "%02X" ""' "$1")" = '7F454C46' ]
    else
        [ "$(head -c 4 "$1")" = "$(printf '\177ELF')" ]
    fi
}

# format_unix_timestamp <TIMESTAMP-UNIX> <TO-FORMAT> [-u]
  format_unix_timestamp() {
   date $3 -jf "%s" "$1" "$2" 2> /dev/null ||
   date $3 -d      "@$1" "$2"
}

# https://equa.space/sh/lolcat/
lolcat_awk() {
    awk -v angle=45 -v angle_phase=40 -v reverse=0 -v offset=195 -v offset_phase=0 -v width=100 -v width_phase=8 "$@" '
    function put_rgb(color) {
        printf "\033[%s38;2;%d;%d;%dm", reverse ? "7;" : "", int(color[1] * 255), int(color[2] * 255), int(color[3] * 255);
    }

    function hsv_to_rgb(hsv, rgb, c, h2, x) {
        c = hsv[2] * hsv[3];
        h2 = hsv[1] * 6;
        x = c * (1 - ((h2 % 2) - 1 > 0 ? (h2 % 2) - 1 : 1 - (h2 % 2)));
        if (int(h2) % 6 == 0) {
            rgb[1] = c; rgb[2] = x; rgb[3] = 0;
        } else if (int(h2) % 6 == 1) {
            rgb[1] = x; rgb[2] = c; rgb[3] = 0;
        } else if (int(h2) % 6 == 2) {
            rgb[1] = 0; rgb[2] = c; rgb[3] = x;
        } else if (int(h2) % 6 == 3) {
            rgb[1] = 0; rgb[2] = x; rgb[3] = c;
        } else if (int(h2) % 6 == 4) {
            rgb[1] = x; rgb[2] = 0; rgb[3] = c;
        } else if (int(h2) % 6 == 5) {
            rgb[1] = c; rgb[2] = 0; rgb[3] = x;
        }

        rgb[1] += hsv[2] - c;
        rgb[2] += hsv[2] - c;
        rgb[3] += hsv[2] - c;
    }

    BEGIN {
        srand();
        if (offset == "") offset = rand() * 360;
    }

    {
        y = NR - 1;
        for (x = 0; x < length($0); x++) {
            for (i = 0; i < 3; i++) {
                mult_x = cos((angle + i * angle_phase) / 57.2976);
                mult_y = sin((angle + i * angle_phase) / 57.2976);
                hsv[1] = (((x * mult_x + y * mult_y) / (width + width_phase * i)) % 1 + 1 + (offset + offset_phase * i) / 360) % 1;
                hsv[2] = 0.8;
                hsv[3] = 0.9;

                hsv_to_rgb(hsv, trgb);
                rgb[i + 1] = trgb[i + 1];
            }

            put_rgb(rgb);
            printf("%s", substr($0, x + 1, 1));
        }
        print "\033[0m";
    }
    '
}

# }}}
##############################################################################
# {{{ md5sum

#examples:
# printf ss | md5sum
# cat FILE  | md5sum
# md5sum < FILE
md5sum() {
    if [ $# -eq 0 ] ; then
        if echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl md5 | rev | cut -d ' ' -f1 | rev
        else
            error "md5sum, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    else
        [ -e "$1" ] || {
            error "md5sum <PATH-OF-FILE>, PATH-OF-FILE[$1] is not exist."
            return 1
        }

        if command -v openssl > /dev/null ; then
             openssl md5    "$1" | cut -d ' ' -f2
        elif echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum "$1" | cut -d ' ' -f1
        else
            error "md5sum <PATH-OF-FILE>, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    fi
}

# }}}
##############################################################################
# {{{ sha256sum

#examples:
# printf ss | sha256sum
# cat FILE  | sha256sum
# sha256sum < FILE
sha256sum() {
    if [ $# -eq 0 ] ; then
        if echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl sha256 | rev | cut -d ' ' -f1 | rev
        else
            error "sha256sum, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    else
        [ -e "$1" ] || {
            error "sha256sum <PATH-OF-FILE>, PATH-OF-FILE[$1] is not exist."
            return 1
        }

        if command -v openssl > /dev/null ; then
             openssl sha256    "$1" | cut -d ' ' -f2
        elif echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum "$1" | cut -d ' ' -f1
        else
            error "sha256sum <PATH-OF-FILE>, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    fi
}

# file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>
  file_exists_and_sha256sum_matched() {
    [ -z "$1" ] && {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, <PATH-OF-FILE> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, <EXPECTED-SHA256SUM-OF-FILE> is not given."
        return 1
    }

    [ -e "$1" ] || {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, PATH-OF-FILE[$1] is not exist."
        return 1
    }

    [ "$(sha256sum $1)" = "$2" ]
}

# }}}
##############################################################################
# {{{ map

# 40   map name is not given.
# 41   map key  is not given.

# __map_name_ref <MAP-NAME>
  __map_name_ref() {
    if [ -z "$1" ] ; then
        error "__map_name_ref <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    printf "map_%s\n" "$(printf '%s\n' "$1" | md5sum)"
}

# __map_key_ref <MAP-NAME> <MAP-KEY>
  __map_key_ref() {
    if [ -z "$1" ] ; then
        error "__map_key_ref <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "__map_key_ref <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    printf "%s_key_%s\n" "$(__map_name_ref "$1")" "$(printf '%s\n' "$2" | md5sum)"
}

# map_contains <MAP-NAME> <MAP-KEY>
  map_contains() {
    if [ -z "$1" ] ; then
        error "map_contains <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_contains <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    for item in $(eval echo \$$(__map_name_ref "$1"))
    do
        if [ "$item" = "$2" ] ; then
            return 0
        fi
    done

    return 1
}

# map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>
  map_set() {
    if [ -z "$1" ] ; then
        error "map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>, <MAP-KEY> is not given."
        return 41
    fi

    map_contains "$1" "$2" || {
        unset __MAP_NAME_REF__
        __MAP_NAME_REF__="$(__map_name_ref "$1")"
        __MAP_NAME_REF_VALUE__="$(eval echo \$$__MAP_NAME_REF__)"
        eval "$__MAP_NAME_REF__=\"$__MAP_NAME_REF_VALUE__ $2\""
    }

    eval "$(__map_key_ref "$1" "$2")=$3"
}

# map_get <MAP-NAME> <MAP-KEY>
  map_get() {
    if [ -z "$1" ] ; then
        error "map_get <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_get <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    eval echo "\$$(__map_key_ref "$1" "$2")"
}

# map_remove <MAP-NAME> <MAP-KEY>
  map_remove() {
    if [ -z "$1" ] ; then
        error "map_remove <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_remove <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    unset __MAP_KEYS__
    __MAP_KEYS__="$(map_keys "$1")"

    unset $__MAP_NAME_REF__

    for item in $__MAP_KEYS__
    do
        if [ "$item" = "$2" ] ; then
            continue
        else
            eval "$__MAP_NAME_REF__='$(eval echo \$$__MAP_NAME_REF__) $item'"
        fi
    done

    eval "unset $(__map_key_ref "$1" "$2")"
}

# map_remove <MAP-NAME>
  map_clear() {
    if [ -z "$1" ] ; then
        error "map_clear <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    for item in $(eval echo "\$$__MAP_NAME_REF__")
    do
        eval "unset $(__map_key_ref "$1" "$item")"
    done

    eval "unset $__MAP_NAME_REF__"
}

# map_keys <MAP-NAME>
  map_keys() {
    if [ -z "$1" ] ; then
        error "map_keys <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    eval echo "\$$(__map_name_ref "$1")"
}

# map_size <MAP-NAME>
  map_size() {
    if [ -z "$1" ] ; then
        error "map_size <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    list_length $(map_keys "$1")
}

# }}}
##############################################################################
# {{{ fetch

# fetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_URI
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    unset FETCH_SILENT

    if [ -z "$1" ] ; then
        error "fetch <URL> [OPTION]... , <URL> must not be empty."
        return 1
    else
        if [ "$COUNTRY" = 'china' ] ; then
            FETCH_URL="$(get_china_mirror_url "$1")"
        else
            FETCH_URL="$1"
        fi
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --silent)
                FETCH_SILENT=yes
                RUN_SILENT=yes
                ;;
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --uri=*)
                FETCH_URI=$(getvalue "$1")
                if [ -z "$FETCH_URI" ] ; then
                    error "fetch <URL> --uri=<URL-MIRROR> , <URL-MIRROR> must not be empty."
                    return 1
                else
                    if [ "$COUNTRY" = 'china' ] ; then
                        FETCH_URI="$(get_china_mirror_url "$FETCH_URI")"
                    fi
                fi
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    error "fetch <URL> --output-dir=<DIR> , <DIR> must not be empty."
                    return 1
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    error "fetch <URL> --output-name=<NAME> , <NAME> must not be empty."
                    return 1
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    error "fetch <URL> --output-path=<FILEPATH> , <FILEPATH> must not be empty."
                    return 1
                fi
                ;;
            *)  error "fetch <URL> [OPTION]..., unrecognized option: $1

    fetch command usage:

    fetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-path=PATH>
    fetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
    fetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
    fetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>"
                return 1
        esac
        shift
    done

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        if [ -z "$FETCH_OUTPUT_DIR" ] && [ -z "$FETCH_OUTPUT_NAME" ] ; then
            FETCH_OUTPUT_PATH='-'
        else
            if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                FETCH_OUTPUT_DIR="$PWD"
            fi

            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi

            FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"

            if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                run install -d "$FETCH_OUTPUT_DIR" || return 1
            fi
        fi
    elif [ "$FETCH_OUTPUT_PATH" = '-' ] ; then
        unset FETCH_OUTPUT_DIR
        unset FETCH_OUTPUT_NAME
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
        if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR" || return 1
        fi
    fi

    case $FETCH_URL in
        *.git)
            if [    -d "$FETCH_OUTPUT_PATH" ] ; then
                run cd "$FETCH_OUTPUT_PATH" || return 1
                if      git rev-parse 2> /dev/null ; then
                    run git pull || return 1
                    run git submodule update --recursive || return 1
                else
                    run cd .. || return 1
                    run rm -rf "$FETCH_OUTPUT_NAME" || return 1
                    run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
                fi
            else
                if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                    run install -d "$FETCH_OUTPUT_DIR" || return 1
                fi
                run cd "$FETCH_OUTPUT_DIR" || return 1
                run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
            fi
            ;;
        *)
            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -f "$FETCH_OUTPUT_PATH" ] ; then
                if [ -n "$FETCH_SHA256" ] ; then
                    if file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                        success "$FETCH_OUTPUT_PATH already have been fetched."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_PATH" || return 1
            fi

            for FETCH_TOOL in curl wget http lynx aria2c axel
            do
                if command_exists_in_filesystem "$FETCH_TOOL" ; then
                    break
                else
                    unset FETCH_TOOL
                fi
            done

            if [ -z "$FETCH_TOOL" ] ; then
                error "no fetch tool found, please install one of curl wget http lynx aria2c axel, then try again."
                return 1
            fi

            case $FETCH_TOOL in
                curl)
                    unset FETCH_TOOL_CURL_EXTRA_OPTIONS

                    if [ "$FETCH_SILENT" = yes ] ; then
                        FETCH_TOOL_CURL_OPTIONS='--no-progress-meter'
                    fi

                    if [ -f "$MY_HOME_DIR/core/etc/ssl/certs/cacert.pem" ] ; then
                        FETCH_TOOL_CURL_OPTIONS="--cacert $MY_HOME_DIR/core/etc/ssl/certs/cacert.pem"
                    fi

                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                wget)
                    run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                http)
                    run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                lynx)
                    run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'" ||
                    run "lynx -source '$FETCH_URI' > '$FETCH_OUTPUT_PATH'"
                    ;;
                aria2c)
                    run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'" ||
                    run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URI'"
                    ;;
                axel)
                    run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                *)  error "fetch() unimplementation: $FETCH_TOOL"
                    return 1
                    ;;
            esac

            [ $? -eq 0 ] || return 1

            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -n "$FETCH_SHA256" ] ; then
                file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" || {
                    error "sha256sum mismatch.\n    expect : $FETCH_SHA256\n    actual : $(sha256sum $FETCH_OUTPUT_PATH)"
                    return 1
                }
            fi
    esac
}

install_ca_certificates_on_netbsd() {
    # https://www.cambus.net/installing-ca-certificates-on-netbsd/
    if [ "$(uname)" = NetBSD ] ; then
        command -v mozilla-rootcerts > /dev/null || {
            if command -v pkgin > /dev/null ; then
                run $([ "$(whoami)" = root ] || printf 'sudo\n') pkgin -y install mozilla-rootcerts
            fi
        }
        run mozilla-rootcerts install || true
    fi
}

# }}}
##############################################################################
# {{{ get_china_mirror_url

# get_china_mirror_url <ORIGIN_URL>
get_china_mirror_url() {
    case $1 in
        *githubusercontent.com/*)
            printf "%s\n" "$1" | sed 's@githubusercontent.com/@githubusercontents.com/@'
            ;;
        *github.com/*)
            printf "%s\n" "$1" | sed 's@github.com/@hub.fastgit.org/@'
            ;;
        *)  printf '%s\n' "$1"
    esac
}

# }}}
##############################################################################
# {{{ __upgrade_self

# __upgrade_self <URL> [--china] [-x]
__upgrade_self() {
    set -e

    if [ -z "$1" ] ; then
        error "__upgrade_self <URL> [--china] [-x] , <URL> must not be empty."
        return 1
    else
        UPGRADE_SELF_URL="$1"
    fi

    shift

    unset XTRACE
    unset COUNTRY

    for arg in $@
    do
        case $arg in
            --xtrace|-x)
                XTRACE=yes
                set -x
                ;;
            --china)
                COUNTRY=china
                ;;
            *)  error "__upgrade_self <URL> [--china] [-x] , unrecognized argument: $arg" ; return 1
        esac
    done

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f $CURRENT_SCRIPT_FILEPATH)
        else
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$UPGRADE_SELF_URL" --output-path="$WORKING_DIR/self"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
            run      install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        else
            run sudo install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        fi

        run rm -rf $WORKING_DIR
    }

    trap __upgrade_self_exit EXIT
}

# }}}
##############################################################################
# {{{ __integrate_zsh_completions

# __integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x]
__integrate_zsh_completions() {
    set -e

    if [ -z "$1" ] ; then
        error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x] , <URL> must not be empty."
        return 1
    else
        ZSH_COMPLETIONS_SCRIPT_URL="$1"
    fi

    shift

    unset XTRACE
    unset COUNTRY
    unset OUTPUT_DIR

    for arg in $@
    do
        case $arg in
            --xtrace|-x)
                XTRACE=yes
                set -x
                ;;
            --china)
                COUNTRY=china
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$OUTPUT_DIR" ] ; then
                    error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <DIR> must not be empty."
                    return 1
                fi
                OUTPUT_DIR=$(globing "$OUTPUT_DIR")
                ;;
            *)  error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x] , unrecognized argument: $arg"
                return 1
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ -n "$OUTPUT_DIR" ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="$OUTPUT_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    elif [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        else
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        fi
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$ZSH_COMPLETIONS_SCRIPT_URL" --output-path="$WORKING_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"
        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf $WORKING_DIR

    printf '\n'
    note "${COLOR_YELLOW}you need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ os

__get_os_kind_from_uname() {
    case $1 in
        msys*)    printf '%s\n' 'windows' ;;
        mingw32*) printf '%s\n' 'windows' ;;
        mingw64*) printf '%s\n' 'windows' ;;
        cygwin*)  printf '%s\n' 'windows' ;;
        *)        printf '%s\n' "$1"
    esac
}

__get_os_type_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_type_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f1 | tr A-Z a-z ;;
            *)   return 1
        esac
    fi
}

__get_os_version_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_version_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f2 ;;
            *)   return 1
        esac
    fi
}

# https://www.freedesktop.org/software/systemd/man/os-release.html
__get_os_type_from_etc_os_release() {
    if [ -e /etc/os-release ] ; then
        (
            . /etc/os-release || return 20
            if [ -z "$ID" ] ; then
                return 1
            else
                printf '%s\n' "$ID" | tr A-Z a-z
            fi
        )
    else
        return 1
    fi
}

__get_os_version_from_etc_os_release() {
    if [ -f /etc/os-release ] ; then
        (
            . /etc/os-release || return 20
            if [ -z "$VERSION_ID" ] ; then
                printf '%s\n' 'rolling'
            else
                printf '%s\n' "$VERSION_ID"
            fi
        )
    else
        return 1
    fi
}

# https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/lsbrelease.html
__get_os_type_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --id | cut -f2 | tr A-Z a-z
    else
        return 1
    fi
}

__get_os_version_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --release | cut -f2
    else
        return 1
    fi
}

__get_os_type_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_type_from_etc_redhat_release "$(cat /etc/redhat-release)"
        else
            return 1
        fi
    else
        case $1 in
            'Red Hat Enterprise Linux release'*)
                printf '%s\n' rhel
                ;;
            'Fedora release'*)
                printf '%s\n' fedora
                ;;
            'CentOS release'*)
                printf '%s\n' centos
                ;;
            'CentOS Linux release'*)
                printf '%s\n' centos
                ;;
            *)  printf '%s\n' "$1" | cut -d ' ' -f1 | tr A-Z a-z
        esac
    fi
}

__get_os_version_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_version_from_etc_redhat_release $(cat /etc/redhat-release)
        else
            return 1
        fi
    else
        while [ -n "$1" ]
        do
            case $1 in
                [1-9]*) printf '%s\n' "$1"; return 0
            esac
            shift
        done
        return 1
    fi
}

__get_os_version_from_getprop() {
    if command -v getprop > /dev/null ; then
        getprop ro.build.version.release
    else
        return 1
    fi
}

__get_os_arch_from_uname() {
    if command -v uname > /dev/null ; then
        uname -m 2> /dev/null
    else
        return 1
    fi
}

__get_os_arch_from_arch() {
    if command -v arch > /dev/null ; then
        arch
    else
        return 1
    fi
}

__get_os_type_from_os_kind() {
    case $1 in
        darwin)  printf '%s\n' macos ;;
        linux)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                printf '%s\n' android
            else
                __get_os_type_from_etc_redhat_release ||
                __get_os_type_from_etc_os_release ||
                __get_os_type_from_lsb_release ||
                __get_os_type_from_uname_a
            fi
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_name_from_os_type() {
    case $1 in
        debian)  printf '%s\n' 'Debian' ;;
        ubuntu)  printf '%s\n' 'Ubuntu' ;;
        linuxmint) printf '%s\n' 'LinuxMint' ;;
        centos)  printf '%s\n' 'CentOS' ;;
        fedora)  printf '%s\n' 'Fedora' ;;
        rhel)    printf '%s\n' 'RHEL' ;;
        opensuse-leap)
                 printf '%s\n' 'openSUSE-Leap' ;;
        gentoo)  printf '%s\n' 'Gentoo' ;;
        manjaro) printf '%s\n' 'Manjaro' ;;
        alpine)  printf '%s\n' 'AlpineLinux' ;;
        arch)    printf '%s\n' 'ArchLinux' ;;
        void)    printf '%s\n' 'VoidLinux' ;;
        freebsd) printf '%s\n' 'FreeBSD' ;;
        netbsd)  printf '%s\n' 'NetBSD' ;;
        openbsd) printf '%s\n' 'OpenBSD' ;;
        macos)   printf '%s\n' 'macOS' ;;
        android) printf '%s\n' 'Android' ;;
        windows)
            systeminfo | sed -n '/OS Name:/p' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//'
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_version_from_os_kind() {
    case $1 in
        freebsd) freebsd-version ;;
        openbsd) uname -r ;;
        netbsd)  uname -r ;;
        darwin)  sw_vers -productVersion ;;
        linux)
            __get_os_version_from_etc_redhat_release ||
            __get_os_version_from_etc_os_release ||
            __get_os_version_from_lsb_release ||
            __get_os_version_from_getprop ||
            __get_os_version_from_uname_a
            ;;
        windows)
            systeminfo | sed -n '/OS Version:/p' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//' | cut -d ' ' -f1
            ;;
    esac
}

__get_os_sub_system() {
    case $(uname | tr A-Z a-z) in
        msys*)    printf '%s\n' "msys"    ;;
        mingw32*) printf '%s\n' "mingw32" ;;
        mingw64*) printf '%s\n' "mingw64" ;;
        cygwin*)  printf '%s\n' 'cygwin'  ;;
        *)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                if [ -n "$TERMUX_VERSION" ] ; then
                    printf '%s\n' termux
                fi
            fi
    esac
}

__get_os_arch() {
    __get_os_arch_from_uname ||
    __get_os_arch_from_arch
}

__get_os_libc_from_os_kind() {
    if [ "$1" = linux ] ; then
        if [ "$(uname -o 2>/dev/null)" = Android ] ; then
            printf '%s\n' bionic
            return 0
        fi

        # https://pubs.opengroup.org/onlinepubs/7908799/xcu/getconf.html
        if command -v getconf > /dev/null ; then
            if getconf GNU_LIBC_VERSION > /dev/null 2>&1 ; then
                printf '%s\n' glibc
                return 0
            fi
        fi

        if command -v ldd > /dev/null ; then
            if command -v grep > /dev/null ; then
                if ldd --version 2>&1 | head -n 1 | grep -q GLIBC ; then
                    printf '%s\n' glibc
                    return 0
                fi
                if ldd --version 2>&1 | head -n 1 | grep -q musl ; then
                    printf '%s\n' musl
                    return 0
                fi
            elif command -v sed > /dev/null ; then
                if [ -n "$(ldd --version 2>&1 | head -n 1 | sed -n '/GLIBC/p')" ] ; then
                    printf '%s\n' glibc
                    return 0
                fi
                if [ -n "$(ldd --version 2>&1 | head -n 1 | sed -n '/musl/p')"  ] ; then
                    printf '%s\n' musl
                    return 0
                fi
            fi
        fi

        return 1
    fi
}

# https://stackoverflow.com/questions/45181115/portable-way-to-find-the-number-of-processors-cpus-in-a-shell-script
__get_os_ncpu() {
    case "$(uname)" in
        Darwin) sysctl -n machdep.cpu.thread_count ;;
        *BSD)   sysctl -n hw.ncpu ;;
        *)  if command nproc --version > /dev/null 2>&1 ; then
                command nproc
            elif test -f /proc/cpuinfo ; then
                if command -v grep > /dev/null ; then
                    grep -c processor /proc/cpuinfo
                elif command -v sed > /dev/null && command -v wc > /dev/null ; then
                    sed -n '/^processor/p' /proc/cpuinfo | wc -l
                else
                    printf '%s\n' 4
                fi
            else
                printf '%s\n' 4
            fi
    esac
}

os() {
    if [ $# -eq 0 ] ; then
        printf "current-machine-os-kind : %s\n" "$(os kind)"
        printf "current-machine-os-type : %s\n" "$(os type)"
        printf "current-machine-os-name : %s\n" "$(os name)"
        printf "current-machine-os-vers : %s\n" "$(os vers)"
        printf "current-machine-os-arch : %s\n" "$(os arch)"
        printf "current-machine-os-ncpu : %s\n" "$(os ncpu)"
        printf "current-machine-os-euid : %s\n" "$(os euid)"
        printf "current-machine-os-libc : %s\n" "$(os libc)"
        printf "current-machine-os-subs : %s\n" "$(os subs)"
    elif [ $# -eq 1 ] ; then
        case $1 in
            -h|--help)
                cat <<'EOF'
os -h | --help
os -V | --version
os kind
os type
os name
os vers
os arch
os ncpu
os euid
os libc
os subs
EOF
                ;;
            -V|--version)
                printf "%s\n" '2021.10.01.03'
                ;;
            kind)
                __get_os_kind_from_uname $(uname | tr A-Z a-z)
                ;;
            type)
                __get_os_type_from_os_kind $(os kind)
                ;;
            name)
                __get_os_name_from_os_type $(os type)
                ;;
            vers)
                __get_os_version_from_os_kind $(os kind)
                ;;
            subs)
                __get_os_sub_system
                ;;
            arch)
                __get_os_arch
                ;;
            ncpu)
                __get_os_ncpu
                ;;
            euid)
                id -u
                ;;
            libc)
                __get_os_libc_from_os_kind $(os kind)
                ;;
            *)  printf '%s\n' "unrecognized argument: $1" >&2; return 1
        esac
    else
        printf '%s\n' "os command only support one argument." >&2; return 1
    fi
}

# }}}
##############################################################################
# {{{ version

version_of_python_module() {
    unset PIP_COMMAND
    PIP_COMMAND=$(command -v pip3 || command -v pip)
    if [ -z "$PIP_COMMAND" ] ; then
        error "can't found pip command."
        return 1
    else
        "$PIP_COMMAND" show $1 | sed -n '/Version:/p' | cut -d ' ' -f2
    fi
}

# retrive the version of a command from it's name or path
version_of_command() {
    case $(basename "$1") in
      gclient) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       ccache) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         bear) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmake) "$1" --version 2> /dev/null | head -n 1 | cut -d '+' -f1 | cut -d 'v' -f2 ;;
        cmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         rake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       rustc)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$1"   version | cut -d ' ' -f3 | cut -c3- ;;
         tree) "$1" --version | cut -d ' ' -f2 | cut -c2- ;;
   pkg-config) "$1" --version 2> /dev/null | head -n 1 ;;
     patchelf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       m4|gm4) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
    autopoint) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     xgettext) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     automake|aclocal)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     realpath) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
  intltoolize) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      objcopy) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
          adb) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
         flex) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        groff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     makeinfo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     help2man) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
    gtkdocize) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 sphinx-build) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
 glib-mkenums) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 glib-compile-resources)
               "$1" --version ;;
         file) "$1" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       protoc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
     rst2man|rst2man.py|rst2man-3|rst2man-3.6|rst2man-3.7|rst2man-3.8|rst2man-3.9)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         java) "$1"  -version 2>&1 | head -n 1 | cut -d ' ' -f3 | sed 's/"//g' ;;
         gzip) "$1" --version 2>&1 | head -n 1 | awk '{print($NF)}' ;;
         lzip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$1" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$1" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2) "$1" --help 2>&1 | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1 ;;
          tar)
            VERSION_MSG=$("$1" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) printf '%s\n' "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) printf '%s\n' "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         cpan) ;;
         find) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         diff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         grep) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$1" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
          lua) "$1" -v 2>/dev/null | head -n 1 | cut -d ' ' -f2 ;;
    python|python2|python3)
               "$1" --version 2>&1 | head -n 1 | cut -d ' ' -f2 ;;
         pip)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         pip3) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         node) "$1" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
       base64) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      hexdump) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      sqlite3) "$1"  -version 2> /dev/null | head -n 1 | cut -d ' ' -f1 ;;
            *) "$1" --version 2> /dev/null | head -n 1
    esac
}

# retrive the major part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_major_of_command() {
    version_of_command "$1" | cut -d. -f1
}

# retrive the minor part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_minor_of_command() {
    version_of_command "$1" | cut -d. -f2
}

# retrive the major part of the given version
# Note: the given version must have form: major.minor.patch
version_major_of_version() {
    printf '%s\n' "$1" | cut -d. -f1
}

# retrive the minor part of the given version
# Note: the given version must have form: major.minor.patch
version_minor_of_version() {
    printf '%s\n' "$1" | cut -d. -f2
}

version_sort() {
    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html
    # https://man.netbsd.org/NetBSD-8.1/i386/sort.1
    #
    # sort: unrecognized option: V
    # BusyBox v1.29.3 (2019-01-24 07:45:07 UTC) multi-call binary.
    # Usage: sort [-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...
    if  printf '%s\n' | (sort -V > /dev/null 2>&1) ; then
        printf '%s\n' "$@" | tr ' ' '\n' | sort -V
    else
        printf '%s\n' "$@" | tr ' ' '\n' | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4
    fi
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  error "version_compare: $2: not supported operator." ; return 1
    esac
}

# check if the version of give installed command match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# command_exists_in_filesystem_and_version_matched automake eq 1.16.0
# command_exists_in_filesystem_and_version_matched automake lt 1.16.0
# command_exists_in_filesystem_and_version_matched automake gt 1.16.0
# command_exists_in_filesystem_and_version_matched automake le 1.16.0
# command_exists_in_filesystem_and_version_matched automake ge 1.16.0
# command_exists_in_filesystem_and_version_matched automake
command_exists_in_filesystem_and_version_matched() {
    if command_exists_in_filesystem "$1" ; then
        if [ $# -eq 3 ] ; then
            version_match "$(version_of_command "$1")" "$2" "$3"
        fi
    else
        return 1
    fi
}

# }}}
##############################################################################
# {{{ operations of formula

__load_formula_of_the_given_package() {
    unset PACKAGE_FORMULA_LOADED

    unset PACKAGE_NAME
    unset PACKAGE_NAME_UPPERCASE_UNDERSCORE

    unset PACKAGE_SUMMARY
    unset PACKAGE_WEBPAGE

    unset PACKAGE_GIT_URL
    unset PACKAGE_GIT_SHA
    unset PACKAGE_GIT_REF
    unset PACKAGE_SHALLOW

    unset PACKAGE_SVN_URL

    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_URI
    unset PACKAGE_SRC_SHA
    unset PACKAGE_SRC_NAME
    unset PACKAGE_SRC_TYPE
    unset PACKAGE_SRC_PATH

    unset PACKAGE_FIX_URL
    unset PACKAGE_FIX_SHA
    unset PACKAGE_FIX_NAME
    unset PACKAGE_FIX_TYPE
    unset PACKAGE_FIX_PATH

    unset PACKAGE_RES_URL
    unset PACKAGE_RES_SHA
    unset PACKAGE_RES_NAME
    unset PACKAGE_RES_TYPE
    unset PACKAGE_RES_PATH

    unset PACKAGE_VERSION
    unset PACKAGE_VERSION_MAJOR
    unset PACKAGE_VERSION_MINOR
    unset PACKAGE_VERSION_PATCH
    unset PACKAGE_VERSION_TWEAK

    unset PACKAGE_DEVELOPER

    unset PACKAGE_LICENSE

    unset PACKAGE_BSYSTEM

    unset PACKAGE_BUILD_SYSTEM
    unset PACKAGE_BUILD_SYSTEM_GO
    unset PACKAGE_BUILD_SYSTEM_RAKE
    unset PACKAGE_BUILD_SYSTEM_NINJA
    unset PACKAGE_BUILD_SYSTEM_GMAKE
    unset PACKAGE_BUILD_SYSTEM_CMAKE
    unset PACKAGE_BUILD_SYSTEM_XMAKE
    unset PACKAGE_BUILD_SYSTEM_MESON
    unset PACKAGE_BUILD_SYSTEM_CARGO
    unset PACKAGE_BUILD_SYSTEM_AUTOGENSH
    unset PACKAGE_BUILD_SYSTEM_AUTOTOOLS
    unset PACKAGE_BUILD_SYSTEM_CONFIGURE
    unset PACKAGE_BUILD_SYSTEM_NDK_BUILD

    # dir relative to $PACKAGE_INSTALLING_TOP_DIR, which contains build script such as autogen.sh, configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, xmake.lua, etc.
    unset PACKAGE_BSCRIPT

    # if build in build script dir, otherwise build in build dir
    unset PACKAGE_BINBSTD
    unset PACKAGE_BUILD_IN_BSCRIPT_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL
    unset PACKAGE_PARALLEL

    # space-separated    perl modules that are depended by this package when installing and/or runtime, which will be installed via cpan
    unset PACKAGE_DEP_PLM

    # space-separated python packages that are depended by this package when installing and/or runtime, which will be installed via pip3
    unset PACKAGE_DEP_PYM

    # space-separated   ppkg packages that are depended by this package when installing and/or runtime, which will be installed via uppm
    unset PACKAGE_DEP_UPP

    # space-separated   ppkg packages that are depended by this package when installing and/or runtime, which will be installed via ppkg
    unset PACKAGE_DEP_PKG

    unset PACKAGE_CDEFINE
    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_FORMULA_FILEPATH

    unset -f build0
    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    for key in summary webpage git-url git-sha git-ref shallow src-url src-uri src-sha fix-url fix-sha res-url res-sha dep-pkg dep-pym license version bsystem bscript binbstd cdefine ccflags xxflags ldflags parallel toolset cstdlib exetype
    do
        unset __KEY_UPPERCASE_UNDERSCORE__
        unset __VALUE__

        __KEY_UPPERCASE_UNDERSCORE__="$(printf '%s\n' "$key" | tr '-' '_' | tr a-z A-Z)"
        __VALUE__="$(yq ".$key" "$PACKAGE_FORMULA_FILEPATH")"

        if [ "$__VALUE__" = null ] ; then
                __VALUE__=
        fi

        eval "PACKAGE_$__KEY_UPPERCASE_UNDERSCORE__='$__VALUE__'"
    done

    unset PACKAGE_PREPARE_ACTIONS
    PACKAGE_PREPARE_ACTIONS="$(yq .prepare "$PACKAGE_FORMULA_FILEPATH")"

    unset PACKAGE_INSTALL_ACTIONS
    PACKAGE_INSTALL_ACTIONS="$(yq .install "$PACKAGE_FORMULA_FILEPATH")"

    if [ -z "$PACKAGE_BSYSTEM" ] && [ -n "$PACKAGE_INSTALL_ACTIONS" ]; then
        for FirstWordOfLineInInstallActions in $(printf '%s\n' "$PACKAGE_INSTALL_ACTIONS" | sed 's|^[ ]*||' | cut -d ' ' -f1)
        do
            case "$FirstWordOfLineInInstallActions" in
                configure)    PACKAGE_BSYSTEM=configure ; break ;;
                cmakew)       PACKAGE_BSYSTEM=cmake ; break ;;
                xmakew)       PACKAGE_BSYSTEM=xmake ; break ;;
                mesonw)       PACKAGE_BSYSTEM=meson ; break ;;
                gmakew)       PACKAGE_BSYSTEM=gmake ; break ;;
                cargow)       PACKAGE_BSYSTEM=cargo ; break ;;
                go|gow)       PACKAGE_BSYSTEM=go    ; break ;;
            esac
        done
    fi

    PACKAGE_NAME="$1"
    PACKAGE_NAME_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '+-.' '_')

    PACKAGE_BUILD_SYSTEM=$PACKAGE_BSYSTEM

    PACKAGE_BUILD_IN_BSCRIPT_DIR=$PACKAGE_BINBSTD

    if [ -z "$PACKAGE_PARALLEL" ] ; then
        PACKAGE_PARALLEL=yes
        PACKAGE_BUILD_IN_PARALLEL=yes
    else
        PACKAGE_BUILD_IN_PARALLEL="$PACKAGE_PARALLEL"
    fi

    if [ -z "$PACKAGE_SUMMARY" ] ; then
        die "summary must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_WEBPAGE" ] ; then
        PACKAGE_WEBPAGE="$PACKAGE_GIT_URL"
    fi

    if [ -z "$PACKAGE_WEBPAGE" ] ; then
        die "webpage or git-url must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        PACKAGE_SRC_URL="$PACKAGE_GIT_URL"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        die "src-url or git-url must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    case $PACKAGE_SRC_URL in
        dir://*)   PACKAGE_SRC_TYPE=dir ;;
        *.git)     PACKAGE_SRC_TYPE=git    ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP git" ;;
        *.zip)     PACKAGE_SRC_TYPE=zip    ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl unzip" ;;
        *.tar.xz)  PACKAGE_SRC_TYPE=tar.xz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar xz" ;;
        *.tar.gz)  PACKAGE_SRC_TYPE=tar.gz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar gzip" ;;
        *.tar.lz)  PACKAGE_SRC_TYPE=tar.lz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar lzip" ;;
        *.tar.bz2) PACKAGE_SRC_TYPE=tar.bz2; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar bzip2" ;;
        *.tgz)     PACKAGE_SRC_TYPE=tar.gz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar gzip" ;;
        *.txz)     PACKAGE_SRC_TYPE=tar.xz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar xz" ;;
        *.c)       PACKAGE_SRC_TYPE=c      ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl" ;;
        *.cc)      PACKAGE_SRC_TYPE=cxx    ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl" ;;
        *.cxx)     PACKAGE_SRC_TYPE=cxx    ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl" ;;
        *.cpp)     PACKAGE_SRC_TYPE=cxx    ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl" ;;
        *)  die "unrecognized extension : $PACKAGE_SRC_URL. the supported extensions are .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    case $PACKAGE_SRC_TYPE in
        dir)
            PACKAGE_SRC_PATH=$(printf '%s\n' "$PACKAGE_SRC_URL" | cut -c7-)

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        git)
            PACKAGE_SRC_NAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_PATH="$MY_CACHE_DIR/src/$PACKAGE_SRC_NAME"

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SHA" ] ; then
                die "src-sha is not configed in $PACKAGE_FORMULA_FILEPATH"
            fi

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr '_@' - | sed 's|-stable||' | sed 's|-src||' | sed 's|\.src||' | sed 's|\.orig\.|.|' | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.lz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                case $PACKAGE_VERSION in
                    '') die "version is not configed in $PACKAGE_FORMULA_FILEPATH" ;;
                    v*) PACKAGE_VERSION=$(printf '%s\n' "$PACKAGE_VERSION" | cut -c2-)
                esac
            fi

            PACKAGE_SRC_NAME="$PACKAGE_NAME-$PACKAGE_VERSION.$PACKAGE_SRC_TYPE"
            PACKAGE_SRC_PATH="$MY_CACHE_DIR/src/$PACKAGE_SRC_NAME"
    esac

    if [ -n "$PACKAGE_FIX_URL" ] ; then
        if [ -z "$PACKAGE_FIX_SHA" ] ; then
            die "fix-sha is not configed in $PACKAGE_FORMULA_FILEPATH"
        fi

        PACKAGE_FIX_NAME=$(basename "$PACKAGE_FIX_URL" | sed 's|?.*||')
        PACKAGE_FIX_PATH="$MY_CACHE_DIR/fix/$PACKAGE_FIX_NAME"

        case $PACKAGE_FIX_NAME in
            *.diff)    PACKAGE_FIX_TYPE=patch  ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"           ;;
            *.patch)   PACKAGE_FIX_TYPE=patch  ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"           ;;
            *.zip)     PACKAGE_FIX_TYPE=zip    ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch unzip"     ;;
            *.tar.xz)  PACKAGE_FIX_TYPE=tar.xz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            *.tar.gz)  PACKAGE_FIX_TYPE=tar.gz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            *.tar.lz)  PACKAGE_FIX_TYPE=tar.lz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar lzip"  ;;
            *.tar.bz2) PACKAGE_FIX_TYPE=tar.bz2; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar bzip2" ;;
            *.tgz)     PACKAGE_FIX_TYPE=tar.gz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            *.txz)     PACKAGE_FIX_TYPE=tar.xz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            *)  die "unrecognized fix extension : $PACKAGE_FIX_URL.\n    supported fix extensons are: .fix .diff .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
        esac
    fi

    if [ -n "$PACKAGE_RES_URL" ] ; then
        if [ -z "$PACKAGE_RES_SHA" ] ; then
            die "res-sha is not configed in $PACKAGE_FORMULA_FILEPATH"
        fi

        PACKAGE_RES_NAME=$(basename "$PACKAGE_RES_URL" | sed 's|?.*||')
        PACKAGE_RES_PATH="$MY_CACHE_DIR/res/$PACKAGE_RES_NAME"

        case $PACKAGE_RES_NAME in
            *.diff)    PACKAGE_RES_TYPE=patch  ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"           ;;
            *.patch)   PACKAGE_RES_TYPE=patch  ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"           ;;
            *.zip)     PACKAGE_RES_TYPE=zip    ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch unzip"     ;;
            *.tar.xz)  PACKAGE_RES_TYPE=tar.xz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            *.tar.gz)  PACKAGE_RES_TYPE=tar.gz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            *.tar.lz)  PACKAGE_RES_TYPE=tar.lz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar lzip"  ;;
            *.tar.bz2) PACKAGE_RES_TYPE=tar.bz2; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar bzip2" ;;
            *.tgz)     PACKAGE_RES_TYPE=tar.gz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            *.txz)     PACKAGE_RES_TYPE=tar.xz ; PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            *)  die "unrecognized res extension : $PACKAGE_FIX_URL.\n    supported res extensons are: .fix .diff .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
        esac
    fi

    if [ -n "$PACKAGE_VERSION" ] ; then
        PACKAGE_VERSION_MAJOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f1)"
        PACKAGE_VERSION_MINOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f2)"
        PACKAGE_VERSION_PATCH="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f3)"
        PACKAGE_VERSION_TWEAK="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f4)"
    fi

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            ndk-build)   PACKAGE_BUILD_SYSTEM_NDK_BUILD=yes ;;
            autogen)     PACKAGE_BUILD_SYSTEM_AUTOGENSH=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            autotools)   PACKAGE_BUILD_SYSTEM_AUTOTOOLS=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            configure)   PACKAGE_BUILD_SYSTEM_CONFIGURE=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-gmake) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-ninja) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            cmake)       PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            xmake)       PACKAGE_BUILD_SYSTEM_XMAKE=yes     ;;
            meson)       PACKAGE_BUILD_SYSTEM_MESON=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            ninja)       PACKAGE_BUILD_SYSTEM_NINJA=yes     ;;
            gmake)       PACKAGE_BUILD_SYSTEM_GMAKE=yes     ;;
            rake)        PACKAGE_BUILD_SYSTEM_RAKE=yes      ;;
            cargo)       PACKAGE_BUILD_SYSTEM_CARGO=yes     ;;
            go)          PACKAGE_BUILD_SYSTEM_GO=yes        ;;
        esac
    done

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     PACKAGE_DEP_PKG="$PACKAGE_DEP_PKG automake" ;;
            autotools)   PACKAGE_DEP_PKG="$PACKAGE_DEP_PKG automake" ;;

            configure)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"  ;;
            cmake-gmake) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake gmake"  ;;
            cmake-ninja) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            cmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            xmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP xmake"  ;;
            meson)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            ninja)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            gmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"  ;;
            rake)        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ruby"   ;;
            #cargo)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP rustup" ;;
            go)          PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP golang" ;;
        esac
    done

    if [ "$PACKAGE_BUILD_SYSTEM_MESON" = yes ] ; then
        PACKAGE_DEP_PYM=meson
    fi

    if [ -n "$PACKAGE_DEP_PYM" ] ; then
        PACKAGE_DEP_PKG="$PACKAGE_DEP_PKG python3"
    fi

    if [ -n "$PACKAGE_DEP_PLM" ] ; then
        PACKAGE_DEP_PKG="$PACKAGE_DEP_PKG perl"
    fi

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = no ] ; then
        BUILD_NJOBS=1
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_XMAKE" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    PACKAGE_FORMULA_LOADED=yes
}

# examples:
# __view_formula_of_the_given_package curl
# __view_formula_of_the_given_package curl --paging=never
  __view_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__view_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    shift

    unset VIEW_FORMULA_PAGING

    while [ -n "$1" ]
    do
        case $1 in
            --paging=*)
                VIEW_FORMULA_PAGING=$(getvalue "$1")
                case $VIEW_FORMULA_PAGING in
                    auto|always|never) ;;
                    *) die "--paging=<VALUE>, <VALUE> must be one of auto, always, never"
                esac
                ;;
            *)  die "unrecognized argument: $1"
        esac
        shift
    done

    case $VIEW_FORMULA_PAGING in
        ''|auto)
            if command -v bat > /dev/null ; then
                bat --language=yaml --paging=auto "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
        always)
            if command -v bat > /dev/null ; then
                bat --language=yaml --paging=always "$PACKAGE_FORMULA_FILEPATH"
            else
                more "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
        never)
            if command -v bat > /dev/null ; then
                bat --language=yaml --paging=never "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
    esac
}

# __edit_formula_of_the_given_package <PACKAGE-NAME>
  __edit_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__edit_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    [ -z "$2" ] || warn "edit action accept only one argument."

    if [ -z "$EDITOR" ] ; then
        EDITOR=$(command -v nvim || command -v vim || command -v vi || command -v open) || die "please set EDITOR environment variable."
    fi

    "$EDITOR" "$PACKAGE_FORMULA_FILEPATH"
}

# __create_formula_of_the_given_package <PACKAGE-NAME>
  __create_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__create_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset REPO_NAME
    REPO_NAME=offical

    if [ -e "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.yml" ] ; then
        die "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.yml formula already exists."
    fi

    cat > "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.yml" <<EOF
summary: Summary of this package
webpage: https://www.xx.com
bin-url: https://www.xx.com/pkgname-x.y.z.tar.gz
bin-sha: c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1
version: x.y.z
dep.pkg: a b c
prepare:
install:
EOF
    __edit_formula_of_the_given_package "$1"
}

# __delete_formula_of_the_given_package <PACKAGE-NAME>
  __delete_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__delete_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    run rm "$PACKAGE_FORMULA_FILEPATH"
}

# __rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>
__rename_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>, <OLD-PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "__rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>, <NEW-PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_REPO
    PACKAGE_FORMULA_REPO="$(__repo_of_formula_of_the_given_package $1)" || return 1

    unset PACKAGE_FORMULA_FILEPATH_OLD
    unset PACKAGE_FORMULA_FILEPATH_NEW

    PACKAGE_FORMULA_FILEPATH_OLD="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$1.yml"
    PACKAGE_FORMULA_FILEPATH_NEW="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$2.yml"

    if [ -f "$PACKAGE_FORMULA_FILEPATH_NEW" ] ; then
        die "$2 package is already exist."
    fi

    if mv "$PACKAGE_FORMULA_FILEPATH_OLD" "$PACKAGE_FORMULA_FILEPATH_NEW" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi
}

__list_formulas() {
    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -d  "$MY_FORMULA_REPO_DIR/$repo/formula" ] ; then
            find "$MY_FORMULA_REPO_DIR/$repo/formula" -maxdepth 1 -type f -name '*.yml'
        fi
    done
}

# __add_a_formula_repo <REPO-NAME> <REPO-URL>
__add_a_formula_repo() {
    if [ -z "$1" ] ; then
        die "please specify a repo name."
    fi

    if [ -z "$2" ] ; then
        die "please specify a repo url."
    fi

    case $2 in
        *.git)
            case $2 in
                http://*|https://*|git@*) ;;
                *)  die "$2: not a valid git url."
            esac
            ;;
        *)  die "$2: repo url must end with .git"
    esac

    for repoName in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            die "$1 formula repo already exists."
        fi
    done

    printf '%s=%s\n' "$1" "$2" >> "$MY_HOME_DIR/repos"
}

# __del_a_formula_repo <REPO-NAME>
  __del_a_formula_repo() {
    if [ -z "$1" ] ; then
        die "please specify a repo name."
    fi

    if [ "$1" = 'offical' ] ; then
        die "offical formula repo can not be deleted."
    fi

    unset REPO_EXISTS
    for repoName in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            REPO_EXISTS=yes
        fi
    done

    if [ "$REPO_EXISTS" = yes ] ; then
        sed_in_place "/^$1=/d" "$MY_HOME_DIR/repos"
    else
        die "$1 formula repo not exists."
    fi
}

__repo_of_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__repo_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ -e "$MY_FORMULA_REPO_DIR/$repo/formula/$1.yml" ] ; then
            printf '%s\n' "$repo"
            return 0
        fi
    done

    error "package [$1] is not available."
    return 1
}

# __path_of_formula_of_the_given_package <PACKAGE-NAME>
  __path_of_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__path_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -e           "$MY_FORMULA_REPO_DIR/$repo/formula/$1.yml" ] ; then
            printf '%s\n' "$MY_FORMULA_REPO_DIR/$repo/formula/$1.yml"
            return 0
        fi
    done

    error "package [$1] is not available."
    return 1
}

__list_formula_repositories() {
    if [ -e "$MY_HOME_DIR/repos" ] ; then
        cat "$MY_HOME_DIR/repos"
    else
        install -d "$MY_HOME_DIR"
        printf 'offical=%s\n' "$MY_OFFICAL_FORMULA_REPO_URL" | tee "$MY_HOME_DIR/repos"
    fi
}

__update_formula_repositories() {
    for item in $(__list_formula_repositories)
    do
        unset FORMULA_REPO_NAME
        unset FORMULA_REPO_URL_

        FORMULA_REPO_NAME=$(printf '%s\n' "$item" | cut -d= -f1)
        FORMULA_REPO_URL_=$(printf '%s\n' "$item" | cut -d= -f2)

        printf '%b\n' "${COLOR_PURPLE}=== Updating formula repository${COLOR_OFF} ${COLOR_GREEN}$FORMULA_REPO_NAME${COLOR_OFF}"

        if [ -d        "$MY_FORMULA_REPO_DIR/$FORMULA_REPO_NAME" ] ; then
            run git -C "$MY_FORMULA_REPO_DIR/$FORMULA_REPO_NAME" pull origin master:master
            if [ "$(git branch | sed -n '/^*/p' | cut -d ' ' -f2)" != master ] ;  then
                run git -C "$MY_FORMULA_REPO_DIR/$FORMULA_REPO_NAME" checkout master
            fi
        else
            run install -d "$MY_FORMULA_REPO_DIR"
            run git -C "$MY_FORMULA_REPO_DIR" clone "$FORMULA_REPO_URL_" "$FORMULA_REPO_NAME"
        fi
    done
}

# }}}
##############################################################################

prompt_user_to_install_bat() {
    echo
    note "${COLOR_YELLOW}if you want to have a better experience, I strongly recommend you to install${COLOR_OFF} ${COLOR_GREEN}bat${COLOR_OFF} ${COLOR_YELLOW}on this machine. For more details, please visit website${COLOR_OFF} ${COLOR_GREEN}https://github.com/sharkdp/bat${COLOR_OFF}"
}

# fetch source code if needed
__fetch_sources_of_the_given_package() {
    case $PACKAGE_SRC_TYPE in
        dir) note "$PACKAGE_SRC_URL is local path, no need to fetch." ;;
        git)
            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                GIT_REF_SPEC="+HEAD:refs/remotes/origin/master"
            else
                GIT_REF_SPEC="+$PACKAGE_GIT_SHA:refs/remotes/origin/master"
            fi

            if [ "$PACKAGE_SHALLOW" = yes ] ; then
                GIT_FETCH_EXTRA_OPTIONS='--depth=1'
            else
                if [ -f "$PACKAGE_SRC_PATH/.git/shallow" ] ; then
                    GIT_FETCH_EXTRA_OPTIONS='--unshallow'
                else
                    GIT_FETCH_EXTRA_OPTIONS=
                fi
            fi

            if [ -d "$PACKAGE_SRC_PATH" ] ; then
                if git -C "$PACKAGE_SRC_PATH" rev-parse 2> /dev/null ; then
                    if [ -n "$PACKAGE_GIT_SHA" ] && [ "$PACKAGE_GIT_SHA" = "$(git -C "$PACKAGE_SRC_PATH" rev-parse HEAD)" ] ; then
                        success "$PACKAGE_SRC_PATH already have been fetched."
                        return 0
                    fi

                    run git -C "$PACKAGE_SRC_PATH" -c protocol.version=2 fetch --prune --progress $GIT_FETCH_EXTRA_OPTIONS origin "$GIT_REF_SPEC" || return 1
                    run git -C "$PACKAGE_SRC_PATH" checkout --progress --force -B master refs/remotes/origin/master || return 1
                    run git -C "$PACKAGE_SRC_PATH" submodule update --init || return 1

                    return 0
                else
                    run rm -rf "$PACKAGE_SRC_PATH" || return 1
                fi
            fi

            run install -d "$PACKAGE_SRC_PATH" || return 1
            run git -C "$PACKAGE_SRC_PATH" -c init.defaultBranch=master init || return 1
            run git -C "$PACKAGE_SRC_PATH" remote add origin "$PACKAGE_SRC_URL" || return 1
            run git -C "$PACKAGE_SRC_PATH" -c protocol.version=2 fetch --prune --progress $GIT_FETCH_EXTRA_OPTIONS origin "$GIT_REF_SPEC" || return 1
            run git -C "$PACKAGE_SRC_PATH" checkout --progress --force -B master refs/remotes/origin/master || return 1
            run git -C "$PACKAGE_SRC_PATH" submodule update --init || return 1
            ;;
        *)  if [ -z   "$PACKAGE_SRC_URI" ] ; then
                fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_PATH"
            else
                fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_PATH" --uri="$PACKAGE_SRC_URI"
            fi
    esac
}

__fetch_patches_of_the_given_package() {
    if [ -n   "$PACKAGE_FIX_URL" ] ; then
        fetch "$PACKAGE_FIX_URL" --sha256="$PACKAGE_FIX_SHA" --output-path="$PACKAGE_FIX_PATH"
    fi
    if [ -n   "$PACKAGE_RES_URL" ] ; then
        fetch "$PACKAGE_RES_URL" --sha256="$PACKAGE_RES_SHA" --output-path="$PACKAGE_RES_PATH"
    fi
}

__fetch_resources_of_the_given_package() {
    [ -z "$1" ] && {
        error "__fetch_resources_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    case $1 in
        @all)
            shift
            unset STEP_NUM
            for PKG in $(__list_available_packages)
            do
                step "$PKG"
                 __load_formula_of_the_given_package "$PKG" $@
                __fetch_sources_of_the_given_package "$PKG" $@
                __fetch_patches_of_the_given_package "$PKG" $@
            done
            ;;
        *)
             __load_formula_of_the_given_package $@
            __fetch_sources_of_the_given_package $@
            __fetch_patches_of_the_given_package $@
    esac
}

# check if the given package is available
# if the version condition is given, check if the condition is matched
#
# condition operator:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available automake eq 1.16.0
# is_package_available automake lt 1.16.0
# is_package_available automake gt 1.16.0
# is_package_available automake le 1.16.0
# is_package_available automake ge 1.16.0
# is_package_available automake
  is_package_available() {
    [ -z "$1" ] && {
        error "is_package_available <PACKAGE-NAME> [<eq|lt|gt|le|ge> <VERSION>], <PACKAGE-NAME> is not given."
        return 1
    }

    case $# in
        1)  [ -n "$(__path_of_formula_of_the_given_package $1)" ] ;;
        3)  __load_formula_of_the_given_package "$1" || return 1
            shift
            version_match $PACKAGE_VERSION $@
            ;;
        *)  error "is available command only accept 1 or 3 argument." ; return 1
    esac
}

# is_package_installed <PACKAGE-NAME>
  is_package_installed() {
    [ -z "$1" ] && {
        error "is_package_installed <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    [ -d "$MY_INSTALL_DIR/$1" ]                    || return 10
    [ -f "$MY_INSTALL_DIR/$1/installed-metadata-ppkg" ] || return 11
    [ -f "$MY_INSTALL_DIR/$1/installed-files" ]    || return 12
}

# is_package__outdated <PACKAGE-NAME>
  is_package__outdated() {
    __load_formula_of_the_given_package "$1"
    __load_installed_metadata_of_the_given_package "$1"
    version_match "$PACKAGE_VERSION" gt "$INSTALLED_PACKAGE_VERSION"
}

__gen_github_workflows() {
    set -e

    unset GROUP_SIZE
    unset OUTPUT_DIR

    while [ -n "$1" ]
    do
        case $1 in
            --group-size=*)
                GROUP_SIZE=$(getvalue "$1")
                is_integer "$GROUP_SIZE" || die "--group-size=INTEGER"
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                case "$OUTPUT_DIR" in
                    '') die "--output-dir=<DIR>, <DIR> must not be empty." ;;
                    /*) ;;
                    \~|\~/) OUTPUT_DIR="${HOME}" ;;
                    \~/*)   OUTPUT_DIR="${HOME}$(printf "$OUTPUT_DIR" | cut -c3-)" ;;
                    .|./)   OUTPUT_DIR="${PWD}" ;;
                    *)      OUTPUT_DIR="${PWD}/$OUTPUT_DIR" ;;
                esac
                [ -d "$OUTPUT_DIR" ] || run install -d "$OUTPUT_DIR"
        esac
        shift
    done

    if [ -z "$GROUP_SIZE" ] ; then
        die "please sepecify --group-size=INTEGER argument."
    fi

    if [ -z "$OUTPUT_DIR" ] ; then
        OUTPUT_DIR="$MY_HOME_DIR/repos.d/offical/.github/workflows"
    fi

    GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH="$MY_HOME_DIR/repos.d/offical/.github/workflows/template"

    if [ ! -f "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" ] ; then
        __update_formula_repositories
    fi

    unset AVAILABLE_PACKAGES
    unset YDEPENDED_PACKAGES
    unset NDEPENDED_PACKAGES

    AVAILABLE_PACKAGES=$(__list_available_packages)

    for item in test v8 webrtc
    do
        AVAILABLE_PACKAGES=$(printf '%s\n' "$AVAILABLE_PACKAGES" | sed "s|^$item$||")
    done

    for x in $AVAILABLE_PACKAGES
    do
        YDEPENDED_PACKAGES="$YDEPENDED_PACKAGES $(__get_packages_that_are_directly_depended_by_the_given_package "$x")"
    done

    YDEPENDED_PACKAGES=$(printf '%s\n' "$YDEPENDED_PACKAGES" | tr ' ' '\n' | sort | uniq)

    echo YDEPENDED_PACKAGES=$YDEPENDED_PACKAGES

    unset AVAILABLE_PACKAGES_COUNT

    AVAILABLE_PACKAGES_COUNT="$(list_length $AVAILABLE_PACKAGES)"

    echo $AVAILABLE_PACKAGES_COUNT

    I=0
    J=0
    K=0

    for x in $AVAILABLE_PACKAGES
    do
        I=$(expr "$I" + 1)
        K=$(expr "$K" + 1)

        EXIST=n

        for y in $YDEPENDED_PACKAGES
        do
            if [ "$x" = "$y" ] ; then
                EXIST=y
                break
            fi
        done

        if [ "$EXIST" = n ] ; then
            if [ -z "$NDEPENDED_PACKAGES" ] ; then
                NDEPENDED_PACKAGES="$x"
            else
                NDEPENDED_PACKAGES="$NDEPENDED_PACKAGES $x"
            fi
        fi

        if [ "$I" -eq "$AVAILABLE_PACKAGES_COUNT" ] || [ "$K" -eq "$GROUP_SIZE" ] ; then
            unset OUTPUT_FILEPATH

            J=$(expr "$J" + 1)
            OUTPUT_FILEPATH="$OUTPUT_DIR/ci$J.yml"
            NDEPENDED_PACKAGES=$(printf '%s\n' "$NDEPENDED_PACKAGES" | tr ' ' ,)

            echo
            run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
            sed_in_place "s/INDEX/$J/"                          "$OUTPUT_FILEPATH"
            sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"       "$OUTPUT_FILEPATH"

            unset NDEPENDED_PACKAGES

            K=0
        fi
    done
}

__list_available_packages() {
    for FORMULA_REPO_NAME in $(__list_formula_repositories | cut -d= -f1)
    do
        find "$MY_FORMULA_REPO_DIR/$FORMULA_REPO_NAME/formula" -maxdepth 1 -type f -name '*.yml' -exec basename {} \; | sed -e 's|\.yml$||' | sort | uniq || return 1
    done
}

__list_installed_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" > /dev/null || return 1
    else
        return 0
    fi

    for packageName in $(ls)
    do
        if is_package_installed "$packageName" ; then
            printf '%s\n' "$packageName"
        fi
    done
}

__list__outdated_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" > /dev/null || return 1
    else
        return 0
    fi

    for packageName in $(ls)
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        printf '%s\n' "$packageName"
    done
}

# __tree_the_given_installed_package <PACKAGE-NAME> [TREE-OPTIONS]
  __tree_the_given_installed_package() {
    [ -z "$1" ] && {
        error "__tree_the_given_installed_package <PACKAGE-NAME> [TREE-OPTIONS], <PACKAGE-NAME> is not given."
        return 1
    }

    is_package_installed "$1" || {
        error "package [$1] is not installed."
        return 1
    }

    run tree $(shiftn 1 $@) "$MY_INSTALL_DIR/$1"
}

# __uninstall_the_given_packages <PACKAGE-NAME>...
  __uninstall_the_given_packages() {
    unset USER_SPECIFIED_PACKAGES

    while [ -n "$1" ]
    do
        case "$1" in
            -x|--xtrace)
                ;;
            -*) die "__uninstall_the_given_packages <PACKAGE-NAME>..., unrecognized option: $1"
                ;;
            *)  USER_SPECIFIED_PACKAGES="$USER_SPECIFIED_PACKAGES $1"
        esac
        shift
    done

    [ -z "$USER_SPECIFIED_PACKAGES" ] && {
        error "__uninstall_the_given_packages <PACKAGE-NAME>..., <PACKAGE-NAME> is not given."
        return 1
    }

    for packageName in $USER_SPECIFIED_PACKAGES
    do
        if is_package_installed "$packageName" ; then
            run rm -rf "$MY_INSTALL_DIR/$packageName"
        fi
    done
}

__reinstall_the_given_packages() {
    inspect_install_arguments $@

    [ -z "$USER_SPECIFIED_PACKAGES" ] && {
        error "__reinstall_the_given_packages <PACKAGE-NAME>..., <PACKAGE-NAME> is not given."
        return 1
    }

    for packageName in $USER_SPECIFIED_PACKAGES
    do
        is_package_available "$packageName" || {
            error "package [$packageName] is not available."
            return 1
        }
        is_package_installed "$packageName" || {
            error "package [$packageName] is not installed."
            return 1
        }
    done

    for INSTALLING_PACKAGE in $USER_SPECIFIED_PACKAGES
    do
        [ -d "$MY_BACKUP_DIR" ] || {
            install -d "$MY_BACKUP_DIR" || return 1
        }

        mv "$MY_INSTALL_DIR/$INSTALLING_PACKAGE" "$MY_BACKUP_DIR/$INSTALLING_PACKAGE" || return 1

        (__install_the_given_package "$INSTALLING_PACKAGE") || return 1

        rm -rf "$MY_BACKUP_DIR/$INSTALLING_PACKAGE" || return 1
    done
}

__upgrade_packages() {
    inspect_install_arguments $@

    if [ -z "$USER_SPECIFIED_PACKAGES" ] ; then
        USER_SPECIFIED_PACKAGES=$(__list__outdated_packages)
    fi

    for packageName in $USER_SPECIFIED_PACKAGES
    do
        is_package_available "$packageName" || {
            error "package [$packageName] is not available."
            return 1
        }
        is_package_installed "$packageName" || {
            error "package [$packageName] is not installed."
            return 1
        }
    done

    for INSTALLING_PACKAGE in $USER_SPECIFIED_PACKAGES
    do
        [ -d "$MY_BACKUP_DIR" ] || {
            install -d "$MY_BACKUP_DIR" || return 1
        }

        mv "$MY_INSTALL_DIR/$INSTALLING_PACKAGE" "$MY_BACKUP_DIR/$INSTALLING_PACKAGE" || return 1

        (__install_the_given_package "$INSTALLING_PACKAGE") || return 1

        rm -rf "$MY_BACKUP_DIR/$INSTALLING_PACKAGE" || return 1
    done
}

__cleanup() {
    [ -d "$MY_CACHE_DIR/src" ] || return 0
    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" || return 1
        for item in $(ls)
        do
            if [ -f "$item" ] ; then
                case $item in
                    *.yml)
                        __load_formula_of_the_given_package $(printf '%s\n' "$item" | sed 's/\.yml//g')
                esac
            fi
        done
    done
    success "Done."
}

__search_packages() {
    [ -z "$1" ] && {
        error "please specify a keyword."
        return 1
    }

    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        find "$MY_FORMULA_REPO_DIR/$repo/formula" -maxdepth 1 -type f -name '*.yml' -exec basename {} \; | sed -e 's|\.yml$||' | grep "$*"
    done
}

__compare_versions_with_brew() {
    get_brew_package_name_from_my_package_name() {
        case $1 in
            file)     printf '%s\n' 'file-formula' ;;
            delta)    printf '%s\n' 'git-delta' ;;
            gmake)    printf '%s\n' 'make'      ;;
            gtar)     printf '%s\n' 'gnu-tar'   ;;
            libjxl)   printf '%s\n' 'jpeg-xl'   ;;
            blake3)   printf '%s\n' 'b3sum'     ;;
            libwebp)  printf '%s\n' 'webp'      ;;
            proj7)    printf '%s\n' 'proj@7'    ;;
            openssl)  printf '%s\n' 'openssl@1.1';;
            freetype2)printf '%s\n' 'freetype'  ;;
            freetype2-with-harfbuzz)
                      printf '%s\n' 'freetype'  ;;
            gnu-coreutils)
                      printf '%s\n' 'coreutils' ;;
            libmediainfo|mediainfo)
                      printf '%s\n' 'media-info';;
            tcl-core) printf '%s\n' 'tcl-tk'    ;;
            *)        printf '%s\n' "$1"
        esac
    }

    set -e

    cd "$MY_HOME_DIR/repos.d/offical/formula"

    for item in $(find . -maxdepth 1 -type f -name '*.yml' -exec basename {} \; | sed -e 's|\.yml$||' | sort | uniq)
    do
        __load_formula_of_the_given_package "$item"
        BREW_PKG_NMAE="$(get_brew_package_name_from_my_package_name $PACKAGE_NAME)"
        if brew info "$BREW_PKG_NMAE" > /dev/null 2>&1 ; then
            BREW_PKG_VERS=$(brew info "$BREW_PKG_NMAE" 2> /dev/null | head -n 1 | sed -e 's|^==> .*: ||' -e 's|stable ||' | cut -d ' ' -f1)
            if version_match "$BREW_PKG_VERS" gt "$PACKAGE_VERSION" ; then
                printf "${COLOR_RED}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$BREW_PKG_NMAE" "$BREW_PKG_VERS"
            else
                :
                #printf "${COLOR_GREEN}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$BREW_PKG_NMAE" "$BREW_PKG_VERS"
            fi
        else
            printf "${COLOR_BLUE}%-10s %-10s  |${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION"
        fi
    done
}

__show_or_open_homepage_of_the_given_package() {
    unset ACTION
    unset PACKAGE

    while [ -n "$1" ]
    do
        case $1 in
            --open)
                ACTION=open
                ;;
            -*|--*)
                die "unrecognized argument: 41"
                ;;
            *)  if [ -z "$PACKAGE" ] ; then
                    PACKAGE=$1
                else
                    die "too many packages given."
                fi
        esac
        shift
    done

    if [ "$ACTION" = open ] ; then
        __open_homepage_of_the_given_package $PACKAGE
    else
        __show_homepage_of_the_given_package $PACKAGE
    fi
}

__show_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        __load_formula_of_the_given_package "$1"
    fi

    printf '%s\n' "$PACKAGE_WEBPAGE"
}

__open_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        __load_formula_of_the_given_package "$1"
    fi
    
    if command -v open > /dev/null ; then
        run "open '$PACKAGE_WEBPAGE'"
    elif command -v termux-open-url > /dev/null ; then
        run "termux-open-url '$PACKAGE_WEBPAGE'"
    else
        warn "I don't konw how to open"
    fi
}

# __show_packages_depended_by_the_given_package <PACKAGE-NAME> [--format=<list|json|graph>] [--brief] [-o <OUTPUT-FILE-PATH>]
__show_packages_depended_by_the_given_package() {
    [ -z "$1" ] && {
        error "__show_packages_depended_by_the_given_package <PACKAGE-NAME> [--format=<list|json|graph>] [--brief] [-o <OUTPUT-FILE-PATH>], <PACKAGE-NAME> is not given."
        return 1
    }

    PACKAGE_NAME="$1"

    shift

    unset OUTPUT_FILEPATH
    unset OUTPUT_FORMAT
    unset OUTPUT_BRIEF
    unset RECURSIVE

    while [ -n "$1" ]
    do
        case $1 in
            --format=list)
                OUTPUT_FORMAT=list
                ;;
            --format=json)
                OUTPUT_FORMAT=json
                ;;
            --format=dot)
                OUTPUT_FORMAT=dot
                ;;
            --format=txt)
                OUTPUT_FORMAT=txt
                ;;
            --format=png)
                OUTPUT_FORMAT=png
                ;;
            --format=*)
                OUTPUT_FORMAT=$(getvalue $1)
                die "unsupported format: $OUTPUT_FORMAT"
                ;;
            --brief)
                OUTPUT_BRIEF=yes
                ;;
            -r) RECURSIVE=yes ;;
            -x) set -x ;;
            -o)
                if [ -z "$2" ] ; then
                    die "-o <OUTPUT-FILE-PATH>, <OUTPUT-FILE-PATH> must not be empty."
                else
                    OUTPUT_FILEPATH="$2"
                    shift
                fi
                ;;
            *)  die "$_0 depends <PACKAGE-NAME> [--format=<list|json|graph>] [--brief] [-o <OUTPUT-FILE-PATH>], unrecognized argumet: $1"
        esac
        shift
    done

    if [ -z "$OUTPUT_FORMAT" ] ; then
        OUTPUT_FORMAT=list
    fi

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        if [ "$OUTPUT_FORMAT" = 'png' ] ; then
            die "you want png file, but -o <OUTPUT-FILE-PATH> option is not given."
        fi

        OUTPUT_FILEPATH=/dev/tty
    else
        if [ "$OUTPUT_FORMAT" = 'png' ] && [ "$OUTPUT_FILEPATH" = '/dev/tty' ] ; then
            die "you want png file, /dev/tty is not allowed."
        fi
    fi

    case $OUTPUT_FORMAT in
        list)
            unset RECURSIVE_DEPENDENT_PACKAGES
            RECURSIVE_DEPENDENT_PACKAGES=$(__get_packages_that_are_recursively_depended_by_the_given_package "$PACKAGE_NAME")

            if [ -z "$RECURSIVE_DEPENDENT_PACKAGES" ] ; then
                return 0
            fi

            unset OUTPUT_CONTENT

            if [ "$OUTPUT_BRIEF" = yes ] ; then
                OUTPUT_CONTENT="$RECURSIVE_DEPENDENT_PACKAGES"
            else
                for DEPENDENCY_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
                do
                    unset DEPENDENCY_PACKAGE_DIRECT_DEPS
                    DEPENDENCY_PACKAGE_DIRECT_DEPS=$(__get_packages_that_are_directly_depended_by_the_given_package "$DEPENDENCY_PACKAGE_NAME")
                    DEPENDENCY_PACKAGE_DIRECT_DEPS=$(printf '%s\n' "$DEPENDENCY_PACKAGE_DIRECT_DEPS" | tr ' ' ',')

                    unset LINE
                    LINE=$(printf 'name:%-15s dependencies:%s\n' "$DEPENDENCY_PACKAGE_NAME" "$DEPENDENCY_PACKAGE_DIRECT_DEPS")
                    if [ -z "$OUTPUT_CONTENT" ] ; then
                        OUTPUT_CONTENT="$LINE"
                    else
                        OUTPUT_CONTENT="$OUTPUT_CONTENT
$LINE"
                    fi
                done
            fi

            if [ "$OUTPUT_FILEPATH" = '/dev/tty' ] ; then
                printf '%s\n' "$OUTPUT_CONTENT"
            else
                unset OUTPUT_DIR

                case $3 in
                    /*) OUTPUT_DIR="$(dirname      "$3")" ;;
                     *) OUTPUT_DIR="$(dirname "$PWD/$3")" ;;
                esac

                if [ !      -d "$OUTPUT_DIR" ] ; then
                    install -d "$OUTPUT_DIR"
                fi

                printf '%s\n' "$OUTPUT_CONTENT" > "$OUTPUT_FILEPATH"
            fi
            ;;
        json)
            unset RECURSIVE_DEPENDENT_PACKAGES
            RECURSIVE_DEPENDENT_PACKAGES=$(__get_packages_that_are_recursively_depended_by_the_given_package "$PACKAGE_NAME")

            JSON_ARRAY='['

            if [ "$OUTPUT_BRIEF" = yes ] ; then
                for DEPENDENCY_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
                do
                    JSON_ARRAY="$JSON_ARRAY\"$DEPENDENCY_PACKAGE_NAME\","
                done
            else
                for DEPENDENCY_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
                do
                    unset DEPENDENCY_PACKAGE_DIRECT_DEPS
                    DEPENDENCY_PACKAGE_DIRECT_DEPS=$(__get_packages_that_are_directly_depended_by_the_given_package "$DEPENDENCY_PACKAGE_NAME" | tr ' ' ',')

                    JSON_ARRAY="$JSON_ARRAY{\"name\":\"$DEPENDENCY_PACKAGE_NAME\",\"dependencies\":\"$DEPENDENCY_PACKAGE_DIRECT_DEPS\"},"
                done
            fi

            JSON_ARRAY=$(printf '%s\n' "$JSON_ARRAY" | sed 's|,$||')

            JSON_ARRAY="$JSON_ARRAY]"

            if [ "$OUTPUT_FILEPATH" = '/dev/tty' ] ; then
                printf '%s\n' "$JSON_ARRAY"
            else
                unset OUTPUT_DIR

                case $3 in
                    /*) OUTPUT_DIR="$(dirname      "$3")" ;;
                     *) OUTPUT_DIR="$(dirname "$PWD/$3")" ;;
                esac

                if [ !      -d "$OUTPUT_DIR" ] ; then
                    install -d "$OUTPUT_DIR"
                fi

                printf '%s\n' "$JSON_ARRAY" > "$OUTPUT_FILEPATH"
            fi
            ;;
        dot)
            __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" dot "$OUTPUT_FILEPATH"
            ;;
        txt)
            __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" txt "$OUTPUT_FILEPATH"
            ;;
        png)
            __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" png "$OUTPUT_FILEPATH"

            if [ "$OUTPUT_FILEPATH" != '/dev/tty' ] ; then
                for item in open feh eog lsix
                do
                    if command -v "$item" > /dev/null ; then
                        "$item" "$OUTPUT_FILEPATH" &
                        return 0
                    fi
                done
            fi
    esac
}

# __logs_the_given_installed_package <PACKAGE-NAME>
  __logs_the_given_installed_package() {
    [ -z "$1" ] && {
        error "$_0 logs <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    __logs_the_given_dir() {
        for item in $(ls "$1")
        do
            item="$1/$item"
            if [ -d "$item" ] ; then
                continue
            fi
            if [ "$VIEWER" = 'bat' ] ; then
                case $item in
                    *.png) ;;
                    */installed-metadata-ppkg)
                        bat -l yaml "$item" ;;
                    *)  bat "$item"
                esac
            else
                "$VIEWER" "$item"
            fi
        done
    }

    __logs_the_given_dir "$MY_INSTALL_DIR/$1"
    __logs_the_given_dir "$MY_INSTALL_DIR/$1/$2/share/log"

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

# examples:
# __pack_the_given_installed_package <PACKAGE-NAME> <TYPE> [--keep-packing-dir]
# __pack_the_given_installed_package    autoconf    tar.xz
  __pack_the_given_installed_package() {
    __load_installed_metadata_of_the_given_package "$1"

    case $2 in
        7z) ;;
        zip)
            ;;
        tar.gz)
            ;;
        tar.xz)
            ;;
        tar.bz2)
            ;;
        '')die "$_0 pack <PACKAGE-NAME> <TYPE>, <TYPE> must not be empty." ;;
        *) die "$_0 pack <PACKAGE-NAME> <TYPE>, unsupported TYPE: $2, the supported types are 7z zip tar.gz tar.xz tar.bz2."
    esac

    for option in $(shiftn 2 $@)
    do
        case $option in
            --keep-packing-dir)
                KEEP_PACKING_DIR=yes
                ;;
            -x|--xtrace)
                ;;
            *)  die "$_0 pack <PACKAGE-NAME> <TYPE> [--keep-packing-dir], unrecognized option: $option"
        esac
    done

    INSTALLED_PACKAGE_NAME="$1"

    if [ -z "$INSTALLED_PACKAGE_VERSION" ] ; then
        INSTALLED_PACKAGE_VERSION="$INSTALLED_PACKAGE_DATETIME"
    fi

    if [ "$NATIVE_OS_KIND" = darwin ] ; then
        NATIVE_OS_KIND=macos
    fi

    if [ "$NATIVE_OS_ARCH" = 'amd64' ] ; then
        NATIVE_OS_ARCH=x86_64
    elif [ "$NATIVE_OS_ARCH" = 'aarch64' ] ; then
        NATIVE_OS_ARCH=arm64
    fi

    unset PACKED_DIR_NAME
    if [ -z "$NATIVE_OS_LIBC" ] ; then
        PACKED_DIR_NAME="$INSTALLED_PACKAGE_NAME-$INSTALLED_PACKAGE_VERSION-$NATIVE_OS_KIND-$NATIVE_OS_ARCH"
    else
        PACKED_DIR_NAME="$INSTALLED_PACKAGE_NAME-$INSTALLED_PACKAGE_VERSION-$NATIVE_OS_KIND-$NATIVE_OS_ARCH"
    fi

    unset PACKED_FILE_NAME
    PACKED_FILE_NAME="$PACKED_DIR_NAME.$2"

    step "create packing directory"
    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    PACKING_DIR=$(mktemp -d)

    step "change to packing directory"
    run cd $PACKING_DIR

    step "make link refer to installed package root dir"
    run ln -s "$MY_INSTALL_DIR/$INSTALLED_PACKAGE_NAME" "$PACKED_DIR_NAME"

    step "packing"
    case $2 in
        7z)  run 7za a -t7z -r "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        zip) run zip -9 -r     "$PACKED_FILE_NAME" "$PACKED_DIR_NAME"   ;;
        tar.gz)  run tar zvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        tar.xz)  run tar Jvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        tar.bz2) run tar jvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
    esac

    step "check integrity of packed file"
    case $2 in
        7z)    run 7za t -t7z "$PACKED_FILE_NAME" ;;
        zip)   run unzip -t   "$PACKED_FILE_NAME" ;;
        tar.*) run tar   -tf  "$PACKED_FILE_NAME" ;;
    esac

    step "show size of packed file"
    run "du -sh $PACKED_FILE_NAME | cut -f1"

    if [ ! -d "$MY_CACHE_DIR/bin" ] ; then
        step "create cached binary dir"
        run install -d "$MY_CACHE_DIR/bin"
    fi

    step "copy packed file to cached dir"
    run cp "$PACKED_FILE_NAME" "$MY_CACHE_DIR/bin/"

    if [ "$KEEP_PACKING_DIR" = yes ] ; then
        echo
        note "the work dir [$PACKING_DIR] is not deleted as --keep-packing-dir option is given."
    else
        step "delete packing directory"
        run rm -rf $PACKING_DIR
    fi
}

# this fuction should be run in subshell
# __get_packages_that_are_directly_depended_by_the_given_package <PACKAGE-NAME>
  __get_packages_that_are_directly_depended_by_the_given_package() {
      __load_formula_of_the_given_package "$1" && printf '%s\n' "$PACKAGE_DEP_PKG"
}

# this fuction should be run in subshell
#
# __get_packages_that_are_recursively_depended_by_the_given_packages <PACKAGE-NAME>...
  __get_packages_that_are_recursively_depended_by_the_given_packages() {
      [ -z "$1" ] && {
          error "__get_packages_that_are_recursively_depended_by_the_given_packages <PACKAGE-NAME>..., <PACKAGE-NAME> is not given."
          return 1
      }

      __get_packages_that_are_recursively_depended_by_the_given_package ";$(printf '%s\n' "$*" | tr ' ' ';')"
}

# this fuction should be run in subshell
#
# __get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME>
# __get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME> internal
  __get_packages_that_are_recursively_depended_by_the_given_package() {
    [ -z "$1" ] && {
        error "__get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME> [internal], <PACKAGE-NAME> is not given."
        return 1
    }

    unset DIRECT_DEPENDENT_PACKAGES

    case $1 in
        *\;*) DIRECT_DEPENDENT_PACKAGES=$(printf '%s\n' "$1" | tr ';' ' ') ;;
        *)    DIRECT_DEPENDENT_PACKAGES=$(__get_packages_that_are_directly_depended_by_the_given_package "$1")
    esac

    [ "$2" != internal ] && {
        DEPTH=1
        RESULT=
    }

    DEPTH=$(expr "$DEPTH" + 1)

    for DIRECT_DEPENDENT_PACKAGE_NAME in $DIRECT_DEPENDENT_PACKAGES
    do
        is_package_available "$DIRECT_DEPENDENT_PACKAGE_NAME" || {
            error "package [$DIRECT_DEPENDENT_PACKAGE_NAME] is not available."
            return 1
        }

        if [ "$(printf '%s\n' "$RESULT" | sed -n "/^$DIRECT_DEPENDENT_PACKAGE_NAME$/p")" = "$DIRECT_DEPENDENT_PACKAGE_NAME" ] ; then
            RESULT=$(printf '%s\n' "$RESULT" | sed "/^$DIRECT_DEPENDENT_PACKAGE_NAME$/d")
        fi

        if [ -z "$RESULT" ] ; then
            RESULT="$DIRECT_DEPENDENT_PACKAGE_NAME"
        else
            RESULT="$DIRECT_DEPENDENT_PACKAGE_NAME
$RESULT"
        fi

        __get_packages_that_are_recursively_depended_by_the_given_package "$DIRECT_DEPENDENT_PACKAGE_NAME" internal
    done

    DEPTH=$(expr "$DEPTH" - 1)

    if [ "$DEPTH" -eq 1 ] ; then
        printf '%s\n' "$RESULT"
    fi
}

__get_dot_file_contents() {
    for PKG in $@
    do
        unset DIRECT_DEPENDENT_PACKAGES
        DIRECT_DEPENDENT_PACKAGES="$(__get_packages_that_are_directly_depended_by_the_given_package "$PKG")"
        if [ -n "$DIRECT_DEPENDENT_PACKAGES" ] ; then
            printf '"%s" -> { "%s" }\n' "$PKG" "$(printf '%s\n' "$DIRECT_DEPENDENT_PACKAGES" | sed 's/ /" "/g')"
            __get_dot_file_contents $DIRECT_DEPENDENT_PACKAGES
        fi
    done
}

# __gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> <OUTPUT-FILEPATH>
__gen_dependency_graph_recursively_depended_by_the_given_package() {
    unset DIRECT_DEPENDENT_PACKAGES
    DIRECT_DEPENDENT_PACKAGES="$(__get_packages_that_are_directly_depended_by_the_given_package "$1")"

    if [ -z "$DIRECT_DEPENDENT_PACKAGES" ] ; then
        return 0
    fi

    case $2 in
        dot|txt|png) ;;
        '') die "__gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> <OUTPUT-FILEPATH>, format must not be empty." ;;
        *)  die "__gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> <OUTPUT-FILEPATH>, unrecognized format: $2"
    esac

    if [ -z "$3" ] ; then
        die "__gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> <OUTPUT-FILEPATH>, <OUTPUT-FILEPATH> must be not empty."
    fi

    unset GEN_DEPENDENCY_GRAPH_WORKING_DIR
    unset GEN_DEPENDENCY_GRAPH_DOT_FILEPATH

    GEN_DEPENDENCY_GRAPH_WORKING_DIR=$(mktemp -d) || return 1
    GEN_DEPENDENCY_GRAPH_DOT_FILEPATH="$GEN_DEPENDENCY_GRAPH_WORKING_DIR/dependencies.dot"
    GEN_DEPENDENCY_GRAPH_TXT_FILEPATH="$GEN_DEPENDENCY_GRAPH_WORKING_DIR/dependencies.txt"
    GEN_DEPENDENCY_GRAPH_PNG_FILEPATH="$GEN_DEPENDENCY_GRAPH_WORKING_DIR/dependencies.png"

    printf 'digraph G {\n'       >  "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
    __get_dot_file_contents "$1" >> "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
    printf '}\n'                 >> "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"

    if [ "$3" != '/dev/tty' ] ; then
        unset GEN_DEPENDENCY_GRAPH_OUTPUT_DIR

        case $3 in
            /*) GEN_DEPENDENCY_GRAPH_OUTPUT_DIR="$(dirname      "$3")" ;;
             *) GEN_DEPENDENCY_GRAPH_OUTPUT_DIR="$(dirname "$PWD/$3")" ;;
        esac

        if [ !      -d "$GEN_DEPENDENCY_GRAPH_OUTPUT_DIR" ] ; then
            install -d "$GEN_DEPENDENCY_GRAPH_OUTPUT_DIR" || return 1
        fi
    fi

    case $2 in
        dot)
            if [ "$3" = '/dev/tty' ] ; then
                cat   "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            else
                cp -f "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH" "$3"
            fi
            ;;
        txt)
            # https://github.com/ggerganov/dot-to-ascii
            curl \
                -o "$GEN_DEPENDENCY_GRAPH_TXT_FILEPATH" \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$(cat $GEN_DEPENDENCY_GRAPH_DOT_FILEPATH)" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php" || return 1

            if [ "$3" = '/dev/tty' ] ; then
                cat   "$GEN_DEPENDENCY_GRAPH_TXT_FILEPATH"
            else
                cp -f "$GEN_DEPENDENCY_GRAPH_TXT_FILEPATH" "$3"
            fi
            ;;
        png)
            (main install graphviz) || return 1

            if command -v fc-match > /dev/null ; then
                # Error: fontconfig: Couldn't find font.
                if [ -z "$(fc-match)" ] ; then
                    fetch 'https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true' --output-dir="$HOME/.fonts" --output-name='Meslo LG M DZ Regular Nerd Font Complete Mono.ttf' || return 1
                fi
            fi

            run dot -Tpng -o "$3" "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            ;;
    esac
}

__install_the_given_packages() {
    inspect_install_arguments $@

    [ -z "$USER_SPECIFIED_PACKAGES" ] && {
        error "$_0 install <PACKAGE-NAME>..., <PACKAGE-NAME> is not given."
        return 1
    }

    unset RECURSIVE_DEPENDENT_PACKAGES
    RECURSIVE_DEPENDENT_PACKAGES="$(__get_packages_that_are_recursively_depended_by_the_given_packages $USER_SPECIFIED_PACKAGES)"

    if [ $(list_length $RECURSIVE_DEPENDENT_PACKAGES) -gt 1 ] ; then
        RECURSIVE_DEPENDENT_PACKAGES="$(printf '%s\n' "$RECURSIVE_DEPENDENT_PACKAGES" | tr '\n' ' ')"
        printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF to install$COLOR_GREEN $RECURSIVE_DEPENDENT_PACKAGES $COLOR_OFF\n"
    fi

    for INSTALLING_PACKAGE in $RECURSIVE_DEPENDENT_PACKAGES
    do
        if is_package_installed "$INSTALLING_PACKAGE" ; then
            if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_QUIET" ] ; then
                printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$INSTALLING_PACKAGE"
            fi
        else
            (__install_the_given_package "$INSTALLING_PACKAGE")
        fi
    done
}

# Note: this function must run in a subshell
__install_the_given_package() {
    printf '%b\n' "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}${1}${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"

    # brew install meson
    # Error: The current work directory doesn't exist, cannot proceed.
    # beacuse previous package's work direcotory is deleted.
    cd ~

    unset PACKAGE_INSTALLING_TOP_DIR
    unset PACKAGE_INSTALLING_SRC_DIR
    unset PACKAGE_INSTALLING_BST_DIR
    unset PACKAGE_INSTALLING_FIX_DIR
    unset PACKAGE_INSTALLING_RES_DIR
    unset PACKAGE_INSTALLING_BIN_DIR
    unset PACKAGE_INSTALLING_INC_DIR
    unset PACKAGE_INSTALLING_LIB_DIR
    unset PACKAGE_INSTALLING_TMP_DIR

    unset PACKAGE_INSTALL_DIR

    step "view formula"
    __view_formula_of_the_given_package "$1" --paging=never

    step "load formula"
    __load_formula_of_the_given_package "$1"

    #########################################################################################

    if [ -z "$PACKAGE_DEP_PKG" ] ; then
        RECURSIVE_DEPENDENT_PACKAGES=
    else
        step "calculating dependency tree of $1"
        RECURSIVE_DEPENDENT_PACKAGES="$(__get_packages_that_are_recursively_depended_by_the_given_packages $PACKAGE_DEP_PKG)"
    fi

    __setup_PATH_env

    for PKG in $RECURSIVE_DEPENDENT_PACKAGES
    do
        if [ -d "$MY_INSTALL_DIR/$PKG/bin" ] ; then
            bppend_to_PATH "$MY_INSTALL_DIR/$PKG/bin"
        fi
    done

    echo PATH:
    printf '%s\n' "$PATH" | tr ':' '\n'

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_GMAKE" = yes ] && [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] && [ "$BEAR_ENABLED" = yes ] ; then
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP bear"
    fi

    if [ "$CCACHE_ENABLED" = yes ] ; then
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ccache"
    fi

    #########################################################################################

    if [ -n "$PACKAGE_DEP_UPP" ] ; then
        step "install depentent tools via uppm"

        run uppm env
        run uppm update

        for item in $PACKAGE_DEP_UPP
        do
            run uppm install "$item"
            bppend_to_PATH "$("$MY_HOME_DIR/core/bin/uppm" info "$item" installed-dir)/bin"
        done
    fi

    #########################################################################################

    if [ -n "$PACKAGE_DEP_PYM" ] ; then
        step "install depentent tools via pip3"

        run pip3 --version
        run pip3 install --upgrade pip setuptools wheel
        run pip3 --version

        for item in $PACKAGE_DEP_PYM
        do
            run pip3 install "$item" --upgrade
        done
    fi

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        command -v rustup > /dev/null || {
            # https://www.rust-lang.org/tools/install
            note "${COLOR_GREEN}rustup cargo rustc${COLOR_OFF} ${COLOR_YELLOW}commands are required, but it is not found on this machine, I will install it via running shell script.${COLOR_OFF}"

            if [ -f    "$MY_HOME_DIR/tmp.d/rustup-init.sh" ] ; then
                run rm "$MY_HOME_DIR/tmp.d/rustup-init.sh" || return 1
            fi

            fetch 'https://sh.rustup.rs' --output-path="$MY_HOME_DIR/tmp.d/rustup-init.sh" || return 1

            run bash "$MY_HOME_DIR/tmp.d/rustup-init.sh" -y || return 1

            export CARGO_HOME=$HOME/.cargo
            export PATH="$CARGO_HOME/bin:$PATH"
        }
    fi

    #########################################################################################

    step "create installing relevant directories"

    PACKAGE_INSTALLING_TOP_DIR="$MY_HOME_DIR/installing/$1"
    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_INSTALLING_TOP_DIR/src"
    PACKAGE_INSTALLING_FIX_DIR="$PACKAGE_INSTALLING_TOP_DIR/fix"
    PACKAGE_INSTALLING_RES_DIR="$PACKAGE_INSTALLING_TOP_DIR/res"
    PACKAGE_INSTALLING_BIN_DIR="$PACKAGE_INSTALLING_TOP_DIR/bin"
    PACKAGE_INSTALLING_INC_DIR="$PACKAGE_INSTALLING_TOP_DIR/inc"
    PACKAGE_INSTALLING_LIB_DIR="$PACKAGE_INSTALLING_TOP_DIR/lib"
    PACKAGE_INSTALLING_TMP_DIR="$PACKAGE_INSTALLING_TOP_DIR/tmp"

    if [ -d "$PACKAGE_INSTALLING_TOP_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALLING_TOP_DIR"
    fi

    run install -d "$PACKAGE_INSTALLING_SRC_DIR"
    run install -d "$PACKAGE_INSTALLING_FIX_DIR"
    run install -d "$PACKAGE_INSTALLING_RES_DIR"
    run install -d "$PACKAGE_INSTALLING_BIN_DIR"
    run install -d "$PACKAGE_INSTALLING_INC_DIR"
    run install -d "$PACKAGE_INSTALLING_LIB_DIR"
    run install -d "$PACKAGE_INSTALLING_TMP_DIR"

    #########################################################################################

    if [ "$PACKAGE_PREPARE_ACTIONS" != null ] ; then
        cat > "$PACKAGE_INSTALLING_BIN_DIR/prepare.sh" <<EOF
prepare() {
$PACKAGE_PREPARE_ACTIONS
}
EOF
        . "$PACKAGE_INSTALLING_BIN_DIR/prepare.sh"
    fi

    if [ "$PACKAGE_INSTALL_ACTIONS" != null ] ; then
        cat > "$PACKAGE_INSTALLING_BIN_DIR/install.sh" <<EOF
build() {
$PACKAGE_INSTALL_ACTIONS
}
EOF
        . "$PACKAGE_INSTALLING_BIN_DIR/install.sh"
    fi

    #########################################################################################

    if [ -z "$RECURSIVE_DEPENDENT_PACKAGES" ] ; then
        step "generating dependency tree of $1"

        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT="$PACKAGE_INSTALLING_TOP_DIR/dependencies.dot"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT="$PACKAGE_INSTALLING_TOP_DIR/dependencies.txt"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_PNG="$PACKAGE_INSTALLING_TOP_DIR/dependencies.png"

        __gen_dependency_graph_recursively_depended_by_the_given_package "$1" dot "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
        __gen_dependency_graph_recursively_depended_by_the_given_package "$1" txt "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT" || true
        # __gen_dependency_graph_recursively_depended_by_the_given_package "$1" png "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_PNG" || true

        if [ -f "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT" ] ; then
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT"
        fi
    fi

    #########################################################################################


    unset PKG_CONFIG

    PKG_CONFIG=$(command -v pkg-config || true)

    step "fetch resources if needed"
    __fetch_sources_of_the_given_package "$1"
    __fetch_patches_of_the_given_package "$1"

    case $PACKAGE_SRC_TYPE in
        dir)
            if [ "$PACKAGE_SRC_PATH" = '/dev/null' ] ; then
                :
            elif [ -d "$PACKAGE_SRC_PATH" ] ; then
                if [ -d "$PACKAGE_SRC_PATH/.git" ] && command -v git > /dev/null ; then
                    PACKAGE_GIT_SHA=$(cd "$PACKAGE_SRC_PATH" && git rev-parse HEAD || true)
                fi
                step "copy source files to the installing src directory"
                run cp -r "$PACKAGE_SRC_PATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            else
                die "src-url point to dir is not exist."
            fi
            ;;
        git)
            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                PACKAGE_GIT_SHA=$(cd "$PACKAGE_SRC_PATH" && git rev-parse HEAD)
            fi
            step "copy source files to the installing src directory"
            run cp -r "$PACKAGE_SRC_PATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        c|cxx)
            step "copy source files to the installing src directory"
            run cp    "$PACKAGE_SRC_PATH"   "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        zip)
            step "uncompressed source file to the installing src directory"
            run unzip "$PACKAGE_SRC_PATH" -d "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        tar.xz|tar.gz|tar.lz|tar.bz2)
            step "uncompressed source file to the installing src directory"
            run tar xf "$PACKAGE_SRC_PATH" -C "$PACKAGE_INSTALLING_SRC_DIR" --strip-components 1 --no-same-owner
            ;;
        *)  die "unrecognized extension : $PACKAGE_SRC_URL. the supported extensions are .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    if [ -n "$PACKAGE_FIX_TYPE" ] ; then
        case $PACKAGE_FIX_TYPE in
            patch)
                step "copy patch file to the installing fix directory"
                run cp    "$PACKAGE_FIX_PATH"   "$PACKAGE_INSTALLING_FIX_DIR"
                ;;
            zip)
                step "uncompressed patch file to the installing fix directory"
                run unzip "$PACKAGE_FIX_PATH" -d "$PACKAGE_INSTALLING_FIX_DIR"
                ;;
            tar.xz|tar.gz|tar.lz|tar.bz2)
                step "uncompressed patch file to the installing fix directory"
                run tar xf "$PACKAGE_FIX_PATH" -C "$PACKAGE_INSTALLING_FIX_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  die "unrecognized fix type : $PACKAGE_FIX_TYPE. the supported fix type are zip tar.xz tar.gz tar.lz tar.bz2"
        esac
    fi

    if [ -n "$PACKAGE_RES_TYPE" ] ; then
        case $PACKAGE_RES_TYPE in
            patch)
                step "copy res file to the installing res directory"
                run cp    "$PACKAGE_RES_PATH"   "$PACKAGE_INSTALLING_RES_DIR"
                ;;
            zip)
                step "uncompressed res file to the installing res directory"
                run unzip "$PACKAGE_RES_PATH" -d "$PACKAGE_INSTALLING_RES_DIR"
                ;;
            tar.xz|tar.gz|tar.lz|tar.bz2)
                step "uncompressed res file to the installing res directory"
                run tar xf "$PACKAGE_RES_PATH" -C "$PACKAGE_INSTALLING_RES_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  die "unrecognized res type : $PACKAGE_RES_TYPE. the supported res type are zip tar.xz tar.gz tar.lz tar.bz2"
        esac
    fi

    if [ -z "$PACKAGE_BSCRIPT" ] ; then
        PACKAGE_INSTALLING_BST_DIR="$PACKAGE_INSTALLING_SRC_DIR"
    else
        PACKAGE_INSTALLING_BST_DIR="$PACKAGE_INSTALLING_SRC_DIR/$PACKAGE_BSCRIPT"
    fi

    step "tree files of the installing top directory"
    run tree --dirsfirst -L 2 "$PACKAGE_INSTALLING_TOP_DIR"

    step "list files of the installing top directory"
    run ls -l "$PACKAGE_INSTALLING_TOP_DIR"

    step "list files of the installing src directory"
    run ls -l "$PACKAGE_INSTALLING_SRC_DIR"

    if [ -n "$PACKAGE_BSCRIPT" ] ; then
        step "list files of the installing build script directory"
        run ls -l "$PACKAGE_INSTALLING_BST_DIR"
    fi

    __config_build_variables "$1"
    __printf_build_variables "$1"

    if [ "$CCACHE_ENABLED" = yes ] ; then
        ccache -s > "$PACKAGE_INSTALLING_TOP_DIR/ccache-s.txt"
    fi

    [ -n "$RECURSIVE_DEPENDENT_PACKAGES" ] && {
        step2 "create symbolic links for dependency libs"
        case $LINK_TYPE in
            static-only|static-prefered) LINK_LIBRARY_TYPE=a  ;;
            shared-only|shared-prefered) LINK_LIBRARY_TYPE=so ;;
        esac

        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
        do
            DEPENDENT_PACKAGE_INSTALLED_LIBRARY_DIR="$MY_INSTALL_DIR/$DEPENDENT_PACKAGE_NAME/lib"
            if [ -d "$DEPENDENT_PACKAGE_INSTALLED_LIBRARY_DIR" ] ; then
                for item in $(find "$DEPENDENT_PACKAGE_INSTALLED_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -name "lib*.$LINK_LIBRARY_TYPE" -exec basename {} \;)
                do
                    if [ -e "$PACKAGE_INSTALLING_TOP_DIR/$item" ] ; then
                        continue
                    else
                        if [ ! -e "$PACKAGE_INSTALLING_LIB_DIR/$item" ] ; then
                            run ln -s "$DEPENDENT_PACKAGE_INSTALLED_LIBRARY_DIR/$item" "$PACKAGE_INSTALLING_LIB_DIR/$item"
                        fi
                    fi
                done
            fi
        done

        unset LINK_LIBRARY_TYPE
    }

    step "do some preparation works"
    if [ "$PWD" != "$PACKAGE_INSTALLING_BST_DIR" ] ; then
        run cd "$PACKAGE_INSTALLING_BST_DIR"
    fi
    if command -v prepare > /dev/null ; then
        prepare "$1"
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)
                warn "no prepare function defined in formula."
                run NOCONFIGURE=yes ./autogen.sh    || return 1
                ;;
            autotools)
                warn "no prepare function defined in formula."
                run autoreconf -ivf || return 1
                ;;
            *)  warn "no prepare function defined in formula, skipped."
        esac
    fi

    step "create symbolic link for CC and CXX to use ccache"
    if [ "$CCACHE_ENABLED" = yes ] ; then
        if [ -z "$CCACHE" ] ; then
            die "ccache is not installed."
        fi
        run ln -sf "$CCACHE" "$PACKAGE_INSTALLING_BIN_DIR/$(basename "$CC")"
        run ln -sf "$CCACHE" "$PACKAGE_INSTALLING_BIN_DIR/$(basename "$CXX")"
    else
        note "ccache is disabled, skipped."
    fi

    run ln -sf "$CC" "$PACKAGE_INSTALLING_BIN_DIR/cc"
    run ln -sf "$LD" "$PACKAGE_INSTALLING_BIN_DIR/ld"

    if [ "$DRYRUN" = yes ] ; then
        if [ -z "$SHELL" ] ; then
            SHELL=$(command -v zsh || command -v bash || command -v sh)
        fi
        exec "$SHELL" || return 1
    fi

    if [ -d "$PACKAGE_INSTALL_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALL_DIR" || return 1
    fi

    if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] ; then
        if [ "$PWD" != "$PACKAGE_INSTALLING_BST_DIR" ] ; then
            run cd "$PACKAGE_INSTALLING_BST_DIR" || return 1
        fi
    else
        run cd    "$PACKAGE_INSTALLING_TMP_DIR" || return 1
    fi

    export       CC_FOR_BUILD="$CC"
    export      CPP_FOR_BUILD="$CPP"
    export   CFLAGS_FOR_BUILD="$CFLAGS"
    export CPPFLAGS_FOR_BUILD="$CPPFLAGS"
    export  LDFLAGS_FOR_BUILD="$LDFLAGS"

    step "building"
    if command -v build > /dev/null ; then
        build $1
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)   configure ;;
            autotools) configure ;;
            configure) configure ;;
            cmake*)    cmakew ;;
            meson)     mesonw ;;
            ninja)     ninjaw clean && ninjaw && ninjaw install ;;
            gmake)     gmakew clean && gmakew && gmakew install ;;
            cargo)     cargow install ;;
            go)        gow ;;
        esac
    fi

    [ -d "$PACKAGE_INSTALL_DIR" ] || {
        error "installed nothing."
        return 1
    }

    if [ "$NATIVE_OS_KIND" = linux ] ; then
        for x in bin sbin
        do
            if [ -d "$PACKAGE_INSTALL_DIR/$x" ] ; then
                for y in $(ls "$PACKAGE_INSTALL_DIR/$x")
                do
                    FILEPATH="$PACKAGE_INSTALL_DIR/$x/$y"

                    if [ -d "$FILEPATH" ] ; then
                        continue
                    fi

                    unset FILE_HEADER_EXPACT
                    unset FILE_HEADER_ACTUAL

                    FILE_HEADER_ACTUAL="$(hexdump -n 20 -v -e '1/1 "%02X" ""' "$FILEPATH")"

                    case $FILE_HEADER_ACTUAL in
                        7F454C4602010100000000000000000003003E00)
                            # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
                            # unset PT_INTERP
                            # PT_INTERP="$(patchelf --print-interpreter "$FILEPATH" 2>/dev/null || true)"

                            if [ "$BUILD_TYPE" = release ] ; then
                                run "$STRIP" $STRIP_ARG "$FILEPATH" || true
                            fi
                    esac
                done
            fi
        done
    fi

    step "install logs"
    __install_logs "$1"

    if [ -d "$TARGET_INSTALL_DIR/lib" ] ; then
        step2 "adjust .la files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_la_files_for_the_given_target $@

        step2 "adjust .pc files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_pc_files_for_the_given_target $@
    fi

    step "record installed metadata"
    __record_installed_metadata_of_the_given_package "$1"

    step "record installed files"
    __record_installed_files_of_the_given_package "$1"

    if [ "$CCACHE_ENABLED" = yes ] ; then
        step "show ccache statistics summary"
        note "Before Build:"
        run  cat "$PACKAGE_INSTALLING_TOP_DIR/ccache-s.txt"
        note "After  Build:"
        run  ccache -s
    fi

    if [ "$KEEP_INSTALLING_DIR" != yes ] ; then
        step "delete the installing directory."
        run rm -rf "$PACKAGE_INSTALLING_TOP_DIR"
    fi

    __tree_the_given_installed_package "$1" $TREE_ARGS

    echo
    success "$1 have been installed successfully."
}

__config_build_variables() {
    step "config build variables"

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        unset DEVELOPER_DIR

        DEVELOPER_DIR="$(xcode-select -p)"

        if [ -d         "$DEVELOPER_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin" ] ; then
            export PATH="$DEVELOPER_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin:$PATH"
        else
            export PATH="$DEVELOPER_DIR/usr/bin:$PATH"
        fi

        # If -mmacosx-version-min is unspecified, the default deployment target is read from MACOSX_DEPLOYMENT_TARGET environment variable. This option only affects Darwin targets.
        # https://clang.llvm.org/docs/CommandGuide/clang.html#envvar-MACOSX_DEPLOYMENT_TARGET
        # https://clang.llvm.org/docs/CommandGuide/clang.html#cmdoption-mmacosx-version-min
        if [ -z "$MACOSX_DEPLOYMENT_TARGET" ] ; then
            MACOSX_DEPLOYMENT_TARGET="$(printf '%s\n' "$NATIVE_OS_VERS" | cut -d. -f1).$(printf '%s\n' "$NATIVE_OS_VERS" | cut -d. -f2)"
        fi

        export MACOSX_DEPLOYMENT_TARGET

        if [ -d     "$DEVELOPER_DIR/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk" ] ; then
            SYSROOT="$DEVELOPER_DIR/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
        else
            SYSROOT="$DEVELOPER_DIR/SDKs/MacOSX.sdk"
        fi

         CCFLAGS="-isysroot $SYSROOT -Qunused-arguments"
        CPPFLAGS="-isysroot $SYSROOT -Qunused-arguments"
         LDFLAGS="-isysroot $SYSROOT"
    else
        if [ "$LINK_TYPE" = static-only ] ; then
            if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
                CMAKE_EXE_LINKER_FLAGS=-static

                export  CFLAGS="$(printf '%s\n'  "$CFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
                export LDFLAGS="$(printf '%s\n' "$LDFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
            else
                CCFLAGS="$CCFLAGS -static --static"
                LDFLAGS="$LDFLAGS -static --static"
            fi
        fi

        # https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html

        LDFLAGS="$LDFLAGS -Wl,--as-needed -Wl,-z,muldefs -Wl,--allow-multiple-definition"
    fi

    CCFLAGS="$CFLAGS -fPIC -fno-common"

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        CCFLAGS="$CCFLAGS -v -Wl,-v"
        LDFLAGS="$LDFLAGS -v -Wl,-v"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        CCFLAGS="$CCFLAGS -Os -DNDEBUG"
        LDFLAGS="$LDFLAGS -Wl,-S"
    fi

    for TOOLNAME in $(list_tools_in_the_toolchain)
    do
        unset TOOLNAME_UPPERCASE
        TOOLNAME_UPPERCASE=$(printf '%s\n' "$TOOLNAME" | tr a-z A-Z)

        unset TOOLPATH
        TOOLPATH="$(eval echo \$${TOOLNAME_UPPERCASE})"

        if [ -z "$TOOLPATH" ] ; then
            case $TOOLNAME in
                cc)  TOOLPATH="$(command -v cc  || command -v gcc || command -v clang   || true)" ;;
                cxx) TOOLPATH="$(command -v c++ || command -v g++ || command -v clang++ || true)" ;;
                cpp) TOOLPATH="$CC -E" ;;
                *)   TOOLPATH="$(command -v "$TOOLNAME" || true)"
            esac
        else
            [ -e "$TOOLPATH" ] || die "${TOOLNAME_UPPERCASE}=$TOOLPATH is not exist."
            [ -x "$TOOLPATH" ] || die "${TOOLNAME_UPPERCASE}=$TOOLPATH is not executable."
        fi

        eval export "${TOOLNAME_UPPERCASE}='$TOOLPATH'"
    done

    unset TOOLNAME_UPPERCASE
    unset TOOLNAME
    unset TOOLPATH

    ##################################################################################

    cat > "$PACKAGE_INSTALLING_BIN_DIR/test.c" <<EOF
int main() {
    return 0;
}
EOF

    if "$CC" -Wno-error=unused-command-line-argument "$PACKAGE_INSTALLING_BIN_DIR/test.c" 2>/dev/null ; then
        CCFLAGS="$CCFLAGS -Wno-error=unused-command-line-argument"
    fi

    ##################################################################################

    export WRAPPED_CC="$CC"
    export WRAPPED_CXX="$CXX"

     CC="$MY_HOME_DIR/core/bin/wrapper-cc"
    CXX="$MY_HOME_DIR/core/bin/wrapper-c++"

    cat > "$CC.c" <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char * argv[]) {
    char * WRAPPED_PROGRAM = NULL;

    if (argv[0][strlen(argv[0]) - 1] == '+') {
        WRAPPED_PROGRAM = getenv("WRAPPED_CXX");

        if (WRAPPED_PROGRAM == NULL) {
            fprintf(stderr, "WRAPPED_CXX environment variable is not set.\n");
            return 2;
        }
    } else {
        WRAPPED_PROGRAM = getenv("WRAPPED_CC");

        if (WRAPPED_PROGRAM == NULL) {
            fprintf(stderr, "WRAPPED_CC environment variable is not set.\n");
            return 2;
        }
    }

    if (argc > 1) {
        int sharedOptionIndex = -1;
        int staticOptionIndex = -1;
        int static2OptionIndex = -1;

        int lastIndex = argc - 1;

        for (int i = 0; i <= lastIndex; i++) {
            if (strcmp(argv[i], "-shared") == 0) {
                sharedOptionIndex = i;

                if ((staticOptionIndex > 0) && (static2OptionIndex > 0)) {
                    break;
                }
            }

            if (strcmp(argv[i], "-static") == 0) {
                staticOptionIndex = i;

                if ((sharedOptionIndex > 0) && (static2OptionIndex > 0)) {
                    break;
                }
            }

            if (strcmp(argv[i], "--static") == 0) {
                static2OptionIndex = i;

                if ((sharedOptionIndex > 0) && (staticOptionIndex > 0)) {
                    break;
                }
            }
        }

        //printf("sharedOptionIndex=%d\n", sharedOptionIndex);
        //printf("staticOptionIndex=%d\n", staticOptionIndex);
        //printf("static2OptionIndex=%d\n", static2OptionIndex);

        if (sharedOptionIndex > 0) {
            if (staticOptionIndex > 0) {
                for (int i = staticOptionIndex; i < lastIndex; i++) {
                    argv[i] = argv[i + 1];
                }

                argv[lastIndex] = NULL;
                lastIndex -= 1;

                if (static2OptionIndex > staticOptionIndex) {
                    static2OptionIndex -= 1;
                }
            }

            if (static2OptionIndex > 0) {
                for (int i = static2OptionIndex; i < lastIndex; i++) {
                    argv[i] = argv[i + 1];
                }
                argv[lastIndex] = NULL;
            }
        }
    }

    argv[0] = WRAPPED_PROGRAM;

    if (WRAPPED_PROGRAM[0] == '/') {
        if (execv(WRAPPED_PROGRAM, argv) == -1) {
            perror(WRAPPED_PROGRAM);
            return 1;
        }
    } else {
        if (execvp(WRAPPED_PROGRAM, argv) == -1) {
            fprintf(stderr, "command not found: %s\b", WRAPPED_PROGRAM);
            return 1;
        }
    }

    return 0;
}
EOF

    run "$WRAPPED_CC" -std=c99 -o "$CC" "$CC.c"
    run ln -sf "$CC" "$CXX"

    ##################################################################################

    for item in $PACKAGE_CDEFINE
    do
        CPPFLAGS="$CPPFLAGS -D$item"
    done

    if [ -n "$PACKAGE_CCFLAGS" ] ; then
        CCFLAGS="$CCFLAGS $PACKAGE_CCFLAGS"
    fi

    if [ -n "$PACKAGE_LDFLAGS" ] ; then
        LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"
    fi

    if [ "$VERBOSE" = yes ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi

    LD_LIBRARY_DIR="$LD_LIBRARY_DIR_OLD"

    # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
    unset CMAKE_FIND_ROOT_PATH

    for DEP_PKG_NAME in $RECURSIVE_DEPENDENT_PACKAGES
    do
        DEP_PKG_NAME_UNDERSCORE=$(printf "$DEP_PKG_NAME" | tr '+-.' '_')

        unset DEP_PKG_INSTALL_DIR
        unset DEP_PKG_BINARY__DIR
        unset DEP_PKG_INCLUDE_DIR
        unset DEP_PKG_LIBRARY_DIR
        unset DEP_PKG_PKGCONF_DIR

        DEP_PKG_INSTALL_DIR="$MY_INSTALL_DIR/$DEP_PKG_NAME"
        DEP_PKG_BINARY__DIR="$DEP_PKG_INSTALL_DIR/bin"
        DEP_PKG_INCLUDE_DIR="$DEP_PKG_INSTALL_DIR/include"
        DEP_PKG_LIBRARY_DIR="$DEP_PKG_INSTALL_DIR/lib"
        DEP_PKG_PKGCONF_DIR="$DEP_PKG_INSTALL_DIR/lib/pkgconfig"

        eval "${DEP_PKG_NAME_UNDERSCORE}_INSTALL_DIR='$DEP_PKG_INSTALL_DIR'"
        eval "${DEP_PKG_NAME_UNDERSCORE}_BINARY__DIR='$DEP_PKG_BINARY__DIR'"
        eval "${DEP_PKG_NAME_UNDERSCORE}_INCLUDE_DIR='$DEP_PKG_INCLUDE_DIR'"
        eval "${DEP_PKG_NAME_UNDERSCORE}_LIBRARY_DIR='$DEP_PKG_LIBRARY_DIR'"

        if [ -d  "$DEP_PKG_BINARY__DIR" ] ; then
            PATH="$DEP_PKG_BINARY__DIR:$PATH"
        fi

        if [ -d "$DEP_PKG_INCLUDE_DIR" ] ; then
            CPPFLAGS="-I$DEP_PKG_INCLUDE_DIR $CPPFLAGS"
        fi

        if [ -d "$DEP_PKG_LIBRARY_DIR" ] ; then
            LDFLAGS="-L$DEP_PKG_LIBRARY_DIR -Wl,-rpath,$DEP_PKG_LIBRARY_DIR $LDFLAGS"

            if [ -z "$LD_LIBRARY_DIR" ] ; then
                LD_LIBRARY_DIR="$DEP_PKG_LIBRARY_DIR"
            else
                LD_LIBRARY_DIR="$DEP_PKG_LIBRARY_DIR:$LD_LIBRARY_DIR"
            fi
        fi

        if [ -d "$DEP_PKG_PKGCONF_DIR" ] ; then
            if [ -z "$PKG_CONFIG_PATH" ] ; then
                PKG_CONFIG_PATH="$DEP_PKG_PKGCONF_DIR"
            else
                PKG_CONFIG_PATH="$DEP_PKG_PKGCONF_DIR:$PKG_CONFIG_PATH"
            fi
        fi

        if [ -z "$CMAKE_FIND_ROOT_PATH" ] ; then
            CMAKE_FIND_ROOT_PATH="$DEP_PKG_INSTALL_DIR"
        else
            CMAKE_FIND_ROOT_PATH="$CMAKE_FIND_ROOT_PATH;$DEP_PKG_INSTALL_DIR"
        fi

        DEP_PKG_ACLOCAL_PATH="$DEP_PKG_INSTALL_DIR/share/aclocal"

        if [ -d "$DEP_PKG_ACLOCAL_PATH" ] ; then
            if [ -z "$ACLOCAL_PATH" ] ; then
                ACLOCAL_PATH="$DEP_PKG_ACLOCAL_PATH"
            else
                ACLOCAL_PATH="$DEP_PKG_ACLOCAL_PATH:$ACLOCAL_PATH"
            fi
        fi
    done

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    export ACLOCAL_PATH
    export LD_LIBRARY_DIR
    export PATH

    if [ "$VERBOSE" = yes ] ; then
        CCFLAGS="$CCFLAGS -v"
    fi

      CFLAGS="$CCFLAGS"
    CXXFLAGS="$CCFLAGS"

    if [ -n "$PACKAGE_XXFLAGS" ] ; then
        CXXFLAGS="$CXXFLAGS $PACKAGE_XXFLAGS"
    fi

    PACKAGE_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE_NAME"

    STATIC_LIBRARY_SUFFIX=.a

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        SHARED_LIBRARY_SUFFIX=.dylib
    else
        SHARED_LIBRARY_SUFFIX=.so
    fi

    CPPFLAGS="-I$PACKAGE_INSTALLING_INC_DIR $CPPFLAGS"
     LDFLAGS="-L$PACKAGE_INSTALLING_LIB_DIR -Wl,-rpath,$PACKAGE_INSTALL_DIR/lib $LDFLAGS"
    export PATH="$PACKAGE_INSTALLING_BIN_DIR:$PATH"

    # https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html#manual:cmake-env-variables(7)
    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        unset CMAKE_PREFIX_PATH
        unset CMAKE_APPLE_SILICON_PROCESSOR
        unset CMAKE_BUILD_PARALLEL_LEVEL
        unset CMAKE_BUILD_TYPE
        unset CMAKE_CONFIGURATION_TYPES
        unset CMAKE_CONFIG_TYPE
        unset CMAKE_EXPORT_COMPILE_COMMANDS
        unset CMAKE_GENERATOR
        unset CMAKE_GENERATOR_INSTANCE
        unset CMAKE_GENERATOR_PLATFORM
        unset CMAKE_GENERATOR_TOOLSET
        unset CMAKE_INSTALL_MODE
        unset CMAKE_C_COMPILER_LAUNCHER
        unset CMAKE_C_LINKER_LAUNCHER
        unset CMAKE_CXX_COMPILER_LAUNCHER
        unset CMAKE_CXX_LINKER_LAUNCHER
        unset CMAKE_MSVCIDE_RUN_PATH
        unset CMAKE_NO_VERBOSE
        unset CMAKE_OSX_ARCHITECTURES
        unset CMAKE_TOOLCHAIN_FILE
        unset DESTDIR
        unset CTEST_INTERACTIVE_DEBUG_MODE
        unset CTEST_OUTPUT_ON_FAILURE
        unset CTEST_PARALLEL_LEVEL
        unset CTEST_PROGRESS_OUTPUT
        unset CTEST_USE_LAUNCHERS_DEFAULT
        unset DASHBOARD_TEST_FROM_CTEST

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_BUILD_PARALLEL_LEVEL.html
        export CMAKE_BUILD_PARALLEL_LEVEL="$BUILD_NJOBS"

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_GENERATOR.html
        if [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] ; then
            export CMAKE_GENERATOR='Ninja'
        else
            export CMAKE_GENERATOR='Unix Makefiles'
        fi

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_EXPORT_COMPILE_COMMANDS.html
        if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] ; then
            export CMAKE_EXPORT_COMPILE_COMMANDS=ON
        else
            export CMAKE_EXPORT_COMPILE_COMMANDS=OFF
        fi

        case $BUILD_TYPE in
            debug)   CMAKE_BUILD_TYPE=Debug   ;;
            release) CMAKE_BUILD_TYPE=Release ;;
        esac

        case $INSTALL_LIB in
            static)  BUILD_SHARED_LIBS=OFF ;;
            *)       BUILD_SHARED_LIBS=ON
        esac

        if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
            CMAKE_VERBOSE_MAKEFILE=OFF
            CMAKE_COLOR_MAKEFILE=OFF
        else
            CMAKE_VERBOSE_MAKEFILE=ON
            CMAKE_COLOR_MAKEFILE=ON
        fi

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
        if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
            CMAKE_FIND_DEBUG_MODE=ON
        else
            CMAKE_FIND_DEBUG_MODE=OFF
        fi

        CMAKE_TOOLCHAIN_FILE="$PACKAGE_INSTALLING_TOP_DIR/toolchain.cmake"
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        # https://docs.rs/backtrace/latest/backtrace/
        export RUST_BACKTRACE=1

        unset RUST_TARGET

        case $NATIVE_OS_KIND-$NATIVE_OS_ARCH in
            linux-x86_64)
                case $NATIVE_OS_LIBC in
                    glibc) RUST_TARGET=x86_64-unknown-linux-gnu  ;;
                    musl)  RUST_TARGET=x86_64-unknown-linux-musl ;;
                    *)     die "unrecognized libc."
                esac
                ;;
            linux-aarch64)
                case $NATIVE_OS_LIBC in
                    glibc) RUST_TARGET=aarch64-unknown-linux-gnu  ;;
                    musl)  RUST_TARGET=aarch64-unknown-linux-musl ;;
                    *)     die "unrecognized libc."
                esac
                ;;
            darwin-x86_64)  RUST_TARGET=x86_64-apple-darwin  ;;
            darwin-aarch64) RUST_TARGET=aarch64-apple-darwin ;;

            freebsd-amd64)  RUST_TARGET=x86_64-unknown-freebsd ;;

            netbsd-x86_64)  RUST_TARGET=x86_64-unknown-netbsd  ;;
        esac

        
        RUST_TARGET_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$RUST_TARGET" | tr a-z A-Z | tr - _)

        # https://doc.rust-lang.org/cargo/reference/config.html#environment-variables
        # https://doc.rust-lang.org/cargo/reference/environment-variables.html
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_AR"="$AR"
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_LINKER"="$CC"

        # this environment variable is not defined by Rust, but it is widely used by third-party project.
        export RUST_TARGET

        export CARGO_BUILD_JOBS="$BUILD_NJOBS"

        # https://doc.rust-lang.org/rustc/codegen-options/index.html#link-arg
        export RUSTFLAGS="-Clinker=$CC -Clink-arg=-L$PACKAGE_INSTALLING_TOP_DIR/lib -Clink-arg=-L$PACKAGE_INSTALLING_TOP_DIR"

        if [ "$LINK_TYPE" = static-only ] && [ "$NATIVE_OS_LIBC" = musl ] ; then
            echo 'INPUT(-lc)' > $PACKAGE_INSTALLING_TOP_DIR/lib/libgcc_s.a
            export RUSTFLAGS="$RUSTFLAGS -Clink-arg=-static -Clink-arg=-ffunction-sections -Clink-arg=-fdata-sections -Clink-arg=-Wl,--gc-sections -Clink-arg=-Wl,--no-dynamic-linker"
        fi

        # https://libraries.io/cargo/cc
        # https://crates.io/crates/cc
        # https://docs.rs/cc/latest/cc/
        # https://github.com/alexcrichton/cc-rs
        export HOST_CC="$CC"
        export HOST_CFLAGS="$CFLAGS"

        export HOST_CXX="$CXX"
        export HOST_CXXFLAGS="$CXXFLAGS"

        export HOST_AR="$AR"

        export TARGET_CC="$CC"
        export TARGET_CFLAGS="$CFLAGS $CPPFLAGS $LDFLAGS"

        export TARGET_CXX="$CXX"
        export TARGET_CXXFLAGS="$CXXFLAGS $CPPFLAGS $LDFLAGS"

        export TARGET_AR="$AR"


        # https://libraries.io/cargo/pkg-config
        # https://crates.io/crates/pkg-config
        # https://docs.rs/pkg-config/latest/pkg_config/
        # https://github.com/rust-lang/pkg-config-rs
        # export TARGET_PKG_CONFIG_ALLOW_CROSS=1


        # https://libraries.io/cargo/cmake
        # https://crates.io/crates/cmake
        # https://docs.rs/cmake/latest/cmake/
        # https://github.com/alexcrichton/cmake-rs
        # this variable is not motioned in their document. you must read the source code of cmake-rs crate.
        # export TARGET_CMAKE_TOOLCHAIN_FILE="$TARGET_WORKING_DIR/toolchain.cmake"


        for item in $RECURSIVE_DEPENDENT_PACKAGES
        do
            case $item in
                openssl)
                    unset OPENSSL_DIR
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_INSTALL_DIR"
                    ;;
            esac
        done

        env | grep CARGO_
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        # https://golang.org/doc/install/source#environment
        export CGO_ENABLED=0
        export CGO_CFLAGS="$CFLAGS"
        export CGO_CXXFLAGS="$CXXFLAGS"
        export CGO_CPPFLAGS="$CPPFLAGS"
        export CGO_LDFLAGS="$LDFLAGS"

        export GO111MODULE='auto'

        if [ "$COUNTRY" = china ] ; then
            export GOPROXY='https://goproxy.cn'
        fi

        unset GOOS
        unset GOARCH

        # export GOOS="$TARGET_OS_TYPE"

        # case $TARGET_OS_ARCH in
        #     armv7*)  export GOARCH=arm   ;;
        #     arm64*)  export GOARCH=arm64 ;;
        #     aarch64) export GOARCH=arm64 ;;
        #     i386)    export GOARCH=386   ;;
        #     i686)    export GOARCH=386   ;;
        #     x86_64)  export GOARCH=amd64 ;;
        # esac
    fi
}

create_cmake_toolchain_file() {
    cat > "$CMAKE_TOOLCHAIN_FILE" <<EOF
message(STATUS "CMake command: \${CMAKE_COMMAND}")
message(STATUS "CMake version: \${CMAKE_VERSION}")

if ("\${BUILD_SHARED_LIBS}" STREQUAL "")
    set(BUILD_SHARED_LIBS $BUILD_SHARED_LIBS)
endif()

set(CMAKE_BUILD_TYPE  $CMAKE_BUILD_TYPE)

set(CMAKE_C_COMPILER "$CC")
set(CMAKE_C_FLAGS "$CFLAGS $CPPFLAGS $LDFLAGS")
set(CMAKE_EXE_LINKER_FLAGS $CMAKE_EXE_LINKER_FLAGS)

set(CMAKE_CXX_COMPILER "$CXX")
set(CMAKE_CXX_FLAGS "$CXXFLAGS $CPPFLAGS $LDFLAGS")

set(CMAKE_ASM_COMPILER "$CC")

set(CMAKE_AR      "$AR")
set(CMAKE_RANLIB  "$RANLIB")

set(CMAKE_LINKER  "$LD")

set(CMAKE_NM      "$NM")
set(CMAKE_READELF "$READELF")

set(CMAKE_OBJCOPY "$OBJCOPY")
set(CMAKE_OBJDUMP "$OBJDUMP")

set(CMAKE_STRIP   "$STRIP")

set(CMAKE_DLLTOOL "$DLLTOOL")

set(CMAKE_ADDR2LINE "$ADDR2LINE")

set(CMAKE_FIND_LIBRARY_SUFFIXES ".a" ".so")

set(CMAKE_FIND_DEBUG_MODE $CMAKE_FIND_DEBUG_MODE)

set(CMAKE_FIND_ROOT_PATH "$CMAKE_FIND_ROOT_PATH")
EOF

    if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_QUIET" ] ; then
        run cat "$CMAKE_TOOLCHAIN_FILE"
    fi
}

__printf_build_variables() {
    step "printf build variables"

    printf '%s\n' "
        BUILD_NJOBS = $BUILD_NJOBS
        BUILD_TYPE  = $BUILD_TYPE

     TIMESTAMP_UNIX = $TIMESTAMP_UNIX

     NATIVE_OS_KIND = $NATIVE_OS_KIND
     NATIVE_OS_TYPE = $NATIVE_OS_TYPE
     NATIVE_OS_NAME = $NATIVE_OS_NAME
     NATIVE_OS_VERS = $NATIVE_OS_VERS
     NATIVE_OS_ARCH = $NATIVE_OS_ARCH
     NATIVE_OS_NCPU = $NATIVE_OS_NCPU
     NATIVE_OS_LIBC = $NATIVE_OS_LIBC
     NATIVE_OS_SUBS = $NATIVE_OS_SUBS

        WRAPPED_CC  = $WRAPPED_CC
        WRAPPED_CXX = $WRAPPED_CXX
    "

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export "$TOOL=\"\$$TOOL\""
        printf "%19s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    echo

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export "$FLAG=\"\$$FLAG\""
        printf "\n%19s = " "$FLAG"
        FIRST=yes
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = yes ] ; then
                FIRST=no
                printf '%s\n' "$item"
            else
                printf '%s\n' "                      $item"
            fi
        done
    done

    echo

    printf "\n%19s = " PATH
    FIRST=yes
    for item in $(printf '%s\n' "$PATH" | tr ' ' '|' | tr ':' ' ')
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
            printf '%s\n' "$item" | tr '|' ' '
        else
            printf '%s\n' "                      $item" | tr '|' ' '
        fi
    done

    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        echo
        env | sed -n '/^CMAKE_/p'
    fi

    printf '%s\n' "

PACKAGE_INSTALLING_TOP_DIR = $PACKAGE_INSTALLING_TOP_DIR
PACKAGE_INSTALLING_SRC_DIR = $PACKAGE_INSTALLING_SRC_DIR
PACKAGE_INSTALLING_BST_DIR = $PACKAGE_INSTALLING_BST_DIR
PACKAGE_INSTALLING_TMP_DIR = $PACKAGE_INSTALLING_TMP_DIR

PACKAGE_INSTALL_DIR = $PACKAGE_INSTALL_DIR

     LD_LIBRARY_DIR = $LD_LIBRARY_DIR

STATIC_LIBRARY_SUFFIX  = $STATIC_LIBRARY_SUFFIX
SHARED_LIBRARY_SUFFIX  = $SHARED_LIBRARY_SUFFIX
"

    step "list PATH"
    IFS_OLD=$IFS
    IFS=':'
    for item in $PATH
    do
        printf '%s\n' "$item"
    done
    IFS=$IFS_OLD

    if [ "$VERBOSE" = yes ] ; then
        step "show export variables"
        run export -p
        echo
    fi
}

__adjust_la_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib" ] || {
        note "no .la files installed, skipped"
        return 0
    }

    LA_FILES="$(find "$PACKAGE_INSTALL_DIR/lib" -name "*.la")"

    [ -z "$LA_FILES" ] && {
        note "no .la files installed, skipped"
        return 0
    }

    for lafile in $LA_FILES
    do
        sed_in_place 's|-Wl,--strip-debug||g'      "$lafile"
        sed_in_place "s|-L$MY_HOME_DIR[^' ]*||g"   "$lafile"
        #sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$lafile"
        #sed_in_place "s|--sysroot $SYSROOT||g"     "$lafile"
    done
}

__adjust_pc_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" ] || {
        note "no .pc files installed, skipped"
        return 0
    }

    PC_FILES="$(find "$PACKAGE_INSTALL_DIR/lib/pkgconfig" -name "*.pc")"

    [ -z "$PC_FILES" ] && {
        note "no .pc files installed, skipped"
        return 0
    }

    for pcfile in $PC_FILES
    do
        sed_in_place "s|$PACKAGE_INSTALL_DIR|\${pcfiledir}/../..|g" "$pcfile"
        sed_in_place 's|-Wl,--strip-debug||g'      "$pcfile"
        sed_in_place "s|-L$MY_HOME_DIR[^' ]*||g"   "$pcfile"
        #sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$pcfile"
        #sed_in_place "s|--sysroot $SYSROOT||"      "$pcfile"

        if grep 'Libs.private:' "$pcfile" > /dev/null ; then
            if grep 'Libs:' "$pcfile" > /dev/null ; then
                LIBS_PRIVATE_CONTENT=$(sed -n '/Libs.private:/p' "$pcfile" | cut -c14-)
                sed_in_place "/Libs:/s|\$|$LIBS_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Libs.private:/d' "$pcfile"
            else
                sed_in_place 's|Libs.private:|Libs:|' "$pcfile"
            fi
        fi

        if grep 'Requires.private:' "$pcfile" > /dev/null ; then
            if grep 'Requires:' "$pcfile" > /dev/null ; then
                REQUIRES_PRIVATE_CONTENT=$(sed -n '/Requires.private:/p' "$pcfile" | cut -c18-)
                sed_in_place "/Requires:/s|\$|$REQUIRES_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Requires.private:/d' "$pcfile"
            else
                sed_in_place 's|Requires.private:|Requires:|' "$pcfile"
            fi
        fi
    done
}

__install_logs() {
    PACKAGE_LOG_DIR="$PACKAGE_INSTALL_DIR/share/log"
    for item in "$PACKAGE_INSTALLING_TMP_DIR" "$PACKAGE_INSTALLING_BST_DIR"
    do
        for item2 in 'config.log' 'compile_commands.json'
        do
            if [ -f "$item/$item2" ] ; then
                if [ ! -d "$PACKAGE_LOG_DIR" ] ; then
                    install -d "$PACKAGE_LOG_DIR"
                fi
                echo "-- Installing: $PACKAGE_LOG_DIR/$item2"
                install -m 644 "$item/$item2" "$PACKAGE_LOG_DIR" || return 1
            fi
        done
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(printf '%s\n' "$1" | cut -d: -f1)
        X2=$(printf '%s\n' "$1" | cut -d: -f2)

        if [ "$X1" = "$X2" ] ; then
            unset X2
        fi

        install -v -d         "$PACKAGE_INSTALL_DIR/include/$X2"
        install -v -m 644 $X1 "$PACKAGE_INSTALL_DIR/include/$X2"

        shift
    done
}

install_libs() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib"
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$PACKAGE_INSTALL_DIR/lib" ;;
            *)   install -v -m 755 $item "$PACKAGE_INSTALL_DIR/lib" ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    install -v -m 644 $@ "$PACKAGE_INSTALL_DIR/lib/pkgconfig"
}

install_bins() {
    install -v -d        "$PACKAGE_INSTALL_DIR/bin" &&
    install -v -m 755 $@ "$PACKAGE_INSTALL_DIR/bin"
}

install_etcs() {
    install -v -d        "$PACKAGE_INSTALL_DIR/etc" &&
    install -v -m 644 $@ "$PACKAGE_INSTALL_DIR/etc"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER"
    done
}

# install_completion <fish|bash|zsh> <COMMAND> <FILE-PATH>
  install_completion() {
    case $1 in
        bash)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/bash/completions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/bash/completions/$2"
            ;;
        fish)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d/$2.fish"
            ;;
        zsh)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/zsh/site-functions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/zsh/site-functions/_$2"
            ;;
        *)  die "install_completion unsupported shell: $1"
    esac
}

install_pc_file() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    cat >         "$PACKAGE_INSTALL_DIR/lib/pkgconfig/$1.pc"
}

# __show_infomation_of_all_available_packages [--json|--yaml|--shell]
  __show_infomation_of_all_available_packages() {
    case $1 in
        --json) __show_infomation_as_json__of_all_available_packages ;;
        --yaml) __show_infomation_as_yaml__of_all_available_packages ;;
        --shell)__show_infomation_as_shell_of_all_available_packages ;;
        '')     __show_infomation_as_mixed_of_all_available_packages ;;
        *)    die "__show_infomation_of_all_available_packages [--json|--yaml|--shell], unrecognized option: $1"
    esac
}

__show_infomation_as_mixed_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '========'
        fi
        __show_infomation_of_the_given_package "$PACKAGE"
    done
}

__show_infomation_as_json__of_all_available_packages() {
    printf '%s\n' '['

    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' ','
        fi
        __show_infomation_as_json__of_the_given_package "$PACKAGE"
    done

    printf '%s\n' ']'
}

__show_infomation_as_yaml__of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '---'
        fi
        __show_infomation_as_yaml__of_the_given_package "$PACKAGE"
    done
}

__show_infomation_as_shell_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '#---'
        fi
        __show_infomation_as_shell_of_the_given_package "$PACKAGE"
    done
}

# __show_infomation_as_json__of_the_given_package <PACKAGE-NAME>
  __show_infomation_as_json__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = yes ] ; then
        PARALLEL=true
    else
        PARALLEL=false
    fi

    jq  --null-input \
        --arg name "$PACKAGE_NAME" \
        --arg version "$PACKAGE_VERSION" \
        --arg summary "$PACKAGE_SUMMARY" \
        --arg webpage "$PACKAGE_WEBPAGE" \
        --arg license "$PACKAGE_LICENSE" \
        --arg git_url "$PACKAGE_GIT_URL" \
        --arg git_sha "$PACKAGE_GIT_SHA" \
        --arg git_tag "$PACKAGE_GIT_REF" \
        --arg src_url "$PACKAGE_SRC_URL" \
        --arg src_sha "$PACKAGE_SRC_SHA" \
        --arg fix_url "$PACKAGE_FIX_URL" \
        --arg fix_sha "$PACKAGE_FIX_SHA" \
        --arg res_url "$PACKAGE_RES_URL" \
        --arg res_sha "$PACKAGE_RES_SHA" \
        --arg dep_pkg "$PACKAGE_DEP_PKG" \
        --arg bsystem "$PACKAGE_BUILD_SYSTEM" \
        --arg binsrcd "$PACKAGE_BUILD_IN_BSCRIPT_DIR" \
        --arg parallel "$PARALLEL" \
        --arg cdefine "$PACKAGE_CDEFINE" \
        --arg ccflags "$PACKAGE_CCFLAGS" \
        --arg xxflags "$PACKAGE_XXFLAGS" \
        --arg ldflags "$PACKAGE_LDFLAGS" \
        --arg developer "$PACKAGE_DEVELOPER" \
'{
    "name":$name,
    "version":$version,
    "summary":$summary,
    "webpage":$webpage,
    "license":$license,
    "git": {
        "url":$git_url,
        "tag":$git_tag,
        "sha":$git_sha
    },
    "src": {
        "url":$src_url,
        "sha":$src_sha
    },
    "fix": {
        "url":$fix_url,
        "sha":$fix_sha
    },
    "res": {
        "url":$res_url,
        "sha":$res_sha
    },
    "dep": {
        "when-build":$dep_pkg,
        "at-runtime":$dep_pkg
    },
    "build": {
        "system":$bsystem,
        "ccflags":$ccflags,
        "cdefine":$cdefine,
        "xxflags":$xxflags,
        "ldflags":$ldflags,
        "binsrcd":$binsrcd,
        "parallel":$parallel
    },
    "developer":$developer
}'
}

# __show_infomation_as_yaml__of_the_given_package <PACKAGE-NAME>
  __show_infomation_as_yaml__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    cat <<EOF
name: $PACKAGE_NAME
version: $PACKAGE_VERSION
summary: $PACKAGE_SUMMARY
webpage: $PACKAGE_WEBPAGE
license: $PACKAGE_LICENSE

git:
    url: $PACKAGE_GIT_URL
    sha: $PACKAGE_GIT_SHA
    tag: $PACKAGE_GIT_REF

src:
    url: $PACKAGE_SRC_URL
    sha: $PACKAGE_SRC_SHA

fix:
    url: $PACKAGE_FIX_URL
    sha: $PACKAGE_FIX_SHA

res:
    url: $PACKAGE_RES_URL
    sha: $PACKAGE_RES_SHA

dep: $PACKAGE_DEP_PKG

build:
    system: $PACKAGE_BUILD_SYSTEM
    binsrcd: $PACKAGE_BUILD_IN_BSCRIPT_DIR
    cdefine: $PACKAGE_CDEFINE
    ccflags: $PACKAGE_CCFLAGS
    xxflags: $PACKAGE_XXFLAGS
    ldflags: $PACKAGE_LDFLAGS
    parallel: $PARALLEL

developer: $PACKAGE_DEVELOPER
EOF
}

# __show_infomation_as_shell_of_the_given_package <PACKAGE-NAME>
  __show_infomation_as_shell_of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    while read KEY
    do
        printf "%s='%s'\n" "${PACKAGE_NAME_UPPERCASE_UNDERSCORE}_${KEY}" "$(eval echo \$$KEY)"
    done <<EOF
PACKAGE_NAME
PACKAGE_SUMMARY
PACKAGE_WEBPAGE
PACKAGE_GIT_URL
PACKAGE_GIT_SHA
PACKAGE_GIT_REF
PACKAGE_SVN_URL
PACKAGE_SRC_URL
PACKAGE_SRC_SHA
PACKAGE_SRC_NAME
PACKAGE_SRC_PATH
PACKAGE_SRC_TYPE
PACKAGE_FIX_URL
PACKAGE_FIX_SHA
PACKAGE_FIX_NAME
PACKAGE_FIX_PATH
PACKAGE_FIX_TYPE
PACKAGE_VERSION
PACKAGE_VERSION_MAJOR
PACKAGE_VERSION_MINOR
PACKAGE_VERSION_PATCH
PACKAGE_VERSION_TWEAK
PACKAGE_DEVELOPER
PACKAGE_LICENSE
PACKAGE_BSCRIPT
PACKAGE_BSYSTEM
PACKAGE_BINBSTD
PACKAGE_BUILD_SYSTEM
PACKAGE_BUILD_SYSTEM_GO
PACKAGE_BUILD_SYSTEM_RAKE
PACKAGE_BUILD_SYSTEM_NINJA
PACKAGE_BUILD_SYSTEM_GMAKE
PACKAGE_BUILD_SYSTEM_CMAKE
PACKAGE_BUILD_SYSTEM_XMAKE
PACKAGE_BUILD_SYSTEM_MESON
PACKAGE_BUILD_SYSTEM_CARGO
PACKAGE_BUILD_SYSTEM_AUTOGENSH
PACKAGE_BUILD_SYSTEM_AUTOTOOLS
PACKAGE_BUILD_SYSTEM_CONFIGURE
PACKAGE_BUILD_IN_BSCRIPT_DIR
PACKAGE_BUILD_IN_PARALLEL
PACKAGE_DEP_PKG
PACKAGE_CDEFINE
PACKAGE_CCFLAGS
PACKAGE_XXFLAGS
PACKAGE_LDFLAGS
PACKAGE_FORMULA_FILEPATH
EOF
}

# __show_infomation_of_the_given_package <PACKAGE-NAME> [OPTIONS]
#
# __show_infomation_of_the_given_package @all
# __show_infomation_of_the_given_package @all --json
# __show_infomation_of_the_given_package @all --yaml
# __show_infomation_of_the_given_package @all --shell
#
# __show_infomation_of_the_given_package curl
# __show_infomation_of_the_given_package curl --json
# __show_infomation_of_the_given_package curl --yaml
# __show_infomation_of_the_given_package curl --shell
#
# __show_infomation_of_the_given_package curl version
# __show_infomation_of_the_given_package curl webpage
  __show_infomation_of_the_given_package() {
    [ -z "$1" ] && {
        error "__show_infomation_of_the_given_package <PACKAGE-NAME> [ARGUMENTS], <PACKAGE-NAME> is not given."
        return 1
    }

    case $1 in
        @all) shift ; __show_infomation_of_all_available_packages $@ ; return $?
    esac

    unset SHOW_INFOMATION_ARGS

    for arg in $@
    do
        case $arg in
            "$1")
                ;;
            -x|--xtrace)
                ;;
            *)  if [ -z "$SHOW_INFOMATION_ARGS" ] ; then
                    SHOW_INFOMATION_ARGS="$arg"
                else
                    SHOW_INFOMATION_ARGS="$SHOW_INFOMATION_ARGS $arg"
                fi
        esac
    done

    case $SHOW_INFOMATION_ARGS in
        --json)
            __show_infomation_as_json__of_the_given_package "$1"
            ;;
        --yaml)
            __show_infomation_as_yaml__of_the_given_package "$1"
            ;;
        --shell)
            __show_infomation_as_shell_of_the_given_package "$1"
            ;;
        formula)
            __path_of_formula_of_the_given_package "$1"
            ;;
        installed-dir)
            if is_package_installed "$1" ; then
                printf '%s\n' "$MY_INSTALL_DIR/$1"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-metadata-raw)
            if is_package_installed "$1" ; then
                cat "$MY_INSTALL_DIR/$1/installed-metadata-ppkg"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-metadata-json)
            if is_package_installed "$1" ; then
                cat "$MY_INSTALL_DIR/$1/installed-metadata-ppkg"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-files)
            if is_package_installed "$1" ; then
                cat "$MY_INSTALL_DIR/$1/installed-files"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-datetime-unix)
            __load_installed_metadata_of_the_given_package "$1"
            printf '%s\n' "$INSTALLED_PACKAGE_DATETIME"
            ;;
        installed-datetime-formatted)
            __load_installed_metadata_of_the_given_package "$1"
            format_unix_timestamp "$INSTALLED_PACKAGE_DATETIME" '+%Y-%m-%d %H:%M:%S'
            ;;
        installed-pkg-version)
            __load_installed_metadata_of_the_given_package "$1"
            printf '%s\n' "$INSTALLED_PACKAGE_VERSION"
            ;;
        '') __show_infomation_as_mixed_of_the_given_package $@
            ;;
        *)  __load_formula_of_the_given_package "$1"
            __PACKAGE_GET__KEY__="$(printf '%s\n' "$2" | tr '+-.' '_' | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_GET__KEY__
    esac
}

# __show_infomation_as_mixed_of_the_given_package <PACKAGE-NAME>
  __show_infomation_as_mixed_of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    printf '%b\n' \
"pkgname : $(mark_is_package_installed_or_not $1)
version : $PACKAGE_VERSION
summary : $PACKAGE_SUMMARY
webpage : $PACKAGE_WEBPAGE
src-url : $PACKAGE_SRC_URL
src-loc : $PACKAGE_SRC_PATH
dep-pkg : $PACKAGE_DEP_PKG"

    is_package_installed "$1" || return 0

    __load_installed_metadata_of_the_given_package "$1"

    printf '%b\n' "${COLOR_GREEN}installed version $INSTALLED_PACKAGE_VERSION at $(format_unix_timestamp $INSTALLED_PACKAGE_DATETIME '+%Y-%m-%d %H:%M:%S') CST${COLOR_OFF}"
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

__record_installed_files_of_the_given_package() {
    if [ -z "$2" ] ; then
        INSTALLED_FILES_FILEPATH="$MY_INSTALL_DIR/$1/installed-files"
        echo "-- Installing: $INSTALLED_FILES_FILEPATH"

        exec 7> "$INSTALLED_FILES_FILEPATH"

        __record_installed_files_of_the_given_package "$1" "$MY_INSTALL_DIR/$1"

        exec 7>&-

        sed_in_place "s|$MY_INSTALL_DIR/$1/||" "$INSTALLED_FILES_FILEPATH"
    else
        for FILENAME in $(ls "$2")
        do
            FILEPATH="$2/$FILENAME"

            if [ -d "$FILEPATH" ] ; then
                printf 'd %s %s\n' "$FILEPATH/" >&7
                __record_installed_files_of_the_given_package "$1" "$FILEPATH"
            else
                printf 'f %s %s\n' "$FILEPATH"  >&7
            fi
        done
    fi
}

# __record_installed_metadata_of_the_given_package <PACKAGE-NAME>
  __record_installed_metadata_of_the_given_package() {
    [ -z "$1" ] && {
        error "__record_installed_metadata_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    INSTALLED_METADATA_FILEPATH="$PACKAGE_INSTALL_DIR/installed-metadata-ppkg"

    printf '%b\n' "-- Installing: $INSTALLED_METADATA_FILEPATH"

    run cp "$PACKAGE_FORMULA_FILEPATH" "$INSTALLED_METADATA_FILEPATH"

    sed_in_place "1i pkgname: $PACKAGE_NAME" "$INSTALLED_METADATA_FILEPATH"

    if ! grep -q '^version: ' "$INSTALLED_METADATA_FILEPATH" ; then
        sed_in_place "2i version: $PACKAGE_VERSION" "$INSTALLED_METADATA_FILEPATH"
    fi

    if [ "$PACKAGE_SRC_TYPE" = git ] || [ "$PACKAGE_SRC_TYPE" = dir ] ; then
        if ! grep -q '^git-sha: ' "$INSTALLED_METADATA_FILEPATH" ; then
            if grep -q '^git-url: ' "$INSTALLED_METADATA_FILEPATH" ; then
                sed_in_place "/^git-url:/a git-sha: $PACKAGE_GIT_SHA" "$INSTALLED_METADATA_FILEPATH"
            else
                sed_in_place "\$a git-sha: $PACKAGE_GIT_SHA" "$INSTALLED_METADATA_FILEPATH"
            fi
        fi
    fi

    sed_in_place '/^#src-url: dir:/d' "$INSTALLED_METADATA_FILEPATH"

    cat >> "$INSTALLED_METADATA_FILEPATH" <<EOF

ppkgvers: $MY_VERSION
datetime: $TIMESTAMP_UNIX
EOF
}

# __load_installed_metadata_of_the_given_package <PACKAGE-NAME>
  __load_installed_metadata_of_the_given_package() {
    [ -z "$1" ] && {
        error "__load_installed_metadata_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    is_package_installed "$1" || {
        error "package [$1] is not installed."
        return 1
    }

    unset INSTALLED_PACKAGE_VERSION
    unset INSTALLED_PACKAGE_SUMMARY
    unset INSTALLED_PACKAGE_WEBPAGE
    unset INSTALLED_PACKAGE_LICENSE

    unset INSTALLED_PACKAGE_GIT_URL
    unset INSTALLED_PACKAGE_GIT_SHA
    unset INSTALLED_PACKAGE_GIT_REF

    unset INSTALLED_PACKAGE_SVN_URL

    unset INSTALLED_PACKAGE_SRC_URL
    unset INSTALLED_PACKAGE_SRC_URI
    unset INSTALLED_PACKAGE_SRC_SHA

    unset INSTALLED_PACKAGE_FIX_URL
    unset INSTALLED_PACKAGE_FIX_SHA

    unset INSTALLED_PACKAGE_RES_URL
    unset INSTALLED_PACKAGE_RES_SHA

    unset INSTALLED_PACKAGE_DEP_PKG

    unset INSTALLED_PACKAGE_BSYSTEM

    unset INSTALLED_PACKAGE_PPKGVERS

    unset INSTALLED_PACKAGE_DATETIME


    PACKAGE_INSTALLED_DIR="$MY_INSTALL_DIR/$1"

    INSTALLED_METADATA_FILEPATH="$PACKAGE_INSTALLED_DIR/installed-metadata-ppkg"

    for key in ppkgvers datetime summary webpage git-url git-sha git-ref shallow src-url src-uri src-sha fix-url fix-sha res-url res-sha dep-pkg dep-pym license version bsystem bscript binbstd cdefine ccflags xxflags ldflags parallel toolset cstdlib exetype
    do
        unset __KEY_UPPERCASE_UNDERSCORE__
        unset __VALUE__

        __KEY_UPPERCASE_UNDERSCORE__="$(printf '%s\n' "$key" | tr '-' '_' | tr a-z A-Z)"
        __VALUE__="$(yq ".$key" "$INSTALLED_METADATA_FILEPATH")"

        if [ "$__VALUE__" = null ] ; then
                __VALUE__=
        fi

        eval "INSTALLED_PACKAGE_$__KEY_UPPERCASE_UNDERSCORE__='$__VALUE__'"
    done

    if [ -z "$INSTALLED_PACKAGE_PPKGVERS" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_PPKGVERS must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_DATETIME" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_DATETIME must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_VERSION" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_VERSION must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_SUMMARY" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_SUMMARY must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_WEBPAGE" ] && [ -z "$INSTALLED_PACKAGE_GIT_URL" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_WEBPAGE must not be empty."
        return 1
    fi

    if [ "${#INSTALLED_PACKAGE_DATETIME}" -ne 10 ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. length of \$INSTALLED_PACKAGE_DATETIME must be 10."
        return 1
    fi
}

gow() {
    if command -v bat > /dev/null ; then
        run "go env | bat --language=bash --paging=never --style=plain"
    else
        run "go env"
    fi

    printf '\n'

    # https://pkg.go.dev/cmd/go
    # https://pkg.go.dev/cmd/link

    unset GO_BUILD_ARGS
    unset GO_BUILD_ARGV_V
    unset GO_BUILD_ARGV_X
    unset GO_BUILD_ARGV_O
    unset GO_BUILD_ARGV_MOD
    unset GO_BUILD_ARGV_TAGS
    unset GO_BUILD_ARGV_LDFLAGS

    unset GO_BUILD_ARGS_EXTRA

    while [ -n "$1" ]
    do
        case $1 in
            -v) shift ; GO_BUILD_ARGV_V='-v' ;;
            -x) shift ; GO_BUILD_ARGV_X='-x' ;;
            -o) shift ; GO_BUILD_ARGV_O="$1" ; shift ;;
            -X) shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="-X $1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -X $1"
                fi
                shift
                ;;
            -ldflags)
                shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="$1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$1 $GO_BUILD_ARGV_LDFLAGS"
                fi
                shift
                ;;
            *)  GO_BUILD_ARGS_EXTRA="$GO_BUILD_ARGS_EXTRA $1" ; shift
        esac
    done

    GO_BUILD_ARGS='-trimpath'

    if [ -z "$GO_BUILD_ARGV_V" ] ; then
        if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_QUIET" ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
    fi

    if [ -z "$GO_BUILD_ARGV_X" ] ; then
        if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -s -w"
    fi

    if [ "$NATIVE_OS_KIND" = linux ] ; then
        GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -linkmode external \"-extldflags=-static\""
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS -ldflags '$GO_BUILD_ARGV_LDFLAGS'"

    if [ -z "$GO_BUILD_ARGV_O" ] ; then
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_INSTALLING_TMP_DIR/"
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_INSTALLING_TMP_DIR/$GO_BUILD_ARGV_O"
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS $GO_BUILD_ARGS_EXTRA"

    run go build $GO_BUILD_ARGS

    for item in $(ls "$PACKAGE_INSTALLING_TMP_DIR")
    do
        case $item in
            *.a)  run install_libs "$PACKAGE_INSTALLING_TMP_DIR/$item" ;;
            *.so) run install_libs "$PACKAGE_INSTALLING_TMP_DIR/$item" ;;
            *)    run install_bins "$PACKAGE_INSTALLING_TMP_DIR/$item" ;;
        esac
    done
}

cargow() {
    run rustup target add "$RUST_TARGET"

    case $1 in
        build)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-build.html

            unset CARGO_BUILD_ARGS
            unset CARGO_BUILD_ARG_VV
            unset CARGO_BUILD_ARG_TARGET
            unset CARGO_BUILD_ARG_RELEASE

            for arg in $@
            do
                case $arg in
                    --vv)      CARGO_BUILD_ARG_VV=set      ;;
                    --target)  CARGO_BUILD_ARG_TARGET=set  ;;
                    --release) CARGO_BUILD_ARG_RELEASE=set ;;
                esac
            done

            CARGO_BUILD_ARGS="$@"

            if [ -z "$CARGO_BUILD_ARG_VV" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS -vv"
            fi

            if [ -z "$CARGO_BUILD_ARG_RELEASE" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --release"
            fi

            if [ -z "$CARGO_BUILD_ARG_TARGET" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --target $RUST_TARGET"
            fi

            run cargo clean && run cargo $CARGO_BUILD_ARGS
            ;;
        install)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-install.html

            unset CARGO_INSTALL_ARGS
            unset CARGO_INSTALL_ARG_TARGET
            unset CARGO_INSTALL_ARG_PATH
            unset CARGO_INSTALL_ARG_ROOT
            unset CARGO_INSTALL_ARG_VV

            for arg in $@
            do
                case $arg in
                    --target) CARGO_INSTALL_ARG_TARGET=set ;;
                    --path)   CARGO_INSTALL_ARG_PATH=set   ;;
                    --root)   CARGO_INSTALL_ARG_ROOT=set   ;;
                    --vv)     CARGO_INSTALL_ARG_VV=set     ;;
                esac
            done

            CARGO_INSTALL_ARGS="$@"

            if [ -z "$CARGO_INSTALL_ARG_VV" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_INSTALL_ARG_TARGET" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_INSTALL_ARG_PATH" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --path $PACKAGE_INSTALLING_BST_DIR"
            fi

            if [ -z "$CARGO_INSTALL_ARG_ROOT" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --root=$PACKAGE_INSTALL_DIR"
            fi

            run cargo clean && run cargo $CARGO_INSTALL_ARGS
            ;;
        cbuild|cinstall)
            unset CARGO_CINSTALL_ARGS
            unset CARGO_CINSTALL_ARG_Q
            unset CARGO_CINSTALL_ARG_V
            unset CARGO_CINSTALL_ARG_VV
            unset CARGO_CINSTALL_ARG_DEBUG
            unset CARGO_CINSTALL_ARG_RELEASE
            unset CARGO_CINSTALL_ARG_TARGET
            unset CARGO_CINSTALL_ARG_PREFIX

            for arg in $@
            do
                case $arg in
                    -q|--quiet)   CARGO_CINSTALL_ARG_Q=set       ;;
                    -v|--verbose) CARGO_CINSTALL_ARG_V=set       ;;
                    -vv)          CARGO_CINSTALL_ARG_VV=set      ;;
                    --debug)      CARGO_CINSTALL_ARG_DEBUG=set   ;;
                    --release)    CARGO_CINSTALL_ARG_RELEASE=set ;;
                    --target)     CARGO_CINSTALL_ARG_TARGET=set  ;;
                    --prefix)     CARGO_CINSTALL_ARG_PREFIX=set  ;;
                esac
            done

            CARGO_CINSTALL_ARGS="$@"

            if [ -z "$CARGO_CINSTALL_ARG_Q" ] && [ -z "$CARGO_CINSTALL_ARG_V" ] && [ -z "$CARGO_CINSTALL_ARG_VV" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_DEBUG" ] && [ -z "$CARGO_CINSTALL_ARG_RELEASE" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --release"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_TARGET" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_PREFIX" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --prefix $PACKAGE_INSTALL_DIR"
            fi

            run cargo $CARGO_CINSTALL_ARGS
            ;;
        *) cargo $@
    esac
}

# run in a subshell
configure() {
    export FORCE_UNSAFE_CONFIGURE=1

    CONFIGURE_ARGS="
        --prefix='$PACKAGE_INSTALL_DIR'
        --disable-option-checking
        --enable-rpath
        --disable-nls
        --enable-largefile
        CC='$CC'
        CFLAGS='$CFLAGS'
        CXX='$CXX'
        CXXFLAGS='$CXXFLAGS'
        CPP='$CPP'
        CPPFLAGS='$CPPFLAGS'
        LDFLAGS='$LDFLAGS'
        AR='$AR'
        RANLIB='$RANLIB'
        PKG_CONFIG='$PKG_CONFIG'
        PKG_CONFIG_PATH='$PKG_CONFIG_PATH'
        PKG_CONFIG_LIBDIR='$PKG_CONFIG_LIBDIR'"

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
        CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-debug"
    else
        CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-debug"
    fi

    case $INSTALL_LIB in
        static) CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --disable-shared" ;;
        shared) CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-shared --disable-static" ;;
        both)   CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --enable-shared"  ;;
        no)     CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-static --disable-shared";;
    esac

    if run $PACKAGE_INSTALLING_BST_DIR/configure $CONFIGURE_ARGS $@ ; then
        echo
    else
        if [ -f "$PACKAGE_INSTALLING_TMP_DIR/config.log" ] ; then
            run cat "$PACKAGE_INSTALLING_TMP_DIR/config.log"
        elif [ -f "$PACKAGE_INSTALLING_BST_DIR/config.log" ] ; then
            run cat "$PACKAGE_INSTALLING_BST_DIR/config.log"
        fi
        return 1
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        for Makefile in $(find "$PACKAGE_INSTALLING_BST_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi

    gmakew clean &&
    gmakew V=1   &&
    gmakew install
}

# gmake wrapper
gmakew() {
    run gmake --version

    if [ "$DEBUG" = yes ] ; then
        run gmake "-j$BUILD_NJOBS --debug $*"
    else
        run gmake "-j$BUILD_NJOBS $*"
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
cmakew() {
    create_cmake_toolchain_file
    run cmake \
        -Wno-dev \
        -DCMAKE_INSTALL_PREFIX=$PACKAGE_INSTALL_DIR \
        -DCMAKE_TOOLCHAIN_FILE=$CMAKE_TOOLCHAIN_FILE \
        -DCMAKE_VERBOSE_MAKEFILE=$CMAKE_VERBOSE_MAKEFILE \
        -DCMAKE_COLOR_MAKEFILE=$CMAKE_COLOR_MAKEFILE \
        -S $PACKAGE_INSTALLING_BST_DIR \
        -B $PACKAGE_INSTALLING_TMP_DIR $@ &&
    run cmake --build   "$PACKAGE_INSTALLING_TMP_DIR" -- -j$BUILD_NJOBS &&
    run cmake --install "$PACKAGE_INSTALLING_TMP_DIR"
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
mesonw() {
    unset MESON_BUILD_DEFAULT_LIBRARY

    case $INSTALL_LIB in
        static|shared|both) MESON_BUILD_DEFAULT_LIBRARY="$INSTALL_LIB"
    esac

        MESON_CROSS_FILE="$PACKAGE_INSTALLING_TMP_DIR/cross-file"

    cat > "$MESON_CROSS_FILE" <<EOF
[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'

[built-in options]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF

    run meson --version
    run ninja --version
    run meson setup \
        --prefix="$PACKAGE_INSTALL_DIR" \
        --buildtype=release \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH" \
        -Ddefault_library=$MESON_BUILD_DEFAULT_LIBRARY \
        -Dlibdir=lib \
        $@ "$PACKAGE_INSTALLING_TMP_DIR" "$PACKAGE_INSTALLING_BST_DIR" &&
    {
        if command -v build_configed > /dev/null ; then
            build_configed
        fi
    } &&
    run ninja -C "$PACKAGE_INSTALLING_TMP_DIR" &&
    run ninja -C "$PACKAGE_INSTALLING_TMP_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}


########################################################################

list_all_installed_libs() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
        cd  "$MY_INSTALL_DIR" || return 1
    else
        return 0
    fi

    for item in *
    do
        if is_package_installed "$item" ; then
            if [ -d "$MY_INSTALL_DIR/$item/libs" ] ; then
                find "$MY_INSTALL_DIR/$item/libs" -name "lib*\.a"
            fi
        fi
    done
}

__ldd() {
    [ -z "$1" ] && {
        error "__ldd <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    is_package_installed "$1" || {
        error "package [$1] is not installed."
        return 1
    }

    [ -z "$3" ] && die "type is not specified."
    [ -z "$4" ] && die "name is not specified."

    READELF="$(echo_path_of_tool_in_the_toolchain readelf)"

    ldd_recursion() {
        [ -z "$1" ] && {
            error "__ldd <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
            return 1
        }

        is_package_installed "$1" || {
            error "package [$1] is not installed."
            return 1
        }

        [ -z "$3" ] && die "type is not specified."
        [ -z "$4" ] && die "name is not specified."

        FILE_PATH="$MY_INSTALL_DIR/$1/$2/$3/$4"
        [ -f "$FILE_PATH" ] || die "$FILE_PATH not exist."
        echo "$FILE_PATH"

        DLL=$("$READELF" -d "$FILE_PATH" | grep ".so" | sed 's/.*\[\(.*\)\].*/\1/')
        for item in $DLL
        do
            ldd_recursion $(read_ldd_cache $item) $(expr "$5" + 1)
        done
    }

    ldd_recursion "$1" "$2" "$3" "$4" 0
}

list_tools_in_the_toolchain() {
    list cc cxx cpp as ar ranlib ld nm strip size strings objdump objcopy readelf dlltool addr2line
}

list_flags_used_by_tools_in_the_toolchain() {
    list CFLAGS CXXFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH PKG_CONFIG_LIBDIR
}

echo_path_of_tool_in_the_toolchain() {
    case $1 in
        cc)  command -v cc  || command -v gcc || command -v clang   ;;
        cxx) command -v c++ || command -v g++ || command -v clang++ ;;
        *)   command -v "$1"
    esac
}

inspect_install_arguments() {
    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    unset USER_SPECIFIED_PACKAGES

    unset DRYRUN

    LOG_LEVEL_QUIET=0
    LOG_LEVEL_NORMAL=1
    LOG_LEVEL_VERBOSE=2
    LOG_LEVEL_TRACE=3
    LOG_LEVEL_DEBUG=4

    LOG_LEVEL=$LOG_LEVEL_NORMAL

    BUILD_NJOBS=$NATIVE_OS_NCPU

    BUILD_TYPE=release

    LINK_TYPE=shared-prefered

    INSTALL_EXE=yes
    INSTALL_MAN=yes
    INSTALL_DOC=yes
    INSTALL_LIB=yes

    KEEP_INSTALLING_DIR=no

    TREE_ARGS='--dirsfirst'

    while [ -n "$1" ]
    do
        case "$1" in
            --china)
                ;;
            --xtrace|-x)
                LOG_LEVEL=$LOG_LEVEL_TRACE
                ;;
            --debug|-d)
                LOG_LEVEL=$LOG_LEVEL_DEBUG
                ;;
            --verbose|-v)
                LOG_LEVEL=$LOG_LEVEL_VERBOSE
                ;;
            --quiet|-q)
                LOG_LEVEL=$LOG_LEVEL_QUIET
                ;;
            --dry-run)
                DRYRUN=yes
                ;;
            --keep-installing-dir)
                KEEP_INSTALLING_DIR=yes
                ;;
            --tree-args=*)
                TREE_ARGS=$(getvalue "$1")
                ;;
            --build-type=*)
                BUILD_TYPE=$(getvalue "$1")
                case $BUILD_TYPE in
                    debug|release) ;;
                    '') die "--build-type=<VALUE>, VALUE must not be empty." ;;
                    *)  die "--build-type=<VALUE>, VALUE must be one of debug release"
                esac
                ;;
            --install-doc)
                INSTALL_DOC=yes
                ;;
            --install-man)
                INSTALL_MAN=yes
                ;;
            --install-exe)
                INSTALL_EXE=yes
                ;;
            --install-lib=*)
                INSTALL_LIB=$(getvalue "$1")
                case $INSTALL_LIB in
                    static|shared|both|yes|no) ;;
                    '') die "--install-lib=<VALUE>, VALUE must not be empty." ;;
                    *)  die "--install-lib=<VALUE>, VALUE must be one of static shared both yes no"
                esac
                ;;
            --link-type=*)
                LINK_TYPE=$(getvalue "$1")
                case $LINK_TYPE in
                    static-only|shared-only|static-prefered|shared-prefered) ;;
                    '') die "--link-type=<VALUE>, VALUE must not be empty." ;;
                    *)  die "--link-type=<VALUE>, VALUE must be one of static-only shared-only static-prefered shared-prefered"
                esac
                ;;
            --jobs=*)
                BUILD_NJOBS=$(getvalue "$1")
                is_integer "$BUILD_NJOBS" || die "--jobs=<VALUE>, VALUE must be a integer."
                ;;
            [a-z]*)
                if [ "$1" = 'all' ] ; then
                    USER_SPECIFIED_PACKAGES="$(__list_available_packages)"
                else
                    if [ -z "$USER_SPECIFIED_PACKAGES" ] ; then
                        USER_SPECIFIED_PACKAGES="$1"
                    else
                        USER_SPECIFIED_PACKAGES="$USER_SPECIFIED_PACKAGES $1"
                    fi
                fi
                ;;
            *)  die "unrecognized argument: $1"
        esac
        shift
    done

    if [ "$INSTALL_LIB" = yes ] ; then
        INSTALL_LIB=both
    fi


    if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
        exec 1>/dev/null
        exec 2>&1
    fi

    if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_DEBUG" ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi

    LD_LIBRARY_DIR_OLD="$LD_LIBRARY_DIR"
}

__is_core_tools_installed() {
    [ -d "$MY_HOME_DIR" ]               || return 1
    [ -d "$MY_HOME_DIR/core" ]          || return 1
    [ -d "$MY_HOME_DIR/core/bin" ]      || return 1
    [ -e "$MY_HOME_DIR/core/bin/uppm" ] || return 1

    for item in bash gnu-coreutils util-linux findutils gawk gsed grep tree curl git unzip gtar gzip xz bzip2 lzip patch patchelf pkg-config yq
    do
        "$MY_HOME_DIR/core/bin/uppm" is-package-installed "$item" || return 1
    done

    return 0
}

__setup() {
    CURRENT_USER__NAME="$(id -n -u)"
    CURRENT_GROUP_NAME="$(id -n -g)"

    if [ -d "$MY_HOME_DIR" ] ; then
        if [ -r "$MY_HOME_DIR" ] && [ -w "$MY_HOME_DIR" ] && [ -x "$MY_HOME_DIR" ] ; then
            :
        else
            if [ -r /opt ] && [ -w /opt ] && [ -x /opt ] ; then
                     chown -R "$CURRENT_GROUP_NAME:$CURRENT_USER__NAME" "$MY_HOME_DIR"
            else
                sudo chown -R "$CURRENT_GROUP_NAME:$CURRENT_USER__NAME" "$MY_HOME_DIR"
            fi
        fi
    else
        if [ -r /opt ] && [ -w /opt ] && [ -x /opt ] ; then
                 install -g "$CURRENT_GROUP_NAME" -o "$CURRENT_USER__NAME" -d "$MY_HOME_DIR"
        else
            sudo install -g "$CURRENT_GROUP_NAME" -o "$CURRENT_USER__NAME" -d "$MY_HOME_DIR"
        fi
    fi

    if [ -d    "$MY_HOME_DIR/core/bin" ] ; then
        rm -rf "$MY_HOME_DIR/core/bin"
    fi

    install -d "$MY_HOME_DIR/core/bin"

    #################################################################################

    unset NATIVE_OS_KIND
    unset NATIVE_OS_ARCH

    NATIVE_OS_KIND="$(uname -s | tr A-Z a-z)"
    NATIVE_OS_ARCH="$(uname -m)"

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        NATIVE_OS_KIND=macos
    fi

    if [ "$NATIVE_OS_ARCH" = 'amd64' ] ; then
        NATIVE_OS_ARCH=x86_64
    elif [ "$NATIVE_OS_ARCH" = 'aarch64' ] ; then
        NATIVE_OS_ARCH=arm64
    fi

    #################################################################################

    if [ "$1" = '--use-system-package-manager' ] ; then
        case $NATIVE_OS_KIND in
            linux)
                if [ -e /etc/os-release ] ; then
                    (
                        unset ID

                        . /etc/os-release

                        case $ID in
                            debian)  __setup_ubuntu ;;
                            ubuntu)  __setup_ubuntu ;;
                            alpine)  __setup_alpine ;;
                            centos)  __setup_centos ;;
                            fedora)  __setup_fedora ;;
                            rhel)    __setup_fedora ;;
                            gentoo)  __setup_gentoo ;;
                            manjaro) __setup_manjaro ;;
                            arch)    __setup_archlinux ;;
                            void)    __setup_voidlinux ;;
                            linuxmint) __setup_ubuntu ;;
                            opensuse-leap) ;;
                        esac
                    )
                fi
                ;;
            macos)   __setup_macos   ;;
            freebsd) __setup_freebsd ;;
            openbsd) __setup_openbsd ;;
            netbsd)  __setup__netbsd ;;
            *) die "$(uname -s) is not supported yet."
        esac

        ln -s /usr/bin/true "$MY_HOME_DIR/core/bin/uppm"
    else
        [ "$(id -u)" -ne 0 ] && sudo=sudo
        __setup_uppm
    fi

    success "ppkg have been succefully setup."
}

__setup_ubuntu() {
    run $sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys CC86BB64
    run $sudo add-apt-repository ppa:rmescandon/yq
    run $sudo apt -y update
    run $sudo apt -y install bash findutils gawk sed grep tree unzip tar gzip lzip patch patchelf pkg-config golang git curl cmake g++ ninja-build make libtool yq
}

__setup_alpine() {
    run $sudo apt update
    run $sudo apt add bash findutils gawk sed grep tree unzip tar gzip lzip patch patchelf pkgconf go yq git curl cmake g++ ninja make libtool
}

__setup_macos() {
    command -v brew > /dev/null || {
        XX="$MY_HOME_DIR/homebrew-install.sh"
        run rm -f   "$XX"
        run curl -o "$XX" -L 'https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh'
        run bash    "$XX"
    }

    run brew update
    run brew install bash coreutils findutils gawk gsed grep tree unzip gnu-tar gzip lzip gpatch patchelf pkg-config yq git curl cmake ninja make libtool
}

__setup_freebsd() {
    run $sudo pkg update
    run $sudo pkg install -y bash coreutils findutils gawk gsed gnugrep tree unzip gtar gzip lzip patch patchelf pkgconf go go-yq git curl cmake gcc ninja gmake libtool
}

__setup_openbsd() {
    run $sudo pkg_add update
    run $sudo pkg_add -y bash findutils gawk gsed gnugrep tree unzip gtar gzip lzip patch patchelf pkgconf go go-yq git curl cmake gcc ninja gmake libtool
}

__setup__netbsd() {
    run $sudo pkgin -y update
    run $sudo pkgin -y install -y bash findutils gawk gsed gnugrep tree unzip gtar gzip lzip patch patchelf pkgconf go go-yq git curl cmake gcc ninja gmake libtool
}

__setup_uppm() {
    unset FETCH_TOOL

    for FETCH_TOOL in curl wget http lynx aria2c axel
    do
        if command_exists_in_filesystem "$FETCH_TOOL" ; then
            break
        else
            unset FETCH_TOOL
        fi
    done

    if [ -z "$FETCH_TOOL" ] ; then
        error "no any fetch tool[curl, wget, http, lynx, aria2c, axel] found, you could download curl from $CORE_TOOL_BASE_URL/curl, then try again."
        return 1
    else
        unset FETCH_TOOL
    fi

    case $NATIVE_OS_KIND in
        linux)   CORE_TOOL_VERSION='2022.08.16' ;;
        macos)   CORE_TOOL_VERSION='2022.08.16' ;;
        freebsd) CORE_TOOL_VERSION='2022.08.16' ;;
        openbsd) CORE_TOOL_VERSION='2022.08.16' ;;
         netbsd) CORE_TOOL_VERSION='2022.08.16' ;;
              *) die "$(uname -s) has not been supported yet."
    esac

    CORE_TOOL_BASE_URL="https://github.com/leleliu008/ppkg-core-$NATIVE_OS_KIND-$NATIVE_OS_ARCH/releases/download/$CORE_TOOL_VERSION"

    SETUP_WORKING_DIR=$(mktemp -d)

    # https://curl.se/docs/caextract.html
    fetch 'https://curl.se/ca/cacert.pem' --output-dir="$SETUP_WORKING_DIR"

    command -v tar > /dev/null || {
        fetch "$CORE_TOOL_BASE_URL/tar" --output-dir="$SETUP_WORKING_DIR"
        run chmod +x "$SETUP_WORKING_DIR/tar"
    }

    command -v xz > /dev/null || {
        fetch "$CORE_TOOL_BASE_URL/xz" --output-dir="$SETUP_WORKING_DIR"
        run chmod +x "$SETUP_WORKING_DIR/xz"
    }

    export PATH="$SETUP_WORKING_DIR:$PATH"

    run install -d                         "$MY_HOME_DIR/core/etc/ssl/certs"
    run cp "$SETUP_WORKING_DIR/cacert.pem" "$MY_HOME_DIR/core/etc/ssl/certs"

    UPPM_INSTALL_URL='https://raw.githubusercontent.com/leleliu008/ppkg-core-linux-x86_64/master/uppm-2022.08.23-linux-x86_64.tar.xz'

    fetch "$UPPM_INSTALL_URL" --output-dir="$SETUP_WORKING_DIR"

    run tar vxf "$SETUP_WORKING_DIR/uppm-2022.08.23-linux-x86_64.tar.xz" --overwrite --strip-components=1 --no-same-owner -C "$MY_HOME_DIR/core"

    rm "$MY_HOME_DIR/core/installed-files"
    rm "$MY_HOME_DIR/core/installed-metadata-ppkg"

    export SSL_CERT_FILE="$MY_HOME_DIR/core/etc/ssl/certs/cacert.pem"

    run "$MY_HOME_DIR/core/bin/uppm env"

    run "$MY_HOME_DIR/core/bin/uppm update"

    cat >> ~/.uppm/repos.d/offical/.git/config <<EOF
[user]
    email = leleliu008@gmail.com
    name = leleliu008
EOF

    for item in bash gnu-coreutils util-linux findutils gawk gsed grep tree curl git unzip gtar gzip xz bzip2 lzip patch patchelf pkg-config yq
    do
        run "$MY_HOME_DIR/core/bin/uppm install $item"
    done
}

init() {
    __is_core_tools_installed || {
        error "please run ${COLOR_GREEN}$_0 setup${COLOR_OFF} command first, then try again."
        return 1
    }

    # https://man7.org/linux/man-pages/man8/ld.so.8.html
    if [ -z "$LD_LIBRARY_DIR" ] ; then
        export LD_LIBRARY_DIR="$MY_HOME_DIR/core/lib"
    else
        export LD_LIBRARY_DIR="$MY_HOME_DIR/core/lib:$LD_LIBRARY_DIR"
    fi

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    if [ -z "$ACLOCAL_PATH" ] ; then
        export ACLOCAL_PATH="$MY_HOME_DIR/core/share/aclocal"
    else
        export ACLOCAL_PATH="$MY_HOME_DIR/core/share/aclocal:$ACLOCAL_PATH"
    fi

    # https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables
    if [ -d "$HOME/.uppm/installed/git/libexec/git-core" ] ; then
        export GIT_EXEC_PATH="$HOME/.uppm/installed/git/libexec/git-core"
        export GIT_TEMPLATE_DIR="$HOME/.uppm/installed/git/share/git-core/templates"
    fi

    # https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_default_verify_paths.html
    if [ -f "$MY_HOME_DIR/core/etc/ssl/certs/cacert.pem" ] ; then
        export SSL_CERT_FILE="$MY_HOME_DIR/core/etc/ssl/certs/cacert.pem"
    fi

    if [ -f "$MY_INIT_RC" ] ; then
        .   "$MY_INIT_RC" || die "load $MY_INIT_RC failed."
    else
        cat > "$MY_INIT_RC" <<EOF
# influential environment variables:
#      CC=/usr/bin/cc
#     CXX=/usr/bin/c++
#     CPP=/usr/bin/cpp
#      AS=/usr/bin/as
#      LD=/usr/bin/ld
#      AR=/usr/bin/ar
#      NM=/usr/bin/nm
#    SIZE=/usr/bin/size
#   STRIP=/usr/bin/strip
#  RANLIB=/usr/bin/ranlib
# STRINGS=/usr/bin/strings
# OBJDUMP=/usr/bin/objdump
# OBJCOPY=/usr/bin/objcopy
# READELF=/usr/bin/readelf

#   CFLAGS=
# CPPFLAGS=
#  LDFLAGS=

# https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
# PKG_CONFIG_LIBDIR=
# PKG_CONFIG_PATH=

# MACOSX_DEPLOYMENT_TARGET=10.15
EOF
    fi

    [ -e "$MY_HOME_DIR/repos" ] || {
        printf '%s\n' "offical=$MY_OFFICAL_FORMULA_REPO_URL"  > "$MY_HOME_DIR/repos"
    }

    unset NATIVE_OS_KIND
    unset NATIVE_OS_TYPE
    unset NATIVE_OS_NAME
    unset NATIVE_OS_VERS
    unset NATIVE_OS_ARCH
    unset NATIVE_OS_NCPU
    unset NATIVE_OS_LIBC
    unset NATIVE_OS_SUBS

    NATIVE_OS_KIND=$(os kind)
    NATIVE_OS_TYPE=$(os type)
    NATIVE_OS_NAME=$(os name)
    NATIVE_OS_VERS=$(os vers)
    NATIVE_OS_ARCH=$(os arch)
    NATIVE_OS_NCPU=$(os ncpu)
    NATIVE_OS_LIBC=$(os libc)
    NATIVE_OS_SUBS=$(os subs)
    NATIVE_OS_EUID=$(os euid)

    if [ "$NATIVE_OS_EUID" -ne 0 ] ; then
        sudo=sudo
    fi

    TIMESTAMP_UNIX="$(date +%s)"

    __setup_PATH_env
}

bppend_to_ACLOCAL_PATH() {
    case ":${ACLOCAL_PATH}:" in
        *:"$1":*) ;;
        *) export ACLOCAL_PATH="$1:$ACLOCAL_PATH" ;;
    esac
}

bppend_to_LD_LIBRARY_DIR() {
    case ":${LD_LIBRARY_DIR}:" in
        *:"$1":*) ;;
        *) export LD_LIBRARY_DIR="$1:$LD_LIBRARY_DIR" ;;
    esac
}

__setup_PATH_env() {
    # pip install --user <PKG>
    bppend_to_PATH "$HOME/.local/bin"

    # cpan install to default local location
    bppend_to_PATH "$HOME/perl5/bin"

    if [ -f "$HOME/.cargo/env" ] ; then
        .   "$HOME/.cargo/env"
    fi

    for dir in "$HOME/.uppm/installed"
    do
        if [ -d "$dir" ] ; then
            for item in $(ls "$dir")
            do
                if [ -d "$dir/$item" ] && [ -f "$dir/$item/installed-metadata-uppm" ] ; then
                    if [ -d "$dir/$item/bin" ] ; then
                        bppend_to_PATH "$dir/$item/bin"
                    fi

                    if [ -d "$dir/$item/lib" ] ; then
                        bppend_to_LD_LIBRARY_DIR "$dir/$item/lib"
                    fi

                    if [ -d "$dir/$item/share/aclocal" ] ; then
                        bppend_to_ACLOCAL_PATH "$dir/$item/share/aclocal"
                    fi
                fi
            done
        fi
    done

    bppend_to_PATH "$MY_HOME_DIR/core/bin"
}

help() {
    if command -v base64 > /dev/null ; then
        LOGO_BASE64_ENCODED='ICAgICAgICAgICAgIF8gICAgICAgICAKIF8gX18gIF8gX18gfCB8IF9fX18gXyAKfCAnXyBcfCAn
XyBcfCB8LyAvIF9gIHwKfCB8XykgfCB8XykgfCAgIDwgKF98IHwKfCAuX18vfCAuX18vfF98XF9c
X18sIHwKfF98ICAgfF98ICAgICAgICB8X19fLyAK'

        if command -v lolcat > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat -S 350
        elif command -v awk > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat_awk
        else
            printf '%b\n' "${COLOR_BLUE}$(printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d)${COLOR_OFF}"
        fi
    fi

    echo "
${COLOR_GREEN}A portable package manager for UNIX.${COLOR_OFF}

${COLOR_GREEN}ppkg <ACTION> [ARGUMENT...]${COLOR_OFF}

${COLOR_GREEN}ppkg --help${COLOR_OFF}
${COLOR_GREEN}ppkg -h${COLOR_OFF}
    show help of this command.

${COLOR_GREEN}ppkg --version${COLOR_OFF}
${COLOR_GREEN}ppkg -V${COLOR_OFF}
    show version of this command.

${COLOR_GREEN}ppkg --homedir${COLOR_OFF}
    show home directory of this software.

${COLOR_GREEN}ppkg --homepage${COLOR_OFF}
    show home webpage of this software.

${COLOR_GREEN}ppkg env${COLOR_OFF}
    show current machine os info.

${COLOR_GREEN}ppkg integrate zsh   [--output-dir=<DIR>] [-x | --china]${COLOR_OFF}
    download a zsh-completion script file to a approprivate location.

${COLOR_GREEN}ppkg update${COLOR_OFF}
    update the formula repositories.

${COLOR_GREEN}ppkg cleanup${COLOR_OFF}
    cleanup the unused cache.

${COLOR_GREEN}ppkg ls-available${COLOR_OFF}
    list the available packages.

${COLOR_GREEN}ppkg ls-installed${COLOR_OFF}
    list the installed packages.

${COLOR_GREEN}ppkg ls-outdated${COLOR_OFF}
    list the outdated  packages.

${COLOR_GREEN}ppkg is-available <PACKAGE-NAME> [eq|ne|ge|gt|le|lt VERSION]${COLOR_OFF}
    is PACKAGE available?

${COLOR_GREEN}ppkg is-installed <PACKAGE-NAME>${COLOR_OFF}
    is PACKAGE installed?

${COLOR_GREEN}ppkg is-outdated  <PACKAGE-NAME>${COLOR_OFF}
    is PACKAGE outdated?

${COLOR_GREEN}ppkg search <KEYWORD>${COLOR_OFF}
    search available packages.
 
${COLOR_GREEN}ppkg formula create <PACKAGE-NAME>${COLOR_OFF}
    create a new formula.

${COLOR_GREEN}ppkg formula delete <PACKAGE-NAME>${COLOR_OFF}
    delete a exist formula.

${COLOR_GREEN}ppkg formula rename <P1> <P2>${COLOR_OFF}
    rename a exist formula to new name.

${COLOR_GREEN}ppkg formula view <PACKAGE-NAME>${COLOR_OFF}
    view the formula of the given package.

${COLOR_GREEN}ppkg formula edit <PACKAGE-NAME>${COLOR_OFF}
    edit the formula of the given package.

${COLOR_GREEN}ppkg formula list${COLOR_OFF}
    list all formulas.

${COLOR_GREEN}ppkg formula-repo [list]${COLOR_OFF}
    list formula-repos.

${COLOR_GREEN}ppkg formula-repo add <FORMULA-REPO-NAME> <FORMULA-REPO-URL>${COLOR_OFF}
    add a new formula-repo.

${COLOR_GREEN}ppkg formula-repo del <FORMULA-REPO-NAME>${COLOR_OFF}
    delete a exist formula-repo.

${COLOR_GREEN}ppkg tree <PACKAGE-NAME> [--dirsfirst | -L N]${COLOR_OFF}
    list files of the given installed package in a tree-like format.

${COLOR_GREEN}ppkg pack <PACKAGE-NAME> <7z|zip|tar.gz|tar.xz|tar.bz2>${COLOR_OFF}
    pack the given installed package.

${COLOR_GREEN}ppkg logs <PACKAGE-NAME>${COLOR_OFF}
    show logs of the given installed package.

${COLOR_GREEN}ppkg info <PACKAGE-NAME> [KEY|--json|--yaml|--shell]${COLOR_OFF}
    show information of the given package.

${COLOR_GREEN}ppkg info @all [--json|--yaml|--shell]${COLOR_OFF}
    show information of all the available packages.

${COLOR_GREEN}ppkg fetch <PACKAGE-NAME>${COLOR_OFF}
    download formula resources of the given package to the cache.

${COLOR_GREEN}ppkg fetch @all${COLOR_OFF}
    download formula resources of all available packages to the cache.

${COLOR_GREEN}ppkg depends <PACKAGE-NAME>${COLOR_OFF}
    show the depends of the given package.

${COLOR_GREEN}ppkg homepage [--open] [PACKAGE-NAME]${COLOR_OFF}
    show or open the homepage of the given package or this project in web browser.

${COLOR_GREEN}ppkg install   <PACKAGE-NAME>... [--jobs=N -q -v -d -x --dry-run --keep-installing-dir]${COLOR_OFF}
    install the given packages.

${COLOR_GREEN}ppkg reinstall <PACKAGE-NAME>... [--jobs=N -q -v -d -x --dry-run --keep-installing-dir]${COLOR_OFF}
    reinstall the given packages.

${COLOR_GREEN}ppkg upgrade   [PACKAGE-NAME]... [--jobs=N -q -v -d -x --dry-run --keep-installing-dir]${COLOR_OFF}
    upgrade the given packages or all outdated packages.

${COLOR_GREEN}ppkg upgrade @self  [-x | --china]${COLOR_OFF}
    upgrade this software.

${COLOR_GREEN}ppkg uninstall <PACKAGE-NAME>...${COLOR_OFF}
    uninstall the given packages.
    "

    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    set -e

    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_05_03
    #IFS_DEFAULT=$(printf ' \t\n')
    #IFS=$IFS_DEFAULT

    # MY represents this software's

    MY_VERSION=0.1.2

    MY_HOME_PAGE="https://github.com/leleliu008/ppkg"
    MY_OFFICAL_FORMULA_REPO_URL="https://github.com/leleliu008/ppkg-formula-repository.git"
    MY_UPGRAGE_URL='https://raw.githubusercontent.com/leleliu008/ppkg/master/bin/ppkg'

    MY_HOME_DIR="/opt/ppkg"

    MY_FORMULA_REPO_DIR="$MY_HOME_DIR/repos.d"
    MY_INSTALL_DIR="$MY_HOME_DIR/installed"
    MY_BACKUP_DIR="$MY_HOME_DIR/backup.d"
    MY_CACHE_DIR="$MY_HOME_DIR/cache.d"

    MY_INIT_RC="$MY_HOME_DIR/init.rc"

    unset XTRACE
    unset COUNTRY

    for arg in $@
    do
        case $arg in
            --xtrace|-x) XTRACE=yes; set -x ;;
            --china)     COUNTRY=china ;;
            *) [ "$XTRACE" = yes ] && [ -n "$COUNTRY" ] && break
        esac
    done

    case $1 in
        ''|--help|-h) 
            help
            return 0
            ;;
        --version|-V)
            printf '%s\n' "$MY_VERSION"
            return 0
            ;;
        --homedir)
            printf '%s\n' "$MY_HOME_DIR"
            return 0
            ;;
        --homepage)
            printf '%s\n' "$MY_HOME_PAGE"
            return 0
            ;;
        env)
            printf '%b\n' "${COLOR_GREEN}ppkg $MY_VERSION${COLOR_OFF}

${COLOR_GREEN}portable package manager for UNIX.${COLOR_OFF}

${COLOR_GREEN}current-machine-os${COLOR_OFF}"
            os
            return 0
            ;;
        setup)
            shift
            __setup $@
            return 0
            ;;
    esac

    init

    case $1 in
        ls-available) shift; __list_available_packages ;;
        ls-installed) shift; __list_installed_packages ;;
        ls-outdated)  shift; __list__outdated_packages ;;

        is-available) shift; is_package_available $@ ;;
        is-installed) shift; is_package_installed $@ ;;
        is-outdated)  shift; is_package__outdated $@ ;;

        formula-repo)
            shift
            case $1 in
                list) shift; __list_formula_repositories ;;
                add)  shift; __add_a_formula_repo $@ ;;
                del)  shift; __del_a_formula_repo $@ ;;
                *) help 1
            esac
            ;;
        formula)
            shift
            case $1 in
                create) shift; __create_formula_of_the_given_package $@ ;;
                delete) shift; __delete_formula_of_the_given_package $@ ;;
                rename) shift; __rename_formula_of_the_given_package $@ ;;
                view)   shift;   __view_formula_of_the_given_package $@ ;;
                edit)   shift;   __edit_formula_of_the_given_package $@ ;;
                list)   shift; __list_formulas ;;
                   *)   help 1
            esac
            ;;

        update)  __update_formula_repositories ;;
        cleanup) __cleanup ;;

        search)  shift; __search_packages "$*" ;;
 
        install) shift;   __install_the_given_packages $@ ;;
      reinstall) shift; __reinstall_the_given_packages $@ ;;
      uninstall) shift; __uninstall_the_given_packages $@ ;;

        upgrade)
            shift
            case $1 in
                @self)
                    shift
                    __upgrade_self "$MY_UPGRAGE_URL" $@ ;;
                *)  __upgrade_packages $@ ;;
            esac
            ;;
        integrate)
            shift
            case $1 in
                zsh) __integrate_zsh_completions 'https://raw.githubusercontent.com/leleliu008/ppkg/master/zsh-completion/_ppkg' ;;
                *)   die "ppkg integrate $1: not support."
            esac
            ;;
        homepage) shift;  __show_or_open_homepage_of_the_given_package $@ ;;
        depends)  shift; __show_packages_depended_by_the_given_package $@ ;;
        fetch)    shift;        __fetch_resources_of_the_given_package $@ ;;

        logs) shift; __logs_the_given_installed_package $@ ;;
        pack) shift; __pack_the_given_installed_package $@ ;;
        tree) shift; __tree_the_given_installed_package $@ ;;

        info)
            shift
            __show_infomation_of_the_given_package $@
            ;;
        ldd)
            shift
            __ldd $@
            ;;
        gen-github-workflows)
            shift
            __gen_github_workflows $@
            ;;
        compare-versions)
            shift
            __compare_versions_with_brew
            ;;
        *)  die "unrecognized argument: $1"
    esac
}

main $@
